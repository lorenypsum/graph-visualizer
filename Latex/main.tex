\documentclass[12pt,a4paper]{article}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
% Caixa reutilizável para destacar algoritmos

\usepackage{amsmath, amssymb, amsthm}
\usepackage{geometry}
\geometry{a4paper, margin=1in}
% Hiperlinks e bookmarks: ativar Unicode e evitar destinos duplicados para figuras/tabelas
\usepackage[unicode,hypertexnames=false]{hyperref}
% Melhora o manuseio de marcadores/outline do PDF e estabiliza reexecuções
\usepackage{bookmark}
\usepackage[backend=bibtex,style=numeric]{biblatex}
\usepackage{csquotes}
\usepackage[brazil]{babel}
\usepackage{microtype}
\usepackage{float} % para usar o modificador [H] e fixar a posição do float
\usepackage{tikz}
\usepackage[most]{tcolorbox}
    \tcbset{colback=green!15,colframe=purple!15,boxrule=0.6pt}
\usepackage{listings}
\usepackage{xcolor}

% Sanitizar conteúdo escrito em bookmarks/TOC (evita "Missing character ... nullfont")
% Substitui comandos frágeis/matemática por versões simples apenas nos marcadores
\pdfstringdefDisableCommands{%
    \def\\{}% ignora quebras de linha em captions
    \def\texttt#1{#1}% remove estilo monoespaçado em bookmarks
    \def\emph#1{#1}% remove ênfase em bookmarks
    \def\bfseries{}% ignora negrito
    \def\itshape{}% ignora itálico
    \def\_{}% evita sublinhado literal em bookmarks
    \def\leq{\string<=}% mapeia símbolos comuns
    \def\geq{\string>=}%
    \def\times{\string x}%
    \def\cup{\string U}%
    \def\cap{\string n}%
    \def\to{->}%
    \def\leadsto{->}%
    % Atenção: \delta não tem argumento; definir com parâmetro causa fuga de argumento
    \def\delta{delta}%
}

% Corrigir nomes de âncoras de hyperref para figuras/tabelas quando a numeração for reiniciada por seção
% (evita "pdfTeX warning (ext4): destination with the same identifier (name{figure.N})...")
\makeatletter
\providecommand*{\theHfigure}{\thefigure}
\renewcommand{\theHfigure}{\thesection.\arabic{figure}}
\providecommand*{\theHtable}{\thetable}
\renewcommand{\theHtable}{\thesection.\arabic{table}}
\makeatother

% Estilo para listagens Python
\lstdefinestyle{pystyle}{
    language=Python,
    basicstyle=\ttfamily\small,
    numbers=left,
    numbersep=6pt,
    tabsize=4,
    showstringspaces=false,
    breaklines=true,
    keywordstyle=\color{blue!70!black}\bfseries,
    commentstyle=\color{green!50!black}\itshape,
    stringstyle=\color{red!60!black},
    inputencoding=utf8,
    extendedchars=true,
    % Mapear caracteres UTF-8 comuns em PT/BR e pontuação tipográfica para LaTeX
    literate={á}{{\'{a}}}1 {é}{{\'{e}}}1 {í}{{\'{\i}}}1 {ó}{{\'{o}}}1 {ú}{{\'{u}}}1
             {Á}{{\'{A}}}1 {É}{{\'{E}}}1 {Í}{{\'{\I}}}1 {Ó}{{\'{O}}}1 {Ú}{{\'{U}}}1
             {à}{{\`{a}}}1 {À}{{\`{A}}}1 {â}{{\^{a}}}1 {Â}{{\^{A}}}1 {ã}{{\~{a}}}1 {Ã}{{\~{A}}}1
             {ê}{{\^{e}}}1 {Ê}{{\^{E}}}1 {ô}{{\^{o}}}1 {Ô}{{\^{O}}}1 {õ}{{\~{o}}}1 {Õ}{{\~{O}}}1
             {ç}{{\c{c}}}1 {Ç}{{\c{C}}}1 {ü}{{\"{u}}}1 {Ü}{{\"{U}}}1
             {ñ}{{\~{n}}}1 {Ñ}{{\~{N}}}1
             {“}{{``}}1 {”}{{''}}1 {’}{{'}}1 {–}{{-}}1 {—}{{-}}1 {…}{{...}}1 {‑}{{-}}1
             {✅}{{$\checkmark$}}1 {✔}{{$\checkmark$}}1 {❌}{{$\times$}}1 {✗}{{$\times$}}1
}

% Algoritmos: paleta verde
\newtcbtheorem[number within=section]{algobox}{Algoritmo}%
{enhanced,breakable,sharp corners,boxsep=6pt,arc=1pt,
 colback=green!3,colframe=green!30,fonttitle=\bfseries,coltitle=black,boxrule=0.6pt}{th}

% Teoremas: paleta azul 
\newtcbtheorem[number within=section]{teobox}{Teorema}%
{enhanced,breakable,sharp corners,boxsep=6pt,arc=1pt,
 colback=blue!3,colframe=blue!20,fonttitle=\bfseries,coltitle=black,boxrule=0.6pt}{th}

 % Lemas: paleta laranja
\newtcbtheorem[number within=section]
{lemabox}{Lema}%
{enhanced,breakable,sharp corners,boxsep=6pt,arc=1pt,
 colback=orange!3,colframe=orange!35,fonttitle=\bfseries,coltitle=black,boxrule=0.6pt}{lem}

% Caixa para código Python com tcolorbox + listings
% Caixa numerada para código Python (numeração por seção)
\newtcblisting[auto counter, number within=section]{pybox}[2][]{
    enhanced, breakable, sharp corners, boxsep=6pt, arc=1pt,
    colback=gray!3, colframe=gray!40, fonttitle=\bfseries, coltitle=black, boxrule=0.6pt,
    listing only, listing engine=listings,
    title={Função~\thetcbcounter: #2}, #1,
    listing options={style=pystyle}
}

\usetikzlibrary{positioning,arrows.meta,fit,calc}

\addbibresource{referencias.bib}

\title{Análise e Implementação de Algoritmos de Busca de uma r-Arborescência Inversa de Custo Mínimo em Grafos Dirigidos com Aplicação Didática Interativa}
\author{Orientador: Mário Leston 
\and Discentes: Lorena Silva Sampaio, Samira Haddad}
\date{\today}

\begin{document}

\maketitle

\section{Introdução}

\paragraph{}
Encontrar uma \textit{r-arborescência inversa de custo mínimo} em grafos dirigidos é um problema estudado em ciência da computação desde os anos 1960, com formulações fundamentais apresentadas por Jack Edmonds em 1967 \cite{edmonds1967optimum}.

\paragraph{}
Essa busca dialoga com um princípio formulado na Idade Média por Guilherme de Ockham: a navalha de Occam (princípio da parcimônia), uma heurística filosófica segundo a qual, entre explicações concorrentes para um fenômeno, devemos preferir a mais simples ou a que faz menos suposições.

\paragraph{}
Podemos pensar na navalha de Occam como critério de escolha entre explicações por meio de uma \textit{teia explicativa mínima}: uma estrutura que conecta fatos ou observações com o mínimo de relações explicativas necessárias.
Quando tais relações envolvem dependência ou causalidade, podemos representá-las pictograficamente como setas direcionadas entre os fatos (as hipóteses aparecem como rótulos dessas setas).
Para refinar o modelo, associamos um custo a cada relação (por exemplo, o esforço para validar a relação ou a complexidade da explicação).

\paragraph{}
Encontrar a \textit{teia explicativa mínima} equivale, nessa metáfora, a encontrar uma \textit{r-arborescência de custo mínimo}: fixamos um vértice raiz \(r\) (a explicação inicial) e escolhemos um conjunto mínimo de relações explicativas de modo que todos os fatos tenham um caminho dirigido que leve a \(r\), minimizando o custo total das arestas.

\paragraph{}
A \textit{r-arborescência} (também chamada \textit{out-arborescência}) orienta as arestas para fora de \(r\): cada vértice \(v\neq r\) tem exatamente uma aresta de entrada, e há um caminho dirigido único de \(r\) até \(v\). Já a \textit{r-arborescência inversa} (\textit{in-arborescência}) orienta as arestas em direção a \(r\): cada \(v\neq r\) tem exatamente uma aresta de saída, e de cada vértice parte um caminho dirigido único até \(r\) \cite{edmonds1967optimum,frank2014}.

\paragraph{}
Com essa distinção em mente, este trabalho concentra-se na variante inversa. Formalmente, dado um grafo dirigido \(G=(V,E)\) com custos \(c:E\to\mathbb{R}^+\) nas arestas e um vértice raiz \(r\in V\), procura-se uma \textit{r-arborescência inversa} — isto é, uma árvore direcionada que atinja todos os vértices por caminhos dirigidos até \(r\) — que minimize o custo total das arestas selecionadas (cf. \cite{edmonds1967optimum,frank2014}).

\paragraph{}
Nosso interesse, porém, não é apenas encontrar a arborescência mínima: o percurso até ela também importa, pois revela propriedades estruturais dos dígrafos e ilumina técnicas distintas de otimização. Por isso, investigamos duas rotas clássicas e complementares: (i) o algoritmo de Chu--Liu/Edmonds, que opera por normalização dos custos das arestas de entrada, seleção sistemática de arestas de custo zero e contração de ciclos até obter um grafo reduzido, seguida pela reexpansão para reconstrução da solução \cite{chu1965,edmonds1967optimum}; e (ii) a abordagem dual, em duas fases, de András Frank, fundamentada em cortes dirigidos, na qual se maximiza uma função de cortes c-viável para induzir arestas de custo zero e, em seguida, extrai-se a arborescência apenas a partir dessas arestas \cite{frank2014}. Embora assentados em princípios distintos — contração de ciclos no plano primal versus empacotamento/dualidade por cortes —, ambos os paradigmas produzem soluções ótimas e tornam explícitas a variedade de abordagens matemáticas que podem ser empregadas para resolver o mesmo problema.

\paragraph{}
Assim sendo, analisamos e implementamos, em Python, essas duas abordagens, e apresentaremos detalhes das implementações, desafios enfrentados e soluções adotadas. Realizamos testes de volume com milhares de instâncias geradas aleatoriamente, registrando resultados em arquivos CSV e de log; os custos obtidos pelo Chu--Liu/Edmonds e pelas duas variantes de András Frank coincidem, corroborando a correção das implementações.

\paragraph{}
Adicionalmente, desenvolvemos uma aplicação web com fins didáticos, utilizando o framework PyScript e as bibliotecas NetworkX e Matplotlib, que permitem construir grafos dirigidos interativamente, escolher o vértice-raiz, executar o algoritmo de Chu--Liu/Edmonds e acompanhar, passo a passo, a evolução do grafo e o registro detalhado da execução (log). A interface inclui operações de adicionar arestas com pesos, carregar um grafo de teste e exportar a instância em formato JSON, facilitando a experimentação por estudantes e educadores.

\subsection{Justificativa}

\paragraph{}
A busca por uma \textit{r-arborescência inversa de custo mínimo} em grafos dirigidos é um problema clássico com aplicações em diversas áreas, como redes de comunicação, planejamento de rotas, análise de dependências e modelagem de processos. Mas, não precisamos dessa justificação prática para nos interessarmos pelo problema: a riqueza estrutural dos dígrafos e a variedade de técnicas algorítmicas disponíveis o tornam um excelente caso de estudo em otimização combinatória.

\paragraph{}
Do ponto de vista didático, a metáfora da “teia explicativa mínima” torna concreto o porquê de estudarmos arborescências enraizadas: ela mapeia perguntas sobre explicação, alcance e economia de recursos para estruturas dirigidas, servindo de fio condutor nas implementações e nos experimentos que apresentamos.

\subsection{Objetivos}

\paragraph{}
O objetivo principal deste trabalho é analisar, implementar e comparar duas abordagens clássicas para o problema de \textit{r-arborescência de custo mínimo} em grafos dirigidos oferecendo uma aplicação web interativa que facilite o entendimento e a experimentação com o algoritmo de Chu--Liu/Edmonds e o método de András Frank, tornando-o acessível para estudantes e educadores.

\subsection{Estrutura do Trabalho}
\paragraph{}
Resumidamente, o trabalho abrange as seguintes frentes:  

\begin{enumerate}
    \item \textbf{Fundamentação teórica}: revisão da literatura sobre arborescências em grafos dirigidos, incluindo definições, propriedades e resultados relevantes.
    \item \textbf{Análise teórica}: consolidação dos conceitos de dígrafos e arborescências, compondo as formulações primal (normalização de custos e contração/reexpansão de ciclos no algoritmo de Chu--Liu/Edmonds) e dual (cortes dirigidos e função c-viável no método de András Frank), destacando resultados e intuições estruturais.
    \item \textbf{Implementação computacional}: implementação em Python das rotinas de normalização dos custos de entrada, construção de \(F^\ast\), detecção e contração de ciclos e reconstrução da solução (Chu--Liu/Edmonds), bem como das duas fases do método de András Frank; além de uma suíte de testes automatizados em larga escala sobre instâncias aleatórias com até centenas de vértices, verificando a coincidência dos custos entre os métodos e registrando resultados em CSV e log.
    \item \textbf{Aplicação pedagógica}: desenvolvimento de uma aplicação web interativa (PyScript + NetworkX + Matplotlib) que permite montar instâncias, escolher o vértice-raiz e acompanhar, passo a passo, a execução do algoritmo com visualização do grafo e dos pesos das arestas, log textual e importação/exportação em JSON para facilitar a reprodução de experimentos.
\end{enumerate}

Deste modo, o trabalho entrega implementações verificadas de Chu--Liu/Edmonds e András Frank, um visualizador web interativo e testes de volume que confirmam a equivalência de custos, úteis ao estudo e ao ensino de arborescências.

\section{Definições Preliminares}
\paragraph{}
Neste capítulo, reunimos as noções matemáticas básicas necessárias para compreensão completa do texto. 

Fixaremos notações e conceitos (conjuntos, relações, funções, dígrafos, propriedade em dígrafos, dígrafos ponderados, ramificações geradoras, arborescências, funções de custo, dualidade, problemas duais e algoritmos), até chegar à formulação do problema da r-arborescência inversa de custo mínimo e adiamos descrições algorítmicas para capítulos posteriores.

\subsection{Conjuntos}
\paragraph{}
Este trabalho depende profundamente da teoria dos conjuntos, podemos dizer que todos os objetos matemáticos que iremos utilizar nessa dissertação se reduzem a conjuntos e operações entre eles.

\paragraph{}
Um \textbf{conjunto} é uma agregação de objetos distintos com características bem definidas, chamados elementos ou membros do conjunto. Os conjuntos são geralmente representados por letras maiúsculas (por exemplo, \(A\), \(B\), \(C\)) e seus elementos são listados entre chaves (por exemplo, \(A = \{1, 2, 3\}\)). Dois conjuntos são iguais se contêm exatamente os mesmos elementos.

\paragraph{}
Podemos ter conjuntos de qualquer tipo de objeto, incluindo números, letras e elementos da natureza. Para motivar as definições ao longo do texto, usaremos dois exemplos complementares que vamos chamar de exemplos-mestres:
\begin{itemize}
    \item (i) Considere um universo \(U\) composto por três conjuntos: árvores \(T\), plantas \(P\) e fungos \(F\) — para praticar pertinência, inclusão e operações; e
    
    \begin{figure}[htbp]
    \centering
    \begin{tikzpicture}[scale=1]
        % Conjuntos P, T e F
        % P: plantas (círculo maior)
        \draw[fill=blue!8, draw=blue!60] (0,0) circle (2);
        \node[blue!60] at (0,2.25) {$P$};
        % T: árvores (círculo menor dentro de P)
        \draw[fill=blue!25, draw=blue!60] (-0.6,0) circle (0.9);
        \node[blue!60] at (-0.6,0) {$T$};
        % F: fungos (círculo disjunto)
        \draw[fill=green!20, draw=green!50!black] (3.8,0) circle (1.2);
        \node[green!50!black] at (3.8,0) {$F$};
    \end{tikzpicture}
    \caption{Relações entre os conjuntos de organismos: $T\subseteq P$ (toda árvore é planta) e $F$ é disjunto de $P$.}
    \label{fig:organismos}
    \end{figure}

    \item (ii) exemplo inspirado na navalha de Occam, com três famílias: evidências \(E\), hipóteses \(H\) e explicações \(\mathcal{M} \subseteq 2^{H}\). Nesse segundo exemplo, privilegiaremos explicações parcimoniosas: entre as que cobrem \(E\), preferimos as minimais por inclusão.
\end{itemize}

\paragraph{}
No segundo exemplo, consideremos \(E=\{\text{queda de temperatura},\, \text{céu nublado}\}\) e \(H=\{H_A, H_B\}\), em que \(H_A\) significa “frente fria” e \(H_B\), “ilha de calor”. Tanto \(\{H_A\}\) quanto \(\{H_A,H_B\}\) explicam \(E\) (cobrem ambas as evidências), mas, por parcimônia, preferimos \(\{H_A\}\), por ser estritamente menor do que \(\{H_A,H_B\}\) (\(\{H_A\} \subset \{H_A,H_B\}\)). Ao longo do texto, recorreremos às noções de pertinência (por exemplo, \(H_A\in H\)), de inclusão e às operações usuais sobre conjuntos (união, interseção etc.) para comparar explicações.

 \begin{figure}[htbp]
        \centering
        \begin{tikzpicture}[>=Stealth, node distance=1.6cm]
            % Evidências
            \node[draw, rounded corners, fill=gray!10, minimum width=3.8cm] (E1) {queda de temperatura};
            \node[draw, rounded corners, fill=gray!10, minimum width=3.8cm, below=of E1] (E2) {céu nublado};
            % Hipóteses
            \node[draw, rounded corners, fill=orange!20, left=4.2cm of E1, minimum width=3.2cm] (HA) {$H_A$: frente fria};
            \node[draw, rounded corners, fill=orange!10, below=of HA, minimum width=3.2cm] (HB) {$H_B$: ilha de calor};
            % Setas de cobertura
            \draw[->, thick] (HA.east) -- (E1.west);
            \draw[->, thick] (HA.east) -- (E2.west);
            \draw[->, dashed] (HB.east) -- (E2.west);
            % Nota de parcimônia
            \node[align=center, font=\small, below=1.0cm of E2] (nota) {Ambas as opções \emph{H\_A} e \emph{H\_A + H\_B} cobrem $E$;\\ por parcimônia, preferimos apenas \emph{H\_A}.};
        \end{tikzpicture}
        \caption{Exemplo inspirado na navalha de Occam: $H_A$ cobre ambas as evidências ($E$), enquanto $H_B$ seria redundante; prefere-se a explicação menor.}
        \label{fig:occam-exemplo}
    \end{figure}

\paragraph{}    
\subsubsection{Subconjuntos}
\paragraph{}
Dizemos que \(A\) é um \textbf{subconjunto} de \(B\), denotado \(A \subseteq B\), quando todo elemento de \(A\) também pertence a \(B\). Se, além disso, \(A \neq B\), escrevemos \(A \subset B\) e chamamos \(A\) de \textbf{subconjunto próprio} de \(B\). Ex.: \( \{1,2\} \subseteq \{1,2,3\} \) e \( \{1,2\} \subset \{1,2,3\} \).Por convenção, o conjunto vazio \(\varnothing\) é subconjunto de qualquer conjunto \(X\) (isto é, \(\varnothing \subseteq X\)), e todo conjunto é subconjunto de si mesmo (\(X \subseteq X\)).

\paragraph{}
No primeiro exemplo-mestre, sejam \(P\) o conjunto de plantas, \(T\) o de árvores e \(F\) o de fungos; então \(T \subseteq P\) (toda árvore é planta), ao passo que \(F \not\subseteq P\).

\paragraph{}
No segundo, seja \(H=\{H_A, H_B\}\) e \(E=\{\text{queda de temperatura},\, \text{céu nublado}\}\), vale \(\{H_A\} \subset \{H_A,H_B\} \subseteq H\); ambas as opções explicam \(E\), mas, 
por parcimônia, preferimos \(\{H_A\}\).

\subsubsection{Pertinência e inclusão}
\paragraph{}

Pertinência e inclusão são os conceitos mais fundamentais da teoria dos conjuntos. 

\paragraph{}
Começando pela \textbf{noção de pertinência} denotado por \(\in\): dizemos que um elemento \(x\) pertence a um conjunto \(X\) quando \(x \in X\) e não pertence quando \(x \notin X\).

\paragraph{}
Seja o nosso universo \(U\) de organismos: \(P=\{\text{todas as plantas}\}\), \(T=\{\text{todas as árvores}\}\) e \(F=\{\text{todos os fungos}\}\). Se \(x\) é um carvalho, então \(x\in T\) e, como toda árvore é uma planta, \(x\in P\). Já se \(y\) é um cogumelo, então \(y\in F\) e, na taxonomia moderna, \(y\notin T\) e \(y\notin P\). Agora, considere \(A=\{\text{árvores com folhas verdes}\}\); a pertinência fica clara: \(x\in A\) se, e somente se, \(x\) é árvore e tem folhas verdes.

\begin{figure}[H]
    \centering
    \begin{tikzpicture}[scale=1]
        % P: plantas (círculo maior)
        \draw[fill=blue!8, draw=blue!60] (0,0) circle (2);
        \node[blue!60] at (0,2.25) {$P$};
        % T: árvores (círculo menor dentro de P)
        \draw[fill=blue!25, draw=blue!60] (-0.6,0) circle (0.9);
        \node[blue!60] at (-0.6,-0.45) {$T$};
        % F: fungos (círculo disjunto)
        \draw[fill=green!20, draw=green!50!black] (3.8,0) circle (1.2);
        \node[green!50!black] at (3.8,-0.55) {$F$};
        % Pontos de pertinência
        \fill[red!70] (-0.9,0.2) circle (2pt);
        \node[anchor=east, text=red!70] at (-1.05,0.2) {$x$};
        \fill[black] (3.6,0.4) circle (2pt);
        \node[anchor=west] at (3.72,0.4) {$y$};
    \end{tikzpicture}
    \caption{Pertinência: $x\in T\subseteq P$ (ponto vermelho dentro de $T$) e $y\in F$ (ponto preto); logo $y\notin P$ e $y\notin T$.}
    \label{fig:pertinencia}
\end{figure}

\paragraph{}
Continuando, vem a \textbf{relação de inclusão} entre conjuntos denotada por \(\subseteq\): escrevemos \(X \subseteq Y\) quando todo elemento de \(X\) também pertence a \(Y\) (e \(X\subset Y\) quando, além disso, \(X\neq Y\)). No nosso exemplo, \(A\subseteq T\subset P\) e \(T\cap F=\varnothing\) (árvores e fungos não se sobrepõem).

\begin{figure}[H]
    \centering
    \begin{tikzpicture}[scale=1]
        % P: conjunto maior
        \draw[fill=blue!8, draw=blue!60] (0,0) circle (2);
        \node[blue!60] at (0,2.25) {$P$};
        % T: subconjunto de P
        \draw[fill=blue!25, draw=blue!60] (-0.6,0) circle (0.9);
        \node[blue!60] at (-0.6,0) {$T$};
        % A: subconjunto de T
        \draw[fill=blue!45, draw=blue!70] (-0.9,0.1) circle (0.45);
        \node[blue!70] at (-0.9,0.1) {$A$};
        % F: disjunto de P (e portanto de T e A)
        \draw[fill=green!20, draw=green!50!black] (3.8,0) circle (1.2);
        \node[green!50!black] at (3.8,0) {$F$};
    \end{tikzpicture}
    \caption{Inclusão: $A\subseteq T\subset P$ (círculos aninhados) e $T\cap F=\varnothing$ (círculos disjuntos).}
    \label{fig:inclusao}
\end{figure}

\subsubsection{Operações entre conjuntos}
\paragraph{}
Com essas definições de pertinência, inclusão e subconjuntos, apresentamos as operações básicas entre conjuntos, que usaremos ao longo do texto (mantendo o exemplo com \(P,T,F,A\)).

Outras operações comuns entre conjuntos incluem:
\begin{itemize}
    \item \textbf{União} (\(A \cup B\)): o conjunto de todos os elementos que pertencem a \(A\), a \(B\), ou ambos.
    
    Exemplo: \(T \cup F\) é o conjunto de todos os organismos que são árvores ou fungos (ou ambos, se existissem tais organismos).
    \begin{figure}[H]
    \centering
    \begin{tikzpicture}[scale=0.95]
        % União T ∪ F com sobreposição visível (intersecção)
        \def\r{1.2}
        \coordinate (LT) at (-0.9,0);
        \coordinate (LF) at (0.9,0);
        % Preenchimento semitransparente para evidenciar a intersecção
        \fill[blue!35, opacity=0.45] (LT) circle (\r);
        \fill[green!35, opacity=0.45] (LF) circle (\r);
        % Contornos e rótulos
        \draw[thick, blue!60] (LT) circle (\r) node[left=6pt] {$T$};
        \draw[thick, green!50!black] (LF) circle (\r) node[right=6pt] {$F$};
    \end{tikzpicture}
    \caption{União: a área colorida representa $T\\cup F$; a sobreposição evidencia a intersecção $T\\cap F$ (hipotética).}
    \label{fig:op-uniao}
    \end{figure}
    
    \paragraph{}
    \item \textbf{União disjunta} (\(A \uplus B\)): o conjunto de todos os elementos que pertencem a \(A\) ou a \(B\), mas não a ambos; é igual a \(A \cup B\) quando \(A\) e \(B\) são disjuntos.
    
    Exemplo: \(T \uplus F\) é o conjunto de todos os organismos que são árvores ou fungos, mas não ambos (o que é trivialmente igual a \(T \cup F\) pois \(T\) e \(F\) são disjuntos).
    \begin{figure}[H]
    \centering
    \begin{tikzpicture}[scale=0.95]
        \def\r{1.1}
        \coordinate (LT) at (-1.8,0);
        \coordinate (LF) at (1.8,0);
        \fill[blue!20] (LT) circle (\r);
        \fill[green!20] (LF) circle (\r);
        \draw[thick, blue!60] (LT) circle (\r) node[left=6pt] {$T$};
        \draw[thick, green!50!black] (LF) circle (\r) node[right=6pt] {$F$};
    \end{tikzpicture}
    \caption{União disjunta: como $T\\cap F=\\varnothing$, tem-se $T\\uplus F = T\\cup F$.}
    \label{fig:op-uniao-disjunta}
    \end{figure}

    \paragraph{}
    \item \textbf{Interseção} (\(A \cap B\)): o conjunto de todos os elementos que pertencem tanto a \(A\) quanto a \(B\).
    
    Exemplo: \(T \cap P = T\), pois todas as árvores são plantas.
    \begin{figure}[H]
    \centering
    \begin{tikzpicture}[scale=0.95]
        % Interseção T ∩ P = T (T ⊆ P)
        \def\rP{1.6}
        \def\rT{0.9}
        \coordinate (cP) at (0,0);
        \coordinate (cT) at (-0.4,0.1);
        % P (maior) e T (dentro de P)
        \draw[fill=blue!10, draw=blue!60, thick] (cP) circle (\rP);
        \node[blue!60] at (0,\rP+0.25) {$P$};
        % Preencher T (interseção equivale a T)
        \draw[fill=blue!35, draw=blue!60, thick] (cT) circle (\rT);
        \node[blue!60] at (cT) {$T$};
    \end{tikzpicture}
    \caption{Interseção: como $T\\subseteq P$, $T\\cap P = T$ (a região escura é $T$).}
    \label{fig:op-intersecao}
    \end{figure}

    \paragraph{}    
    \item \textbf{Diferença} (\(A \setminus B\)): o conjunto de todos os elementos que pertencem a \(A\) mas não a \(B\).
    
    Exemplo: \(T \setminus A\) é o conjunto de todas as árvores que não têm folhas verdes.
    \begin{figure}[H]
    \centering
    \begin{tikzpicture}[scale=0.95]
        % Diferença T \ A (A ⊆ T)
        \def\rT{1.4}
        \def\rA{0.8}
        \coordinate (cT) at (0,0);
        \coordinate (cA) at (0.4,0.2);
        % Preencher T
        \draw[fill=blue!25, draw=blue!60, thick] (cT) circle (\rT);
        % Remover a parte A de dentro de T
        \begin{scope}
            \clip (cT) circle (\rT);
            \fill[white] (cA) circle (\rA);
        \end{scope}
        \draw[thick, blue!60] (cT) circle (\rT) node[above right=2pt and -2pt] {$T$};
        \draw[thick, blue!60] (cA) circle (\rA) node[right=4pt] {$A$};
    \end{tikzpicture}
    \caption{Diferença: região azul representa $T\\setminus A$ (árvores que não têm folhas verdes).}
    \label{fig:op-diferenca}
    \end{figure}
    
    \paragraph{}
    \item \textbf{Complemento} de \(X\) em um universo fixo \(U\): \(X^c := U\setminus X\) (também chamado de \textit{complemento absoluto}); o \textit{complemento relativo} de \(X\) em \(Y\) é \(Y\setminus X\).
    
    Exemplo: \(T^c = U \setminus T\) é o conjunto de todos os organismos que não são árvores. Ou seja, \(T^c\) inclui plantas que não são árvores, fungos e quaisquer outros organismos no universo \(U\).
    \begin{figure}[H]
    \centering
    \begin{tikzpicture}[scale=0.95]
        % Universo U e conjunto T
        \draw[fill=gray!10, draw=black] (-2.6,-1.5) rectangle (2.6,1.5);
        \draw[fill=white, draw=black, thick] (-0.3,0) circle (1.0);
        \node at (-0.3,0) {$T$};
        \node at (2.3,1.25) {$U$};
    \end{tikzpicture}
    \caption{Complemento: a área cinza representa $T^c = U\\setminus T$.}
    \label{fig:op-complemento}
    \end{figure}

    \paragraph{}
    \item \textbf{Diferença simétrica} (\(A\,\Delta\, B\)): \((A\setminus B)\cup(B\setminus A)\); é igual a \(A\cup B\) quando \(A\) e \(B\) são disjuntos.
    
    Exemplo: \(P\,\Delta\, F\) é o conjunto de todos os organismos que são plantas ou fungos, mas não ambos (o que é trivialmente igual a \(P \cup F\) pois \(P\) e \(F\) são disjuntos).
    \begin{figure}[H]
    \centering
    \begin{tikzpicture}[scale=0.95]
        % Diferença simétrica P Δ F com P e F disjuntos
        \def\r{1.2}
        \coordinate (LP) at (-1.6,0);
        \coordinate (LF) at (1.6,0);
        \fill[blue!20] (LP) circle (\r);
        \fill[green!20] (LF) circle (\r);
        \draw[thick, blue!60] (LP) circle (\r) node[left=6pt] {$P$};
        \draw[thick, green!50!black] (LF) circle (\r) node[right=6pt] {$F$};
    \end{tikzpicture}
    \caption{Diferença simétrica: como $P\\cap F=\\varnothing$, temos $P\,\\Delta\, F = P\\cup F$.}
    \label{fig:op-dif-simetrica}
    \end{figure}

    \paragraph{}
    \item \textbf{Produto cartesiano} (\(A\times B\)): o conjunto de pares ordenados \((a,b)\) com \(a\in A\) e \(b\in B\).

    Exemplo: \(T=\{t_1,t_2\}\) e \(F=\{f_1,f_2\}\). Então \(T\times F = \{(t_1,f_1),(t_1,f_2),(t_2,f_1),(t_2,f_2)\}\).
    \begin{figure}[H]
    \centering
    \begin{tikzpicture}[scale=1]
        % Grade limpa para T × F (2×2) sem sobreposições
        \def\xone{0}
        \def\xtwo{2.5}
        \def\yone{0}
        \def\ytwo{1.6}
        % Moldura e linhas da grade
        \draw[gray!35] (\xone-0.4,\yone-0.4) rectangle (\xtwo+0.4,\ytwo+0.4);
        \draw[gray!35] (\xone,\yone) -- (\xone,\ytwo);
        \draw[gray!35] (\xtwo,\yone) -- (\xtwo,\ytwo);
        \draw[gray!35] (\xone,\yone) -- (\xtwo,\yone);
        \draw[gray!35] (\xone,\ytwo) -- (\xtwo,\ytwo);
        % Pontos de T×F com cores distintas por par
        \fill[blue!70] (\xone,\yone) circle (2.4pt);   % (t1,f1)
        \fill[purple!70] (\xone,\ytwo) circle (2.4pt); % (t1,f2)
        \fill[green!60!black] (\xtwo,\yone) circle (2.4pt); % (t2,f1)
        \fill[orange!80!black] (\xtwo,\ytwo) circle (2.4pt); % (t2,f2)
        % Rótulos dos pares (posicionados para não sobrepor)
        \node[font=\scriptsize, text=blue!70, anchor=west]  at (\xone+0.18,\yone+0.18) {$(t_1,f_1)$};
        \node[font=\scriptsize, text=purple!70, anchor=west] at (\xone+0.18,\ytwo) {$(t_1,f_2)$};
        \node[font=\scriptsize, text=green!60!black, anchor=east] at (\xtwo-0.18,\yone+0.18) {$(t_2,f_1)$};
        \node[font=\scriptsize, text=orange!80!black, anchor=east] at (\xtwo-0.18,\ytwo-0.18) {$(t_2,f_2)$};
        % Rótulos dos elementos
        \node[blue!60] at (\xone,\yone-0.45) {$t_1$};
        \node[blue!60] at (\xtwo,\yone-0.45) {$t_2$};
        \node[green!50!black, anchor=east] at (\xone-0.25,\yone) {$f_1$};
        \node[green!50!black, anchor=east] at (\xone-0.25,\ytwo) {$f_2$};
        % Rótulos dos conjuntos (eixos)
        \node at (0.5*\xtwo, -0.95) {$T=\{t_1,t_2\}$};
        \node[rotate=90] at (\xone-0.95, 0.5*\ytwo) {$F=\{f_1,f_2\}$};
    \end{tikzpicture}
    \caption{Produto cartesiano: pontos representam os pares de $T\\times F$ para $T=\{t_1,t_2\}$ e $F=\{f_1,f_2\}$.}
    \label{fig:op-produto}
    \end{figure}

    \paragraph{}
    \item \textbf{Conjunto das partes} (\(2^U\)): a família de todos os subconjuntos de \(U\) (inclui \(\varnothing\) e o próprio \(U\)).
    
    Exemplo: se \(U = \{x,y\}\), então \(2^U = \{\varnothing, \{x\}, \{y\}, \{x,y\}\}\). Logo, \(|2^U|=4=2^{|U|}\).
    \begin{figure}[H]
    \centering
    \begin{tikzpicture}[scale=1, node distance=0.9cm]
        % Diagrama de Hasse para U={x,y}
        \node (empty) at (0,0) {$\varnothing$};
        \node (x) [above left=of empty] {$\{x\}$};
        \node (y) [above right=of empty] {$\{y\}$};
        \node (xy) [above=of empty] {$\{x,y\}$};
        \draw (empty) -- (x) -- (xy) -- (y) -- (empty);
    \end{tikzpicture}
    \caption{Conjunto das partes: diagrama de Hasse de $2^{U}$ para $U=\{x,y\}$.}
    \label{fig:op-partes}
    \end{figure}
\end{itemize}

\paragraph{Identidades úteis.}
Usaremos livremente as propriedades clássicas de conjuntos — comutatividade e associatividade de \(\cup\) e \(\cap\), distributividade e as \textbf{leis de De Morgan} — sem prova. Quando for relevante, explicitaremos a identidade no ponto de uso. Por exemplo, no nosso universo \(U\), \((P\cup F)^c = P^c\cap F^c\).

\subsubsection{Coleção}

\paragraph{}
Entre os objetos que podem pertencer a um conjunto, estão também eles mesmos, outros conjuntos. Chamaremos tais conjuntos de \textbf{coleções} (ou \textbf{famílias}) de conjuntos. Por exemplo, \(\mathcal{C} = \{P, T, F\}\) é uma coleção formada pelos conjuntos de organismos já definidos: plantas \(P\), árvores \(T\) e fungos \(F\). Note que \(\mathcal{C}\) é um conjunto como outro qualquer; seus elementos são, cada um, um conjunto.

\paragraph{}
Coleções são úteis para agrupar subconjuntos relacionados de um mesmo universo. Por exemplo, considere \(\mathcal{D} = \{A, B\}\), onde \(A = \{\text{árvores com folhas verdes}\}\) e \(B = \{\text{árvores com folhas vermelhas}\}\). Assim, \(\mathcal{D} \subseteq 2^{T}\) é uma coleção de subconjuntos de \(T\).

\paragraph{}
Uma coleção \(\mathcal{F}\) é dita \textbf{laminar} quando, para quaisquer \(X, Y \in \mathcal{F}\), vale que \(X \subseteq Y\), \(Y \subseteq X\) ou \(X \cap Y = \varnothing\); isto é, quaisquer dois conjuntos são aninhados (um está contido no outro) ou são disjuntos. 

\paragraph{}
Por exemplo, na coleção \(\mathcal{C} = \{P, T, F\}\): \(P\) é o conjunto de todas as plantas, \(T\) o de todas as árvores (portanto \(T\subseteq P\)) e \(F\) o de todos os fungos (disjunto de plantas e, logo, de árvores). Assim, quaisquer dois conjuntos em \(\mathcal{C}\) são aninhados ou disjuntos, e \(\mathcal{C}\) é laminar. Na coleção \(\mathcal{D} = \{A, T\}\): \(A\) é o conjunto de árvores com folhas verdes e \(T\) o de todas as árvores; como toda árvore de \(A\) é árvore de \(T\), temos \(A\subseteq T\) e a coleção é laminar. Já em \(\mathcal{E} = \{A, R\}\): \(R\) é o conjunto de árvores frutíferas; há árvores que são ao mesmo tempo frutíferas e de folhas verdes (a interseção é não vazia), mas nenhuma das classes contém a outra, então \(\mathcal{E}\) não é laminar.

\begin{figure}[H]
\centering
\begin{tikzpicture}[scale=0.95]
    % (a) Coleção C = {P, T, F} é laminar: T ⊆ P e F disjunto
    \begin{scope}[xshift=-6.2cm]
        % P (maior)
        \draw[fill=blue!8, draw=blue!60, thick] (0,0) circle (1.6);
        \node[blue!60] at (0,1.9) {$P$};
        % T (dentro de P)
        \draw[fill=blue!25, draw=blue!60, thick] (-0.4,0.1) circle (0.8);
        \node[blue!70] at (-0.4,0.1) {$T$};
        % F (disjunto)
        \draw[fill=green!20, draw=green!50!black, thick] (2.8,0) circle (0.9);
        \node[green!50!black] at (2.8,0) {$F$};
        % Rótulo do subpainel
        \node[font=\small] at (0,-2.2) {(a) $\mathcal{C}=\{P,T,F\}$ — laminar};
    \end{scope}

    % (b) Coleção D = {A, T} é laminar: A ⊆ T
    \begin{scope}
        % T
        \draw[fill=blue!25, draw=blue!60, thick] (0,0) circle (1.3);
        \node[blue!60] at (0,1.55) {$T$};
        % A (dentro de T)
        \draw[fill=blue!45, draw=blue!70, thick] (-0.4,0.1) circle (0.6);
        \node[blue!70] at (-0.4,0.1) {$A$};
        % Rótulo do subpainel
        \node[font=\small] at (0,-2.0) {(b) $\mathcal{D}=\{A,T\}$ — laminar};
    \end{scope}

    % (c) Coleção E = {A, R} não é laminar: A e R se interceptam sem inclusão
    \begin{scope}[xshift=6.2cm]
        % A e R sobrepostos
        \def\ra{1.1}
        \coordinate (cA) at (-0.5,0);
        \coordinate (cR) at (0.5,0);
        \fill[blue!35, opacity=0.5] (cA) circle (\ra);
        \fill[orange!60, opacity=0.45] (cR) circle (\ra);
        \draw[blue!70, thick] (cA) circle (\ra) node[left=6pt] {$A$};
        \draw[orange!80!black, thick] (cR) circle (\ra) node[right=6pt] {$R$};
        % Rótulo do subpainel
        \node[font=\small] at (0,-2.0) {(c) $\mathcal{E}=\{A,R\}$ — não laminar};
    \end{scope}
\end{tikzpicture}
\caption{Laminaridade em coleções: em (a) e (b), quaisquer dois conjuntos são aninhados ou disjuntos; em (c), $A$ e $R$ se interceptam sem inclusão, violando a laminaridade.}
\label{fig:laminaridade}
\end{figure}

\paragraph{}
Este é um importante conceito que aparecerá no restante do trabalho. A ideia de laminaridade retornará quando tratarmos de cortes dirigidos.

\subsubsection{Comparando conjuntos: cardinalidade e maximalidade}

\paragraph{}
Podemos comparar conjuntos através de relações de tamanho (cardinalidade) ou por relações de inclusão. Essas duas formas de comparação são distintas e importantes, especialmente quando lidamos com coleções de conjuntos.

\paragraph{}
A \textbf{cardinalidade} de um conjunto \(A\), denotada por \(|A|\), é o número de elementos de \(A\). Para conjuntos finitos, é simplesmente a contagem dos elementos (por exemplo, se \(A=\{1,2,3\}\), então \(|A|=3\)). Para conjuntos infinitos, a cardinalidade pode ser mais complexa, envolvendo conceitos como infinito enumerável e não enumerável. Por exemplo, o conjunto dos números naturais \(\mathbb{N}\) é infinito enumerável, enquanto o conjunto dos números reais \(\mathbb{R}\) é infinito não enumerável.

\paragraph{}
Dizemos que \(A\in\mathcal{C}\) tem \textbf{maior cardinalidade} se \(|A|\ge |B|\) para todo \(B\in\mathcal{C}\) (podendo haver empates). Esse critério não coincide, em geral, com a comparação por relação de inclusão. Em grafos, por exemplo, distinguem-se conjuntos independentes \emph{maximais} (não ampliáveis) de conjuntos independentes \emph{máximos} (de cardinalidade máxima).

\paragraph{}
Ao compararmos uma coleção \(\mathcal{C}\) de conjuntos utilizando sua relações de inclusão \((\mathcal{C},\subseteq)\), é imprescindível distinguir \textbf{maximal} de \textbf{máximo}.

\paragraph{}
Um conjunto \(A\in\mathcal{C}\) é \textbf{maximal} se não existe \(B\in\mathcal{C}\) tal que \(A\subset B\). Em palavras: não dá para ampliar \(A\) estritamente dentro da coleção. Podem haver vários elementos maximais, e eles podem ser incomparáveis entre si. Ex.: em \(\mathcal{C}=\big\{\{1\},\{2\}\big\}\), ambos \(\{1\}\) e \(\{2\}\) são maximais, mas não existe máximo.

\paragraph{}
Um conjunto \(A\in\mathcal{C}\) é \textbf{máximo} se \(B\subseteq A\) para todo \(B\in\mathcal{C}\). Se existe, é único. Ex.: em \(\mathcal{C}=\big\{\{1\},\{2\},\{1,2\}\big\}\), o conjunto \(\{1,2\}\) é o máximo.

\paragraph{}
Um bom exemplo para ilustrar a distinção entre conjuntos maximais e máximos é a coleção \(\mathcal{C}=\big\{\{1\},\{2\},\{1,2\},\{3\}\big\}\). Aqui, \(\{1,2\}\) é o único conjunto máximo (contém todos os outros), enquanto \(\{1\}\), \(\{2\}\) e \(\{3\}\) são todos maximais (não podem ser ampliados dentro da coleção).

\paragraph{}
Esses conceitos reaparecerão ao longo do texto, especialmente na diferença entre estruturas \textbf{maximais} (saturadas por inclusão) e \textbf{máximas/ótimas} (de maior cardinalidade ou menor custo). Para fixar ideias:
\begin{itemize}
    \item Em muitos problemas, “\textbf{maximal}” quer dizer: não dá para ampliar uma escolha sem violar as regras; já “\textbf{máximo/ótimo}” quer dizer: entre todas as escolhas válidas, essa é a melhor segundo o critério (por exemplo, menor custo).
    \item No algoritmo de \textbf{Chu--Liu/Edmonds}, começamos com escolhas locais que já não podem ser ampliadas dentro das regras do problema e, a partir delas, chegamos a uma solução de menor custo.
    \item No método de \textbf{András Frank}, primeiro construímos uma estrutura organizada que garante escolhas suficientes; depois, usando apenas relações já ativadas por essa estrutura, extraímos a solução ótima.
    \item Moral: partimos da ideia de “não dá para aumentar” (maximal) e chegamos a “melhor possível” (máximo/ótimo). Os detalhes técnicos de cada método aparecerão nas seções próprias.
\end{itemize}

\subsection{Relações e Funções}

\paragraph{}
Desde a introdução, vimos a ideia filosófica de explicar como “ligar” fatos a hipóteses da forma mais parcimoniosa possível. Para tornar essa intuição precisa, precisamos de uma linguagem que descreva objetos (conjuntos) e como eles se conectam. É aqui que entram as \textbf{relações} e, de modo ainda mais disciplinado, as \textbf{funções}: regras que associam a cada elemento de um conjunto exatamente um elemento de outro. Com elas, passamos do discurso qualitativo sobre explicações para uma estrutura matemática que permite medir, comparar e, adiante, otimizar.

% \paragraph{}
% Quando lidamos com conjuntos, frequentemente precisamos estabelecer conexões ou associações entre seus elementos. Essas conexões são formalizadas através de \textbf{relações} e \textbf{funções}, que são conceitos fundamentais em matemática e ciência da computação.

\paragraph{}
Na matemática, uma \textbf{relação} entre dois conjuntos \(A\) e \(B\) é uma maneira de associar elementos de \(A\) com elementos de \(B\). Uma \textbf{função} é um tipo especial de relação que associa cada elemento de \(A\) a exatamente um elemento de \(B\).

\paragraph{}
Uma \textbf{relação} \(R\) entre dois conjuntos \(A\) e \(B\) é um subconjunto do produto cartesiano \(A \times B\). Ou seja, \(R \subseteq A \times B\). Se \((a,b) \in R\), dizemos que \(a\) está relacionado a \(b\) pela relação \(R\), denotado \(aRb\).

\begin{figure}[H]
\centering
\begin{tikzpicture}[>=Stealth, node distance=1.2cm]
    % Coluna A (domínio) — retângulos arredondados
    \node[draw, rounded corners, fill=blue!10, minimum width=8mm, minimum height=6mm] (a1) {$a_1$};
    \node[draw, rounded corners, fill=blue!10, below=of a1, minimum width=8mm, minimum height=6mm] (a2) {$a_2$};
    \node[draw, rounded corners, fill=blue!10, below=of a2, minimum width=8mm, minimum height=6mm] (a3) {$a_3$};
    % Coluna B (contradomínio) — círculos
    \node[circle, draw, fill=green!10, right=3.2cm of a1, minimum size=6mm] (b1) {$b_1$};
    \node[circle, draw, fill=green!10, below=of b1, minimum size=6mm] (b2) {$b_2$};
    \node[circle, draw, fill=green!10, below=of b2, minimum size=6mm] (b3) {$b_3$};
    % Agrupadores (caixas) para A e B com rótulos
    \node[draw=blue!50, rounded corners, fit=(a1)(a2)(a3), inner sep=5pt, label={[blue!60]above:A (domínio)}] {};
    \node[draw=green!50!black, fit=(b1)(b2)(b3), inner sep=7pt, label={[green!50!black]above:B (contradomínio)}] {};
    % Setas representando os pares de R (neutras para destacar os conjuntos)
    \draw[->, thick, draw=gray!70] (a1) -- (b2);
    \draw[->, thick, draw=gray!70] (a2) -- (b1);
    \draw[->, thick, draw=gray!70] (a2) -- (b3);
    \draw[->, thick, draw=gray!70] (a3) -- (b3);
\end{tikzpicture}
\caption{Relação $R\subseteq A\times B$. Cada seta representa um par $(a,b)\in R$ (isto é, $a\,R\,b$). As formas/cores distinguem domínio ($A$, retângulos azuis) de contradomínio ($B$, círculos verdes). Note que $a_2$ se relaciona com $b_1$ e $b_3$; logo, este $R$ \emph{não} é uma função. Para que $R$ fosse uma função $f\!:\!A\to B$, cada $a\in A$ deveria ter \emph{exatamente uma} seta saindo para algum $b\in B$.}
\label{fig:relacao}
\end{figure}

\paragraph{}
No nosso primeiro exemplo-mestre, considere \(P=\{\text{todas as plantas}\}\) e \(F=\{\text{todos os fungos}\}\). Definimos a relação \(R\) como "é um organismo que compete com". Assim, se uma planta \(p \in P\) compete com um fungo \(f \in F\), então \((p,f) \in R\).

\paragraph{}
No nosso segundo exemplo, considere \(H=\{\text{hipóteses}\}\) e \(E=\{\text{evidências}\}\). Definimos a relação \(R\) como "explica". Se uma hipótese \(h \in H\) explica uma evidência \(e \in E\), então \((h,e) \in R\).

\paragraph{}
Em teoria dos grafos, uma relação pode representar conexões entre vértices. Por exemplo, em um grafo dirigido, a relação "existe uma aresta de \(u\) para \(v\)" pode ser representada como um conjunto de pares ordenados \((u,v)\).

\paragraph{}
Uma \textbf{função} \(f\) de um conjunto \(A\) em um conjunto \(B\) é uma relação especial que associa cada elemento de \(A\) a exatamente um elemento de \(B\). Denotamos isso como \(f: A \to B\). Se \(f(a) = b\), dizemos que \(b\) é a imagem de \(a\) sob \(f\).

\begin{figure}[H]
\centering
\begin{tikzpicture}[>=Stealth, node distance=1.2cm]
    % Coluna A (domínio) — retângulos arredondados
    \node[draw, rounded corners, fill=blue!10, minimum width=8mm, minimum height=6mm] (a1f) {$a_1$};
    \node[draw, rounded corners, fill=blue!10, below=of a1f, minimum width=8mm, minimum height=6mm] (a2f) {$a_2$};
    \node[draw, rounded corners, fill=blue!10, below=of a2f, minimum width=8mm, minimum height=6mm] (a3f) {$a_3$};
    % Coluna B (contradomínio) — círculos
    \node[circle, draw, fill=green!10, right=3.2cm of a1f, minimum size=6mm] (b1f) {$b_1$};
    \node[circle, draw, fill=green!10, below=of b1f, minimum size=6mm] (b2f) {$b_2$};
    \node[circle, draw, fill=green!10, below=of b2f, minimum size=6mm] (b3f) {$b_3$};
    % Agrupadores (caixas) para A e B com rótulos
    \node[draw=blue!50, rounded corners, fit=(a1f)(a2f)(a3f), inner sep=5pt, label={[blue!60]above:A (domínio)}] {};
    \node[draw=green!50!black, fit=(b1f)(b2f)(b3f), inner sep=7pt, label={[green!50!black]above:B (contradomínio)}] {};
    % Setas de função (exatamente uma saída por elemento de A)
    \draw[->, thick, draw=gray!70] (a1f) -- (b1f);
    \draw[->, thick, draw=gray!70] (a2f) -- (b2f);
    \draw[->, thick, draw=gray!70] (a3f) -- (b2f); % muitos-para-um permitido
\end{tikzpicture}
\caption{Função $f\!:\!A\to B$. Cada elemento de $A$ tem \emph{exatamente uma} seta saindo para um elemento de $B$ (a imagem). Elementos distintos de $A$ podem ter a mesma imagem (muitos-para-um), e nem todo elemento de $B$ precisa ser imagem (aqui, $b_3$ não é atingido). Compare com a Fig.\ \ref{fig:relacao}.}
\label{fig:funcao}
\end{figure}

\paragraph{}
No nosso exemplo-mestre, considere \(P=\{\text{todas as plantas}\}\) e \(\mathbb{N}=\{0,1,2,\ldots\}\) (números naturais). Definimos a função \(f: P \to \mathbb{N}\) que associa cada planta ao seu número de folhas. Se \(p \in P\) é uma árvore com 100 folhas, então \(f(p) = 100\).

\paragraph{}
Em teoria dos grafos, funções podem ser usadas para atribuir pesos às arestas. Por exemplo, se temos um grafo \(G\) com arestas \(e_1, e_2, \ldots, e_n\), podemos definir uma função \(c: E \to \mathbb{R}^+\) que atribui um peso \(c(e_i)\) a cada aresta \(e_i\).

\paragraph{}
Na ciência da computação, relações e funções são usadas para modelar conexões entre dados, estruturas de dados e operações. Por exemplo, em bancos de dados relacionais, tabelas representam relações entre diferentes entidades. Em programação funcional, funções são tratadas como cidadãos de primeira classe, permitindo a criação de funções de ordem superior que podem receber outras funções como argumentos ou retorná-las como resultados.

\subsubsection{Conceitos em Funções}
\paragraph{}
Alguns conceitos importantes relacionados a funções incluem:
\begin{itemize}
    \item \textbf{Domínio}: o conjunto \(A\) de entrada da função \(f: A \to B\).
    \item \textbf{Contradomínio}: o conjunto \(B\) de possíveis saídas da função.
    \item \textbf{Imagem}: o conjunto de valores efetivamente atingidos pela função, \(f(A) = \{f(a) \mid a \in A\}\).
    
    \begin{figure}[H]
    \centering
    \begin{tikzpicture}[>=Stealth, node distance=1.1cm]
        % Elementos do domínio A (retângulos azuis)
        \node[draw, rounded corners, fill=blue!10, minimum width=9mm, minimum height=6mm] (a1img) {$a_1$};
        \node[draw, rounded corners, fill=blue!10, below=of a1img, minimum width=9mm, minimum height=6mm] (a2img) {$a_2$};
        \node[draw, rounded corners, fill=blue!10, below=of a2img, minimum width=9mm, minimum height=6mm] (a3img) {$a_3$};
        % Elementos do contradomínio B (círculos verdes)
        \node[circle, draw, fill=green!10, right=3.2cm of a1img, minimum size=6mm] (b1img) {$b_1$};
        \node[circle, draw, fill=green!10, below=of b1img, minimum size=10mm] (b2img) {$b_2$};
        \node[circle, draw, fill=green!10, below=of b2img, minimum size=6mm] (b3img) {$b_3$};
        % Caixas de agrupamento com rótulos
        \node[draw=blue!50, rounded corners, fit=(a1img)(a2img)(a3img), inner sep=5pt, label={[blue!60]above:A (domínio)}] {};
        \node[draw=green!50!black, fit=(b1img)(b2img)(b3img), inner sep=7pt, label={[green!50!black]above:B (contradomínio)}] {};
        % Setas de f (exatamente uma por elemento de A)
        \draw[->, thick, draw=gray!70] (a1img) -- (b1img);
        \draw[->, thick, draw=gray!70] (a2img) -- (b2img);
        \draw[->, thick, draw=gray!70] (a3img) -- (b2img);
        % Destaque da imagem f(A) ⊆ B
    \node[draw=purple!70!black, thick, fit=(b1img)(b2img), inner sep=3pt, label distance=15mm, label={[purple!70!black]right:Imagem $f(A)$}] {};
    \end{tikzpicture}
    \caption{Domínio, contradomínio e imagem: $A$ (retângulos azuis) mapeia via $f$ para $B$ (círculos verdes). A imagem $f(A)$ é o subconjunto de $B$ efetivamente atingido (aqui, $\{b_1,b_2\}$).}
    \label{fig:dom-contradom-imagem}
    \end{figure}
    
    \item \textbf{Injetora}: uma função \(f\) é injetora se \(f(a_1) = f(a_2)\) implica \(a_1 = a_2\); ou seja, elementos distintos do domínio têm imagens distintas.
    \item \textbf{Sobrejetora}: uma função \(f\) é sobrejetora se para todo \(b \in B\), existe \(a \in A\) tal que \(f(a) = b\); ou seja, a imagem é igual ao contradomínio.
    \item \textbf{Bijetora}: uma função que é tanto injetora quanto sobrejetora; estabelece uma correspondência um-para-um entre os elementos de \(A\) e \(B\).
    
\end{itemize}

\begin{figure}[H]
\centering
\begin{tikzpicture}[>=Stealth, scale=0.9, every node/.style={transform shape}, node distance=0.8cm]
    % estilos reutilizados
    \tikzset{
        Aelem/.style={draw, rounded corners, fill=blue!10, minimum width=7mm, minimum height=5mm},
        Belem/.style={circle, draw, fill=green!10, minimum size=5mm},
        Abox/.style={draw=blue!50, rounded corners},
        Bbox/.style={draw=green!50!black}
    }

    % (a) Injetora: imagens distintas
    \begin{scope}
        \node[Aelem] (a1i) {$a_1$};
        \node[Aelem, below=of a1i] (a2i) {$a_2$};
        \node[Aelem, below=of a2i] (a3i) {$a_3$};
    \node[style=Belem, right=2.2cm of a1i] (b1i) {$b_1$};
        \node[style=Belem, below=of b1i] (b2i) {$b_2$};
        \node[style=Belem, below=of b2i] (b3i) {$b_3$};
    \node[Abox, fit=(a1i)(a2i)(a3i), inner sep=3pt, label={[blue!60]above:$A$}] {};
    \node[Bbox, fit=(b1i)(b2i)(b3i), inner sep=5pt, label={[green!50!black]above:$B$}] {};
    \draw[->, semithick, draw=gray!70] (a1i) -- (b1i);
    \draw[->, semithick, draw=gray!70] (a2i) -- (b2i);
    \draw[->, semithick, draw=gray!70] (a3i) -- (b3i);
    \node[font=\footnotesize, anchor=south] at ($(a1i)!0.5!(b1i)+(0,0.7)$) {(a) Injetora};
    \end{scope}
    
    % (b) Sobrejetora: todo B é atingido
    \begin{scope}[xshift=4.8cm]
        \node[Aelem] (a1s) {$a_1$};
        \node[Aelem, below=of a1s] (a2s) {$a_2$};
        \node[Aelem, below=of a2s] (a3s) {$a_3$};
    \node[style=Belem, right=2.2cm of a1s] (b1s) {$b_1$};
    \node[style=Belem, below=of b1s] (b2s) {$b_2$};
    \node[style=Belem, below=of b2s] (b3s) {$b_3$};
    \node[Abox, fit=(a1s)(a2s)(a3s), inner sep=3pt, label={[blue!60]above:$A$}] {};
    \node[Bbox, fit=(b1s)(b2s)(b3s), inner sep=5pt, label={[green!50!black]above:$B$}] {};
    \draw[->, semithick, draw=gray!70] (a1s) -- (b1s);
    \draw[->, semithick, draw=gray!70] (a2s) -- (b2s);
    \draw[->, semithick, draw=gray!70] (a3s) -- (b3s);
    \node[font=\footnotesize, anchor=south] at ($(a1s)!0.5!(b1s)+(0,0.7)$) {(b) Sobrejetora};
    \end{scope}
   
    % (c) Bijetora: um-para-um e sobre
    \begin{scope}[xshift=9.6cm]
        \node[Aelem] (a1b) {$a_1$};
        \node[Aelem, below=of a1b] (a2b) {$a_2$};
        \node[Aelem, below=of a2b] (a3b) {$a_3$};
    \node[style=Belem, right=2.2cm of a1b] (b1b) {$b_1$};
    \node[style=Belem, below=of b1b] (b2b) {$b_2$};
    \node[style=Belem, below=of b2b] (b3b) {$b_3$};
    \node[Abox, fit=(a1b)(a2b)(a3b), inner sep=3pt, label={[blue!60]above:$A$}] {};
    \node[Bbox, fit=(b1b)(b2b)(b3b), inner sep=5pt, label={[green!50!black]above:$B$}] {};
    \draw[->, semithick, draw=gray!70] (a1b) -- (b2b);
    \draw[->, semithick, draw=gray!70] (a2b) -- (b3b);
    \draw[->, semithick, draw=gray!70] (a3b) -- (b1b);
    \node[font=\footnotesize, anchor=south] at ($(a1b)!0.5!(b1b)+(0,0.7)$) {(c) Bijetora};
    \end{scope}
\end{tikzpicture}
\caption{Funções especiais: (a) Injetora — elementos distintos em $A$ têm imagens distintas em $B$; (b) Sobrejetora — todo elemento de $B$ é imagem; (c) Bijetora — um-para-um e sobre $B$.}
\label{fig:inj-sobre-bij}
\end{figure}

\subsubsection{Funções de agregação e somatórios}

\paragraph{}
Além de relacionar elementos de conjuntos, muitas operações familiares em matemática, envolvem \emph{funções} que recebem coleções de números (ou funções) e devolvem um número.

\paragraph{}
Uma \textbf{função de agregação} é uma função que recebe um conjunto (ou sequência) de valores e retorna um único valor que representa algum aspecto agregado desses valores. Exemplos comuns incluem:
\begin{itemize}
    \item \textbf{Média}: A média aritmética de um conjunto de números \(x_1, x_2, \ldots, x_n\) é dada por \(\frac{1}{n}\sum_{i=1}^{n} x_i\).
    \item \textbf{Máximo e Mínimo}: A função máximo retorna o maior valor em um conjunto, enquanto a função mínimo retorna o menor valor.
    \item \textbf{Produto}: O produto de um conjunto de números \(x_1, x_2, \ldots, x_n\) é dado por \(\prod_{i=1}^{n} x_i\).
    \item \textbf{Contagem}: A função contagem retorna o número de elementos em um conjunto.
\end{itemize}

O \textbf{somatório}, por exemplo, é uma função de agregação linear que mapeia uma sequência \((x_1,\dots,x_n)\) em sua soma:
\[\sum_{i=1}^{n} x_i.\]

Esse conceito é especialmente útil em otimização e em análise combinatória: somatórios aparecem o tempo todo e serão explorados ao longo deste trabalho.

\paragraph{Exemplos com grafos.}
As sessões seguintes explorarão em maiores detalhes grafos e dígrafos, mas agora, consideremos a ideia básica: um \textbf{grafo} é um conjunto de pontos (\emph{vértices}) ligados por linhas (\emph{arestas}). No caso \emph{não dirigido}, as linhas não têm seta; no caso \emph{dirigido}, cada linha tem um sentido e é chamada de \emph{arco}.

\paragraph{}
A noção de somatória aparecerá naturalmente quando lidamos com propriedades dos grafos. Por exemplo:

Seja um grafo não dirigido \(G=(V,E)\). O \textbf{grau} de um vértice \(v\in V\), escrito \(\deg(v)\), é quantas arestas tocam em \(v\). A soma dos graus de todos os vértices conta cada aresta \emph{duas vezes} (uma por extremidade), portanto:
\[\sum_{v\in V} \deg(v) = 2\,|E|.\]

Em grafos dirigidos, distinguimos \(\deg^{-}(v)\) (quantos arcos \emph{chegam} em \(v\)) e \(\deg^{+}(v)\) (quantos arcos \emph{saem} de \(v\)). Cada arco contribui com 1 para um grau de saída e 1 para um grau de entrada, logo:
\[\sum_{v\in V} \deg^{-}(v) = \sum_{v\in V} \deg^{+}(v) = |E|.\]

\paragraph{}
Agora suponha que cada aresta/arco \(e\in E\) tenha um \emph{peso} (ou \emph{custo}) \(c(e)\ge 0\). O \textbf{custo total} de um subconjunto \(F\subseteq E\) é simplesmente a soma dos pesos das arestas escolhidas:
\[C(F) = \sum_{e\in F} c(e).\]
De maneira análoga, se \(X\subseteq V\) é um conjunto de vértices, o \textbf{valor total} (ou peso total) dos arcos que \emph{saem} de \(X\) é a soma dos pesos dessas setas. Usaremos mais adiante a notação \(\delta^{+}(X)\) para o conjunto de arcos que saem de \(X\) (ver a seção de dígrafos); com essa notação,
\[\operatorname{val}^+(X) = \sum_{e\in \delta^{+}(X)} c(e).\]
Esses exemplos mostram como somatórios capturam propriedades estruturais do grafo por meio de funções simples de agregação.

\subsubsection{Funções Especiais}

\paragraph{Função de custo}
\paragraph{}Uma \textbf{função de custo} é uma função \(c: A \to \mathbb{R}^+\) que atribui um valor numérico não negativo (custo) a cada elemento de um conjunto \(A\). Essas funções são amplamente utilizadas em otimização, economia e teoria dos grafos para modelar despesas, penalidades ou recursos associados a escolhas ou ações.

\paragraph{}
Exemplo: Considere um conjunto de tarefas \(T = \{t_1, t_2, t_3\}\). Uma função de custo \(c: T \to \mathbb{R}^+\) pode ser definida como:
\[c(t_1) = 5, \quad c(t_2) = 10, \quad c(t_3) = 3.\]
Aqui, \(c(t_i)\) representa o custo de realizar a tarefa \(t_i\). 

\paragraph{}
Depende diretamente do conceito de somatório, pois frequentemente queremos minimizar o custo total de um conjunto de escolhas. Se \(S \subseteq A\) é um subconjunto de elementos escolhidos, o custo total associado a \(S\) é dado por:
\[C(S) = \sum_{a \in S} c(a).\] 

\paragraph{Função c-disjunta}
Uma \textbf{função c-disjunta} é uma função \(f: A \to B\) que, para quaisquer \(a_1, a_2 \in A\) com \(a_1 \neq a_2\), as imagens \(f(a_1)\) e \(f(a_2)\) são disjuntas, ou seja, \(f(a_1) \cap f(a_2) = \varnothing\). Em outras palavras, elementos distintos do domínio são mapeados para conjuntos disjuntos no contradomínio.

\begin{figure}[H]
\centering
\begin{tikzpicture}[>=Stealth, node distance=1.0cm]
    % Domínio A (retângulos azuis)
    \node[draw, rounded corners, fill=blue!10, minimum width=9mm, minimum height=6mm] (a1cd) {$a_1$};
    \node[draw, rounded corners, fill=blue!10, below=of a1cd, minimum width=9mm, minimum height=6mm] (a2cd) {$a_2$};
    \node[draw, rounded corners, fill=blue!10, below=of a2cd, minimum width=9mm, minimum height=6mm] (a3cd) {$a_3$};
    \node[draw=blue!50, rounded corners, fit=(a1cd)(a2cd)(a3cd), inner sep=4pt, label={[blue!60]above:$A$}] {};

    % Universo U (círculos verdes como átomos) à direita
    \node[circle, draw, fill=green!10, right=3.2cm of a1cd, minimum size=6mm] (ua) {$a$};
    \node[circle, draw, fill=green!10, right=8mm of ua, minimum size=6mm] (ub) {$b$};
    \node[circle, draw, fill=green!10, below=8mm of ua, minimum size=6mm] (uc) {$c$};
    \node[circle, draw, fill=green!10, right=8mm of uc, minimum size=6mm] (ud) {$d$};
    % Caixa do universo U
    \node[draw=gray!60, rounded corners, fit=(ua)(ub)(uc)(ud), inner sep=6pt, label={[gray!70]above:$U$}] (Ubox) {};

    % Destaque das imagens (subconjuntos disjuntos de U)
    \node[draw=purple!70!black, rounded corners, fit=(ua)(ub), inner sep=2pt, label={[purple!70!black]above:$f(a_1)$}] (S1) {};
    \node[draw=orange!80!black, rounded corners, fit=(uc), inner sep=3pt, label={[orange!80!black]below:$f(a_2)$}] (S2) {};
    \node[draw=blue!60!black, rounded corners, fit=(ud), inner sep=3pt, label={[blue!60!black]below:$f(a_3)$}] (S3) {};

    % Setas de mapeamento para os subconjuntos (apontando para as caixas de destaque)
    \draw[->, thick, draw=gray!70] (a1cd) -- (S1.west);
    \draw[->, thick, draw=gray!70] (a2cd) -- (S2.west);
    \draw[->, thick, draw=gray!70] (a3cd) -- (S3.west);
\end{tikzpicture}
\caption{Função c-disjunta: cada \(a\in A\) mapeia para um \emph{subconjunto} de \(U\), e as imagens são dois a dois disjuntas (sem sobreposição). No exemplo, $f(a_1)=\{a,b\}$, $f(a_2)=\{c\}$ e $f(a_3)=\{d\}$.}
\label{fig:c-disjunta}
\end{figure}

\paragraph{}
Exemplo: Considere \(A = \{1, 2, 3\}\) e \(B = \{\{a\}, \{b\}, \{c\}, \{d\}\}\). Definimos a função \(f: A \to B\) como:
\[f(1) = \{a, b\}, \quad f(2) = \{c\}, \quad f(3) = \{d\}.\]
Aqui, \(f\) é c-disjunta, pois \(f(1) \cap f(2) = \varnothing\), \(f(1) \cap f(3) = \varnothing\) e \(f(2) \cap f(3) = \varnothing\).

\paragraph{Função c-viável}

\paragraph{}Uma \textbf{função c-viável} é uma função \(g: A \to \mathbb{R}^+\) que satisfaz certas condições de viabilidade relacionadas a um conjunto de restrições ou critérios. Essas funções são frequentemente usadas em otimização e teoria dos grafos para garantir que as soluções propostas atendam a requisitos específicos.
\paragraph{}
Exemplo: Considere um conjunto de projetos \(P = \{p_1, p_2, p_3\}\) e uma função \(g: P \to \mathbb{R}^+\) que atribui um valor de viabilidade a cada projeto. Suponha que temos a restrição de que a soma dos valores de viabilidade deve ser menor ou igual a um certo limite \(L\). Se definirmos:
\[g(p_1) = 4, \quad g(p_2) = 6, \quad g(p_3) = 3,\]
então a função \(g\) é c-viável se \(g(p_1) + g(p_2) + g(p_3) \leq L\).
\paragraph{}Essas funções são essenciais para garantir que as soluções propostas em problemas de otimização sejam práticas e atendam aos critérios estabelecidos.

\paragraph{Funções de otimização}

\paragraph{}
Do ponto de vista semiótico, “melhor” exprime uma preferência entre interpretações: ao comparar alternativas, escolhemos aquela cuja significação é mais adequada a um critério. Para tornar isso operacional, a matemática troca “fazer mais sentido” por “ter maior (ou menor) valor” em uma escala formal: fixamos (i) um conjunto de soluções viáveis \(\mathcal{F}\) e (ii) uma função numérica sobre \(\mathcal{F}\) que induz uma ordem de comparação.

\paragraph{}
Formalmente, usamos uma \textbf{função objetivo} (ou \textbf{função de otimização})
\[h:\; \mathcal{F} \to \mathbb{R},\]
que atribui um número real a cada solução. Buscamos uma solução \(S^*\in\mathcal{F}\) que \emph{minimize} ou \emph{maximize} \(h\) (isto é, um \(\operatorname*{argmin}\) ou \(\operatorname*{argmax}\)). Quando esse número resulta da soma de contribuições elementares, obtemos o caso aditivo, em ligação direta com os somatórios apresentados antes.

\paragraph{}
Caso \emph{aditivo}. Quando cada elemento \(a\in A\) tem um custo \(c(a)\ge 0\) e as soluções são subconjuntos \(S\subseteq A\), a função objetivo mais comum é o custo total
\[C(S)=\sum_{a\in S} c(a),\]
que desejamos \emph{minimizar}. De modo análogo, se cada item tem um benefício \(p(a)\ge 0\), podemos \emph{maximizar} o benefício total \(P(S)=\sum_{a\in S} p(a)\), possivelmente sujeito a restrições (por exemplo, de orçamento ou limite).

\paragraph{}
Outro exemplo: considere produtos \(X=\{x_1,x_2,x_3\}\) com lucro \(p(x_1)=10\), \(p(x_2)=15\), \(p(x_3)=7\). Se houver um limite de custo que impede escolher todos, o objetivo típico é escolher um subconjunto \(S\subseteq X\) que maximize \(\sum_{x\in S} p(x)\) respeitando as restrições. Essa forma reflete exatamente os somatórios introduzidos antes.

\paragraph{}
Em todos os casos, a função objetivo explicita o critério de “melhor”, e as restrições determinam quais soluções são aceitáveis.

\subsubsection{Otimização}
\paragraph{}
O princípio da navalha de occam nos diz que a explicação mais simples tende a ser a correta. Do ponto de vista semiótico, isso é escolher, entre interpretações possíveis, a que melhor satisfaz um critério. A matemática também se preocupa com identificar a “melhor” solução entre várias alternativas, mas traduz essa ideia em termos quantitativos: fixamos (i) um conjunto de soluções viáveis \(\mathcal{F}\) e (ii) uma função numérica sobre \(\mathcal{F}\) que induz uma ordem de comparação. 

\paragraph{}
Assim, a otimização envolve a maximização ou minimização de uma função objetivo \(h: \mathcal{F} \to \mathbb{R}\) sobre um conjunto de soluções viáveis \(\mathcal{F}\).

\paragraph{}
Esse conceito pode aparecer em muitas necessidades do dia-a-dia: uma empresa pode querer minimizar custos de produção, um viajante pode buscar o caminho mais curto entre dois pontos, ou um investidor pode tentar maximizar o retorno de um portfólio. Em cada caso, a função objetivo quantifica o que significa ser “melhor” ou “mais eficiente”.

\paragraph{}
Pensando em modelagem de problemas em grafos, podemos pensar em exemplos clássicos de otimização:

\begin{itemize}
    \item \textbf{Caminho mais curto}: Dado um grafo com pesos nas arestas, encontrar o caminho entre dois vértices que minimize a soma dos pesos das arestas percorridas.
    \item \textbf{Árvore geradora mínima}: Encontrar uma árvore que conecte todos os vértices de um grafo com o menor custo total das arestas.
    \item \textbf{Fluxo máximo}: Em um grafo direcionado com limites nas arestas, encontrar o fluxo máximo que pode ser enviado de uma fonte a um sumidouro sem exceder esses limites.
\end{itemize}

\paragraph{A dualidade}

\paragraph{}
O taoísmo chinês fala do yin e yang, forças opostas que se complementam. Um conceito que remete à contrastes, noite e dia, matéria e anti-matéria, máximos e mínimos. Na matemática, um conceito semelhante é a \emph{dualidade}, que conecta problemas de minimização a problemas de maximização.

\paragraph{}
Em termos matemáticos, para cada problema de otimização (o \emph{primal}), existe um problema associado (o \emph{dual}) que oferece uma perspectiva complementar. Resolver um desses problemas pode fornecer insights ou soluções para o outro.

\paragraph{Exemplo:}
Considere um problema de otimização onde queremos minimizar o custo de transporte de mercadorias entre diferentes armazéns. O problema primal busca a solução de transporte que minimize os custos totais, enquanto o problema dual pode ser formulado como a maximização do valor dos recursos disponíveis (como a capacidade dos armazéns e a demanda dos clientes).

\paragraph{}
No nosso texto, consideramos como problema primal a minimização do custo de uma estrutura (como uma árvore geradora mínima) e como dual a maximização de um conjunto de pesos ou preços que justificam esse custo mínimo. A relação entre primal e dual é formalizada por teoremas de dualidade, que garantem que o valor ótimo do primal é igual ao valor ótimo do dual sob certas condições.

\paragraph{}
Esse ponto de vista leva a “teoremas min–max” que ligam problemas de \emph{minimização} a problemas de \emph{maximização} e fornecem certificados verificáveis de otimalidade.

\begin{figure}[H]
\centering
\begin{tikzpicture}[>=Stealth, node distance=1.4cm]
    % estilos
    \tikzset{
        box/.style={draw, rounded corners, fill=blue!5, minimum width=37mm, minimum height=10mm, align=center},
        arrow/.style={->, semithick, draw=gray!70},
        badge/.style={draw=green!50!black, rounded corners, fill=green!10, inner sep=4pt, font=\scriptsize}
    }

    % caixas primal (min) e dual (max)
    \node[box] (min) {Minimização\\(cobrir)};
    \node[box, right=4.2cm of min] (max) {Maximização\\(empacotar)};

    % relação de valores dual <= primal
    \draw[arrow] (max.west) -- node[above, font=\scriptsize, black!70]{valor dual $\;\le\;$ valor primal} (min.east);

    % destaque do "min--max" (igualdade no ótimo)
    \path (min) -- (max) node[pos=0.5, yshift=12mm, badge] (mm) {teorema min--max: igualdade no ótimo};

    % certificado de otimalidade
    \path (min) -- (max) node[pos=0.5, yshift=-12mm, badge] (cert) {certificado: verificação simples do ótimo};
\end{tikzpicture}
\caption{Intuição de min--max: um problema de cobrir (minimização) e um de empacotar (maximização) andam juntos. Sempre vale valor dual $\le$ valor primal; quando há igualdade, temos um certificado de otimalidade.}
\label{fig:min-max-cert}
\end{figure}

\paragraph{}
No contexto de grafos, a otimização costuma aparecer como a busca por subestruturas (caminhos, árvores, cortes, fluxos) que minimizam ou maximizam um custo, sempre respeitando a topologia do grafo.

\paragraph{}
Nesta dissertação, essa noção de otimização é central: olhamos para o mesmo problema por dois ângulos que se completam. No lado “primal”, queremos montar diretamente a arborescência de menor custo. O algoritmo de Chu–Liu/Edmonds faz isso de forma gulosa: ajusta os custos por vértice, cria arestas de custo zero (0‑arestas), contrai ciclos quando aparecem e segue até montar a solução ótima. 
(\cite{chu1965,edmonds1967optimum}).

\paragraph{}
No lado “dual”, em vez de montar a árvore, colocamos custos em cortes do grafo com raiz $r$. A regra é simples: nenhum custo pode ultrapassar o custo das arestas que cruzam o corte. Buscamos escolher esses custos para somar o máximo possível. As arestas que “batem no limite” viram 0‑arestas, e a partir delas conseguimos reconstruir uma arborescência ótima. Essa visão, desenvolvida por Frank, leva a um teorema min–max e a um procedimento em duas etapas: primeiro ajustamos os custos, depois extraímos a solução usando apenas 0‑arestas. 
(cf. \cite{frank2014,schrijver2003comb})

\subsection{Problemas interessantes}

\paragraph{}
Qual o número mínimo de cores necessárias para colorir um mapa de países, de modo que países vizinhos tenham cores diferentes? Qual o caminho mais curto entre duas cidades em um mapa rodoviário? Como encontrar a árvore geradora mínima que conecta todas as cidades com o menor custo total? Essas perguntas são exemplos clássicos de problemas que podem ser modelados e resolvidos usando a teoria dos grafos. Vistas sob a lente da navalha de occam, todas elas buscam a solução mais parcimoniosa que atende ao requisito: usar poucas cores, percorrer um caminho curto ou conectar tudo com custo mínimo.

\begin{figure}[H]
\centering
\begin{tikzpicture}[>=Stealth]
    % estilo de vértice e arestas
    \tikzset{v/.style={circle, draw, thick, minimum size=7mm, inner sep=0pt}, e/.style={semithick, draw=gray!70}}

    % vértices de um K4 (exige 4 cores)
    \node[v, fill=red!30, label=below:$v_1$]  (v1) at (0,0) {};
    \node[v, fill=blue!30, label=below:$v_2$] (v2) at (2.1,0) {};
    \node[v, fill=green!35, label=above:$v_3$] (v3) at (1,1.9) {};
    \node[v, fill=orange!40, label=right:$v_4$] (v4) at (1,0.75) {};

    % arestas (todas as pares -> K4)
    \draw[e] (v1) -- (v2);
    \draw[e] (v2) -- (v3);
    \draw[e] (v3) -- (v1);
    \draw[e] (v1) -- (v4);
    \draw[e] (v2) -- (v4);
    \draw[e] (v3) -- (v4);
\end{tikzpicture}
\caption{Coloração de grafos: exemplo de coloração própria do grafo completo $K_4$. Como $K_4$ é completo, precisamos de 4 cores para colorir seus vértices de modo que vértices adjacentes tenham cores diferentes. Uma coloração é uma função $\varphi:V\to C$ tal que, se $uv\in E$, então $\varphi(u)\neq\varphi(v)$.}
\label{fig:coloracao}
\end{figure}

\paragraph{}
Sem a teoria dos grafos, seria difícil formalizar e resolver esses problemas de maneira eficiente. Ao representar situações do mundo real como grafos, tornamos a parcimônia da navalha de occam algo operacional: escolhemos uma medida simples (número de cores, comprimento, custo) e aplicamos algoritmos que, entre as soluções viáveis, minimizam ou maximizam esse critério — produzindo soluções ótimas ou, quando necessário, boas aproximações.

\subsection{Grafos}
\paragraph{}
Falamos bastante de grafos ao longo do texto, aqui fixamos a noção básica. 

\paragraph{}
Um \textbf{grafo} \(G = (V, E)\) é uma estrutura matemática composta por um conjunto \(V\) de \emph{vértices} (ou \emph{nós}) e um conjunto \(E\) de \emph{arestas} (ou \emph{ligações}) que conectam pares de vértices. 

\begin{figure}[H]
\centering
\begin{tikzpicture}[>=Stealth]
    % estilos
    \tikzset{v/.style={circle, draw, fill=blue!10, minimum size=7mm, inner sep=0pt}, e/.style={semithick, draw=gray!70}}

    % vértices (V)
    \node[v, label=below:$v_1$] (v1) at (0,0) {};
    \node[v, label=below:$v_2$] (v2) at (2.0,0) {};
    \node[v, label=above:$v_3$] (v3) at (2.0,1.6) {};
    \node[v, label=above:$v_4$] (v4) at (0,1.6) {};

    % arestas (E: pares não ordenados)
    \draw[e] (v1) -- (v2);
    \draw[e] (v2) -- (v3);
    \draw[e] (v3) -- (v4);
    \draw[e] (v4) -- (v1);

    % legenda com os conjuntos V e E
    \node[align=left, anchor=west] at (3.0,0.9) {$V=\{v_1,v_2,v_3,v_4\}$\\ $E=\{\{v_1,v_2\},\{v_2,v_3\},\{v_3,v_4\},\{v_4,v_1\}\}$};
\end{tikzpicture}
\caption{Definição de grafo: exemplo de grafo simples \(G=(V,E)\). Pontos representam os vértices \(V\) e linhas representam as arestas \(E\), que são pares não ordenados de vértices distintos.}
\label{fig:def-grafo}
\end{figure}

\paragraph{}
O conjunto de vértices \(V\) pode ser definido como \(V = \{v_1, v_2, \ldots, v_n\}\), onde cada \(v_i\) representa um ponto distinto no grafo. O conjunto de arestas \(E\) é um conjunto de pares não ordenados de vértices, ou seja, \(E \subseteq \{\{u, v\} \mid u, v \in V, u \neq v\}\). Cada aresta \(\{u, v\}\) indica uma conexão entre os vértices \(u\) e \(v\).

\paragraph{}
Esses vértices e arestas podem representar uma variedade de entidades e relações no mundo real. Por exemplo, em um grafo que modela uma rede social, os vértices podem representar pessoas, e as arestas podem representar amizades entre elas. Em um grafo que representa uma rede de transporte, os vértices podem ser cidades, e as arestas podem ser estradas ou rotas de voo conectando essas cidades.

\paragraph{}
Tendo em mente esses problemas, podemos falar de custos associados às arestas. Por exemplo, em um grafo que representa uma rede de transporte, cada aresta pode ter um custo associado, como a distância entre duas cidades ou o tempo necessário para percorrer uma estrada. Em um grafo que modela uma rede de comunicação, as arestas podem ter custos relacionados à largura de banda ou à latência.

\paragraph{}
Esses custos representam uma função \(c: E \to \mathbb{R}^+\) que atribui um valor numérico não negativo a cada aresta do grafo. Assim, para cada aresta \(\{u, v\} \in E\), \(c(\{u, v\})\) representa o custo associado a essa conexão.

\begin{figure}[H]
\centering
\begin{tikzpicture}[>=Stealth]
    % estilos
    \tikzset{v/.style={circle, draw, fill=blue!10, minimum size=7mm, inner sep=0pt}, e/.style={semithick, draw=gray!70}}

    % vértices
    \node[v, label=below:$v_1$] (v1) at (0,0) {};
    \node[v, label=below:$v_2$] (v2) at (2.2,0) {};
    \node[v, label=above:$v_3$] (v3) at (3.0,1.8) {};
    \node[v, label=above:$v_4$] (v4) at (-0.4,1.8) {};

    % arestas com custos (rótulos c(e))
    \draw[e] (v1) -- node[midway, fill=white, inner sep=2pt, font=\scriptsize] {3} (v2);
    \draw[e] (v2) -- node[midway, fill=white, inner sep=2pt, font=\scriptsize] {5} (v3);
    \draw[e] (v3) -- node[midway, fill=white, inner sep=2pt, font=\scriptsize] {2} (v4);
    \draw[e] (v4) -- node[midway, fill=white, inner sep=2pt, font=\scriptsize] {4} (v1);
    \draw[e] (v1) -- node[midway, fill=white, inner sep=2pt, font=\scriptsize] {6} (v3);

    % legenda breve
    \node[align=left, anchor=west] at (4.0,1.0) {$c:E\to\mathbb{R}^+$\\ $c(\{v_1,v_2\})=3,\; c(\{v_1,v_3\})=6,\dots$};
\end{tikzpicture}
\caption{Grafo com custos nas arestas: a função $c:E\to\mathbb{R}^+$ atribui a cada aresta um custo $c(e)$ (mostrado junto às arestas). Por exemplo, $c(\{v_1,v_2\})=3$. O custo total de um subconjunto $F\subseteq E$ é $C(F)=\sum_{e\in F} c(e)$.}
\label{fig:grafo-custos}
\end{figure}

\paragraph{}
Grafos apresentam diversas estruturas especiais. Essas estruturas são definidas como subgrafos e são fundamentais para entender a topologia e as propriedades dos grafos, e muitas vezes são o foco de problemas de otimização. 

\subsubsection{Subgrafos}
\paragraph{}Um \textbf{subgrafo} \(H = (V_H, E_H)\) de um grafo \(G = (V, E)\) é um grafo cujos vértices e arestas são subconjuntos dos vértices e arestas de \(G\). Formalmente, \(V_H \subseteq V\) e \(E_H \subseteq E\), e cada aresta em \(E_H\) conecta dois vértices em \(V_H\).

\paragraph{}
Alguns subgrafos interessantes incluem: caminhos, ciclos, componentes conexas e árvores. Muitas propriedades e algoritmos em grafos dependem dessas estruturas, como encontrar o caminho mais curto entre dois vértices, detectar ciclos ou construir árvores geradoras mínimas. Dentre essas muitas estruturas especiais, vamos apresentar as que são relevantes para o desenvolvimento desta dissertação:

\paragraph{Caminhos}
\paragraph{}Um \textbf{caminho} em um grafo é uma sequência de vértices conectados por arestas. Formalmente, um caminho \(P\) de comprimento \(k\geq 1\) é uma sequência de vértices \(P = (v_1, v_2, \ldots, v_{k+1})\) tal que cada par consecutivo \((v_i, v_{i+1})\) é uma aresta em \(E\). O comprimento do caminho é o número de arestas que ele contém, que é \(k\).

\begin{figure}[H]
\centering
\begin{tikzpicture}[>=Stealth]
    % estilos
    \tikzset{v/.style={circle, draw, fill=blue!10, minimum size=7mm, inner sep=0pt}, e/.style={semithick, draw=gray!60}, p/.style={very thick, draw=blue!60}}

    % vértices do caminho
    \node[v, label=below:$v_1$] (v1) at (0,0) {};
    \node[v, label=below:$v_2$] (v2) at (1.8,0) {};
    \node[v, label=below:$v_3$] (v3) at (3.6,0) {};
    \node[v, label=below:$v_4$] (v4) at (5.4,0) {};

    % vértices extras (arestas que não fazem parte do caminho)
    \node[v, label=above:$x$] (x) at (1.8,1.2) {};
    \node[v, label=above:$y$] (y) at (3.6,1.2) {};

    % arestas não pertencentes ao caminho (cinza)
    \draw[e] (v1) -- (x);
    \draw[e] (x) -- (v3);
    \draw[e] (y) -- (v4);

    % caminho destacado (azul)
    \draw[p] (v1) -- (v2);
    \draw[p] (v2) -- (v3);
    \draw[p] (v3) -- (v4);

    % legenda
    \node[align=left, anchor=west] at (6.2,0.6) {$P=(v_1,v_2,v_3,v_4)$\\ $|P|=3$};
\end{tikzpicture}
\caption{Caminho em grafo não dirigido: o caminho $P=(v_1,v_2,v_3,v_4)$ está destacado em azul. Seu comprimento é o número de arestas percorridas, $|P|=3$.}
\label{fig:caminho}
\end{figure}

\paragraph{Ciclos}
\paragraph{}Um \textbf{ciclo} é um caminho que começa e termina no mesmo vértice, ou seja, \(v_1 = v_{k+1}\). Formalmente, um ciclo \(C\) é uma sequência de vértices \(C = (v_1, v_2, \ldots, v_k, v_1)\) tal que cada par consecutivo \((v_i, v_{i+1})\) é uma aresta em \(E\) e \(k \geq 2\). O comprimento do ciclo é o número de arestas que ele contém, que é \(k\).

\begin{figure}[H]
\centering
\begin{tikzpicture}[>=Stealth]
    % estilos
    \tikzset{v/.style={circle, draw, fill=blue!10, minimum size=7mm, inner sep=0pt}, e/.style={semithick, draw=gray!60}, c/.style={very thick, draw=blue!60}}

    % vértices do ciclo (dispostos aproximadamente em círculo)
    \node[v, label=below:$v_1$] (v1) at (0,0) {};
    \node[v, label=right:$v_2$] (v2) at (2.0,0.8) {};
    \node[v, label=above:$v_3$] (v3) at (1.2,2.1) {};
    \node[v, label=left:$v_4$] (v4) at (-0.8,1.6) {};

    % arestas não pertencentes ao ciclo (cinza)
    \node[v, label=right:$x$] (x) at (2.6,1.8) {};
    \draw[e] (x) -- (v2);
    \draw[e] (x) -- (v3);

    % ciclo destacado (azul)
    \draw[c] (v1) -- (v2);
    \draw[c] (v2) -- (v3);
    \draw[c] (v3) -- (v4);
    \draw[c] (v4) -- (v1);

    % legenda
    \node[align=left, anchor=west] at (3.2,1.0) {$C=(v_1,v_2,v_3,v_4,v_1)$\\ $|C|=4$};
\end{tikzpicture}
\caption{Ciclo em grafo não dirigido: o ciclo $C=(v_1,v_2,v_3,v_4,v_1)$ está destacado em azul. Seu comprimento é o número de arestas, $|C|=4$.}
\label{fig:ciclo}
\end{figure}

\paragraph{Componentes conexas}
\paragraph{}Uma \textbf{componente conexa} de um grafo é um subgrafo maximal que é conexo. Formalmente, uma componente conexa \(C\) é um subgrafo \(C = (V_C, E_C)\) onde \(V_C \subseteq V\) e \(E_C \subseteq E\), que satisfaz a seguinte propriedade:
\begin{itemize}
    \item \(C\) é conexo: existe um caminho entre qualquer par de vértices em \(V_C\).
\end{itemize}
Além disso, \(C\) é maximal, o que significa que não é possível adicionar mais vértices ou arestas a \(C\) sem perder a propriedade de conexidade.

\begin{figure}[H]
\centering
\begin{tikzpicture}[>=Stealth]
    % estilos
    \tikzset{v/.style={circle, draw, fill=blue!10, minimum size=7mm, inner sep=0pt}, e/.style={semithick, draw=gray!70}, comp/.style={draw=blue!40, rounded corners}}

    % Componente C1 (à esquerda)
    \node[v, label=above:$a$] (a) at (0,1.2) {};
    \node[v, label=below:$b$] (b) at (-0.8,0) {};
    \node[v, label=below:$c$] (c) at (0.8,0) {};
    \draw[e] (a) -- (b);
    \draw[e] (a) -- (c);
    \node[comp, fit=(a)(b)(c), inner sep=20pt, label={[blue!60]above:$C_1$}] {};

    % Componente C2 (centro)
    \node[v, label=below:$d$] (d) at (4,0) {};
    \node[v, label=below:$e$] (e) at (5.6,0) {};
    \draw[e] (d) -- (e);
    \node[comp, fit=(d)(e), inner sep=15pt, label={[blue!60]above:$C_2$}] {};

    % Componente C3 (direita)
    \node[v, label=above:$f$] (f) at (8.6,1.2) {};
    \node[v, label=below:$g$] (g) at (7.8,0) {};
    \node[v, label=below:$h$] (h) at (9.4,0) {};
    \draw[e] (f) -- (g);
    \draw[e] (f) -- (h);
    \draw[e] (g) -- (h);
    \node[comp, fit=(f)(g)(h), inner sep=20pt, label={[blue!60]above:$C_3$}] {};

    % texto explicativo
    \node[align=center, anchor=north west] at (-0.2,-1.0) {Cada caixa destaca uma \emph{componente conexa}.\\ Não há arestas entre $C_1$, $C_2$ e $C_3$.};
\end{tikzpicture}
\caption{Componentes conexas: o grafo possui três componentes $C_1$, $C_2$ e $C_3$. Cada $C_i$ é conexo e \emph{maximal}: adicionar qualquer vértice de fora quebraria a propriedade de conexidade interna ou exigiria arestas ausentes.}
\label{fig:componentes}
\end{figure}

\paragraph{Árvores}
\paragraph{}Uma \textbf{árvore} é um grafo conexo e acíclico. Formalmente, uma árvore \(T\) é um grafo \(T = (V_T, E_T)\) onde \(V_T \subseteq V\) e \(E
_T \subseteq E\), que satisfaz as seguintes propriedades:
\begin{itemize}
    \item \(T\) é conexo: existe um caminho entre qualquer par de vértices em \(V_T\).
    \item \(T\) é acíclico: não contém ciclos.
\end{itemize}
Além disso, uma árvore com \(n\) vértices sempre tem exatamente \(n-1\) arestas.

\begin{figure}[H]
\centering
\begin{tikzpicture}[>=Stealth]
    % estilos
    \tikzset{v/.style={circle, draw, fill=blue!10, minimum size=7mm, inner sep=0pt}, e/.style={semithick, draw=gray!70}}

    % vértices da árvore
    \node[v, label=below:$r$] (r) at (0,0) {};
    \node[v, label=above:$a$] (a) at (-1.6,1.4) {};
    \node[v, label=above:$b$] (b) at (0.0,1.8) {};
    \node[v, label=above:$c$] (c) at (1.6,1.4) {};
    \node[v, label=above:$d$] (d) at (-2.4,2.8) {};
    \node[v, label=above:$e$] (e) at (-0.8,3.0) {};
    \node[v, label=above:$f$] (f) at (0.8,3.0) {};

    % arestas da árvore (sem ciclos)
    \draw[e] (r) -- (a);
    \draw[e] (r) -- (b);
    \draw[e] (r) -- (c);
    \draw[e] (a) -- (d);
    \draw[e] (a) -- (e);
    \draw[e] (b) -- (f);

    % indicação de |E| = |V| - 1
    \node[align=left, anchor=west] at (3.0,1.8) {$|V_T|=7,\; |E_T|=6$\\ $|E_T|=|V_T|-1$};
\end{tikzpicture}
\caption{Árvore: grafo conexo e acíclico. No exemplo, $|V_T|=7$ e $|E_T|=6$, satisfazendo $|E_T|=|V_T|-1$. Não há ciclos e existe um único caminho simples entre quaisquer dois vértices.}
\label{fig:arvore}
\end{figure}

\paragraph{}
Para o nosso objetivo principal, nos interessa entendê-las em grafos que a direção das conexões (arestas) importa.

\subsection{Dígrafos: quando a direção importa}
\paragraph{}
Existem problemas que a direção das arestas faz toda a diferença. Por exemplo, em uma rede de tráfego, algumas ruas são de mão única, ou em uma rede de comunicação, os dados podem ser enviados em uma direção específica. Nesses casos, usamos \emph{grafos dirigidos} (ou grafos direcionados ou simplesmente dígrafos), onde as arestas são pares de vértices ordenados.

\paragraph{}
Um \textbf{grafo dirigido - dígrafo} (grafos direcionados) é uma estrutura matemática composta por um conjunto \(V\) de \emph{vértices} e um conjunto \(A\) de \emph{arcos} (ou \emph{arestas direcionadas}) que conectam pares ordenados de vértices.

\paragraph{}
Por vértices entendemos o mesmo conjunto que em grafos comuns, mas agora as arestas entre eles têm uma direção específica. Cada arco \((u, v) \in A\) indica uma conexão direcionada do vértice \(u\) para o vértice \(v\), significando que a relação ou fluxo ocorre de \(u\) para \(v\).

\paragraph{}
Assim, temos os conceitos de cabeça e cauda de um arco: em \((u, v)\), \(u\) é a \emph{cauda} (origem) e \(v\) é a \emph{cabeça} (destino). Esses conceitos podem ser formalizados por meio de funções \(s, t: A \to V\), onde \(s((u, v)) = u\) (cauda) e \(t((u, v)) = v\) (cabeça).

\begin{figure}[H]
\centering
\begin{tikzpicture}[>=Stealth]
    % estilos
    \tikzset{v/.style={circle, draw, fill=blue!10, minimum size=7mm, inner sep=0pt}, a/.style={->, semithick, draw=gray!70}}

    % vértices
    \node[v, label=below:$u$] (u) at (0,0) {};
    \node[v, label=below:$v$] (v) at (2.6,0) {};
    \node[v, label=above:$x$] (x) at (1.3,1.5) {};

    % arcos
    \draw[a] (u) -- node[above, sloped, font=\scriptsize] {$a$} (v);
    \draw[a] (x) -- (u);
    \draw[a] (v) -- (x);

    % anotações de cauda/cabeça
    \node[font=\scriptsize, anchor=north] at ($(u)!0.5!(v)$) {$a=(u,v)$};
    \path (u) ++(0,-0.9) node[font=\scriptsize] {cauda $s(a)=u$};
    \path (v) ++(0,-0.9) node[font=\scriptsize] {cabeça $t(a)=v$};
\end{tikzpicture}
\caption{Dígrafos: arcos têm direção. No arco $a=(u,v)$, $u$ é a \emph{cauda} (origem) e $v$ é a \emph{cabeça} (destino). As funções $s,t:A\to V$ dão a origem e o destino de cada arco.}
\label{fig:def-digrafo}
\end{figure}

\paragraph{}
Em digrafos podem ocorrer laços (arcos que conectam um vértice a ele mesmo, como \((u, u)\)) nesse caso as funções \(s\) e \(t\) coincidem. Também podem ocorrer múltiplos arcos entre o mesmo par de vértices (como \((u, v)\) e \((u, v)\) distintos). Pictograficamente representamos essas condições com setas com dupla ponta ou com rótulos diferentes.

\begin{figure}[H]
\centering
\begin{tikzpicture}[>=Stealth]
    % estilos
    \tikzset{v/.style={circle, draw, fill=blue!10, minimum size=7mm, inner sep=0pt}, a/.style={->, semithick, draw=gray!70}, p/.style={->, draw=gray!60}};

    % vértices
    \node[v, label=below:$a$] (a) at (0,0) {};
    \node[v, label=below:$b$] (b) at (2,0) {};
    \node[v, label=above:$c$] (c) at (1,1.5) {};
    \node[v, label=above:$d$] (d) at (3,1.5) {};
    \node[v, label=below:$e$] (e) at (4,0) {};
    \node[v, label=below:$f$] (f) at (5,0) {};
    \node[v, label=above:$g$] (g) at (4.5,1.5) {};
    \node[v, label=above:$h$] (h) at (5.5,1.5) {};

    % arcos
    \draw[a] (a) -- (b);
    \draw[a] (c) -- (a);
    \draw[a] (b) -- (c);
    \draw[a] (d) -- (b);
    \draw[a] (e) -- (d);
    \draw[->, semithick, draw=gray!70] (f) -- (e);
    \draw[a] (g) -- (f);
    \draw[a] (h) -- (g);
    \draw[p] (b) to[bend left=30] (e);
    \draw[p] (e) to[bend left=30] (b);
    \draw[p] (f) to[bend left=40] (f); % laço
\end{tikzpicture}
\caption{Dígrafo: exemplo de grafo dirigido \(D=(V,A)\). Pontos representam os vértices \(V\) e setas representam os arcos \(A\), que são pares ordenados de vértices. Laços (como \((f,f)\)) e múltiplos arcos (como \((b,e)\) e \((e,b)\)) são permitidos.}
\label{fig:def-digrafo-simples}
\end{figure}       

\paragraph{}
Tal qual os grafos comuns, os dígrafos podem ter custos associados aos arcos. A função de custo \(c: A \to \mathbb{R}^+\) atribui um valor numérico geralmente não negativo a cada arco do dígrafo. Assim, para cada arco \((u, v) \in A\), \(c((u, v))\) representa o custo associado a essa conexão direcionada.

\begin{figure}[H]
\centering
\begin{tikzpicture}[>=Stealth]
    % estilos
    \tikzset{v/.style={circle, draw, fill=blue!10, minimum size=7mm, inner sep=0pt}, a/.style={->, semithick, draw=gray!70}}

    % vértices
    \node[v, label=below:$s$] (s) at (0,0) {};
    \node[v, label=above:$u$] (u) at (2,1.0) {};
    \node[v, label=below:$v$] (v) at (2,-1.0) {};
    \node[v, label=below:$t$] (t) at (4,0) {};

    % arcos com custos
    \draw[a] (s) -- node[midway, fill=white, inner sep=2pt, font=\scriptsize] {2} (u);
    \draw[a] (s) -- node[midway, fill=white, inner sep=2pt, font=\scriptsize] {4} (v);
    \draw[a] (u) -- node[midway, fill=white, inner sep=2pt, font=\scriptsize] {1} (v);
    \draw[a] (u) -- node[midway, fill=white, inner sep=2pt, font=\scriptsize] {5} (t);
    \draw[a] (v) -- node[midway, fill=white, inner sep=2pt, font=\scriptsize] {3} (t);

    % legenda
    \node[align=left, anchor=west] at (5.1,0.9) {$c:A\to\mathbb{R}^+$\\ $c((s,u))=2,\; c((v,t))=3,\dots$\\ $C(P)=\sum\limits_{a\in P} c(a)$};
\end{tikzpicture}
\caption{Dígrafos com custos nos arcos: a função $c:A\to\mathbb{R}^+$ atribui a cada arco $(u,v)$ um custo $c((u,v))$ (mostrado junto à seta). O custo de um caminho $P$ é a soma dos custos de seus arcos, $C(P)=\sum_{a\in P} c(a)$.}
\label{fig:digrafo-custos}
\end{figure}

\paragraph{}
Um conceito importante em dígrafos é o de grau de um vértice. O \textbf{grau de entrada} (ou \emph{in-degree}) de um vértice \(v\), denotado por \(d^-(v)\), é o número de arcos que chegam a \(v\) (ou seja, o número de arcos cujo destino é \(v\)). O \textbf{grau de saída} (ou \emph{out-degree}) de um vértice \(v\), denotado por \(d^+(v)\), é o número de arcos que saem de \(v\) (ou seja, o número de arcos cuja origem é \(v\)). Formalmente, temos:
\[d^-(v) = |\{(u, v) \in A \mid u \in V\}|\]
\[d^+(v) = |\{(v, w) \in A \mid w \in V\}|\]

\paragraph{}
Esse conceito é útil para analisar conectividade, o que nos leva ao próximo tópico, empacotamento de vértices.

\paragraph{Empacotamento de Vértices}
\paragraph{}Um \textbf{empacotamento de vértices} (conjunto independente) em um dígrafo é um conjunto \(S\subseteq V\) tal que, no subdígrafo induzido por \(S\), todo vértice tem grau de entrada e de saída iguais a zero. Em notação de graus, se denotamos por \(D[S]\) o subdígrafo induzido, então para todo \(v\in S\) vale \(d^-_{D[S]}(v)=0\) e \(d^+_{D[S]}(v)=0\). Isso é equivalente a dizer que não existe arco com ambas as extremidades em \(S\) (isto é, nenhum \((u,v)\in A\) com \(u,v\in S\)).

\paragraph{Empacotamento Máximo de Vértices}
\paragraph{}
Um \textbf{empacotamento máximo de vértices} é um empacotamento de vértices que contém o maior número possível de vértices. Em outras palavras, é um conjunto \(S\subseteq V\) tal que não existem arcos entre vértices em \(S\) e \(S\) é o maior possível em termos de cardinalidade. Encontrar um empacotamento máximo em um dígrafo é um problema NP-difícil, vamos falar sobre o que isso significa na sessão de algoritmos e complexidade.

\begin{figure}[H]
\centering
\begin{tikzpicture}[>=Stealth]
    % estilos
    \tikzset{v/.style={circle, draw, fill=blue!10, minimum size=7mm, inner sep=0pt}, a/.style={->, semithick, draw=gray!70}}
    % vértices
    \node[v, label=below:$a$, fill=green!18] (a) at (0,0) {};
    \node[v, label=below:$b$] (b) at (2,0) {};
    \node[v, label=above:$c$] (c) at (1,1.6) {};
    \node[v, label=above:$d$, fill=green!18] (d) at (3,1.6) {};
    \node[v, label=below:$e$] (e) at (4,0) {};
    \node[v, label=above:$f$, fill=green!18] (f) at (5.2,1.1) {};
    % arcos do dígrafo
    \draw[a] (a) -- (b);
    \draw[a] (c) -- (a);
    \draw[a] (b) -- (c);
    \draw[a] (d) -- (b);
    \draw[a] (e) -- (d);
    \draw[a] (f) -- (e);
    % anotação
    \node[align=left, anchor=west] at (6.2,1.0) {$S^{*}=\{a,d,f\}$ é máximo\\ (não há arco com extremidades em $S^{*}$)};
\end{tikzpicture}
\caption{Empacotamento máximo de vértices: para este dígrafo, $S^{*}=\{a,d,f\}$ (vértices em verde) é um conjunto independente de tamanho máximo.}
\label{fig:empacotamento-max}
\end{figure}

\paragraph{}
Esses conceitos de conectividade e empacotamento de vértices nos levam a explorar as subestruturas especiais que existem em dígrafos, que são similares às que vimos em grafos comuns, mas com algumas diferenças importantes devido à direção dos arcos.

\subsubsection{Subestruturas em dígrafos}

\paragraph{}
Tal qual os grafos que discutimos na sessão anterior, os dígrafos também possuem as mesmas estruturas especiais, essas estruturas chamadas sub-digrafos mudam um pouco em nomenclatura: caminhos quando direcionados são chamados de trilhas, e ciclos são chamados de circuitos e componentes conexas são componentes fortemente conexas e árvores viram arborescências. Além da nomenclatura, a direção dos arcos traz algumas nuances importantes, discutiremos sobre essas nuances apenas na sessão de arborescências e como os algoritmos de busca mudam bastante em complexidade se estamos tratando de arborescências ou árvores comuns.

\paragraph{}
Um \textbf{subdígrafo} \(D' = (V', A')\) de um dígrafo \(D = (V, A)\) é um dígrafo onde \(V' \subseteq V\) e \(A' \subseteq A\). Ou seja, \(D'\) é formado por um subconjunto dos vértices e arcos de \(D\).

\begin{figure}[H]
\centering
\begin{tikzpicture}[>=Stealth]
    % estilos
    \tikzset{v/.style={circle, draw, fill=blue!10, minimum size=7mm, inner sep=0pt}, a/.style={->, semithick, draw=gray!70}, sub/.style={->, draw=blue!60}}
    % vértices
    \node[v, label=below:$a$] (a) at (0,0) {};
    \node[v, label=below:$b$] (b) at (2,0) {};
    \node[v, label=above:$c$] (c) at (1,1.5) {};
    \node[v, label=above:$d$] (d) at (3,1.5) {};
    \node[v, label=below:$e$] (e) at (4,0) {};
    \node[v, label=below:$f$] (f) at (5,0) {};
    \node[v, label=above:$g$] (g) at (4.5,1.5) {};
    \node[v, label=above:$h$] (h) at (5.5,1.5) {};
    % arcos
    \draw[a] (a) -- (b);
    \draw[a] (c) -- (a);
    \draw[a] (b) -- (c);
    \draw[a] (d) -- (b);
    \draw[a] (e) -- (d);
    \draw[a] (f) -- (e);
    \draw[a] (g) -- (f);
    \draw[a] (h) -- (g);
    \draw[sub] (b) to[bend left=30] (e);
    \draw[sub] (e) to[bend left=30] (b);
    \draw[sub] (f) to[bend left=40] (f); % laço
    % subdígrafo destacado
    \node[draw=blue!40, rounded corners, fit=(b)(c)(d)(e), inner sep=15pt, label={[blue!60]above:$D'$}] {};
\end{tikzpicture}
\caption{Subdígrafo: o subdígrafo $D'=(V',A')$ está destacado em azul. Aqui, $V'=\{b,c,d,e\}$ e $A'=\{(b,c),(c,b),(d,b),(e,d),(b,e),(e,b)\}$.}
\label{fig:subdigrafo}
\end{figure}

\paragraph{Subdigrafos Induzidos}
\paragraph{}
Um subdigrafo pode ser \emph{induzido} por um conjunto de vértices \(V' \subseteq V\), denotado como \(D[V']\). Nesse caso, o conjunto de arcos \(A'\) inclui todos os arcos em \(A\) que têm ambas as extremidades em \(V'\), ou seja, \(A' = \{(u, v) \in A \mid u, v \in V'\}\).

\begin{figure}[H]
\centering
\begin{tikzpicture}[>=Stealth]
    % estilos
    \tikzset{v/.style={circle, draw, fill=blue!10, minimum size=7mm, inner sep=0pt}, a/.style={->, semithick, draw=gray!60}, ind/.style={->, very thick, draw=blue!60}}
    % vértices
    \node[v, label=below:$a$] (a) at (0,0) {};
    \node[v, label=below:$b$] (b) at (2,0) {};
    \node[v, label=above:$c$] (c) at (1,1.6) {};
    \node[v, label=above:$d$] (d) at (3,1.6) {};
    \node[v, label=below:$e$] (e) at (4.2,0) {};
    \node[v, label=below:$f$] (f) at (5.4,0) {};
    % arcos do dígrafo (cinza)
    \draw[a] (a) -- (b);
    \draw[a] (c) -- (a);
    \draw[a] (e) -- (d);
    \draw[a] (f) -- (e);
    \draw[a] (b) to[bend left=20] (e);
    \draw[a] (e) to[bend left=20] (b);
    % arcos em D[V'] (azul): todas as arestas com ambas as extremidades em V'
    \draw[ind] (b) -- (c);
    \draw[ind] (c) -- (d);
    \draw[ind] (d) -- (b);
    % destaque do conjunto de vértices V'
    \node[draw=blue!40, rounded corners, fit=(b)(c)(d), inner sep=12pt, label={[blue!60]above:$V'=\{b,c,d\}$}] {};
\end{tikzpicture}
\caption{Subdígrafo induzido: para $V'=\{b,c,d\}$, o subdígrafo $D[V']$ contém todos os arcos de $D$ cujas extremidades pertencem a $V'$ (em azul). Arcos que incidem em $V'$ mas conectam a vértices fora de $V'$ não pertencem a $D[V']$.}
\label{fig:subdigrafo-induzido}
\end{figure}

\paragraph{Subdigrafo Maximal}
\paragraph{}
Um subdigrafo é tido como maximal se não é possível adicionar mais vértices ou arcos a ele sem perder alguma propriedade específica, como conexidade ou aciclicidade.

\begin{figure}[H]
\centering
\begin{tikzpicture}[>=Stealth]
    % estilos
    \tikzset{v/.style={circle, draw, fill=blue!10, minimum size=7mm, inner sep=0pt}, a/.style={->, semithick, draw=gray!60}, keep/.style={->, very thick, draw=blue!60}}
    % vértices (triângulo)
    \node[v, label=below:$b$] (b) at (0,0) {};
    \node[v, label=below:$c$] (c) at (2.0,0) {};
    \node[v, label=above:$d$] (d) at (1.0,1.6) {};
    % arcos do dígrafo original (cinza)
    \draw[a] (b) -- (c);
    \draw[a] (c) -- (d);
    \draw[a] (d) -- (b);
    % subdígrafo maximal acíclico (azul): mantém dois arcos, omite o terceiro que fecharia o circuito
    \draw[keep] (b) -- (c);
    \draw[keep] (c) -- (d);
    % anotação
    \node[align=left, anchor=west] at (3.0,0.9) {$D'=\{b,c,d\},\ {(b,c),(c,d)}$ é acíclico.\\ Adicionar $(d,b)$ cria o circuito $b\to c\to d\to b$.};
\end{tikzpicture}
\caption{Subdígrafo maximal (por aciclicidade): $D'$ é acíclico e maximal em $D$; adicionar o arco restante $(d,b)$ cria um circuito.}
\label{fig:subdigrafo-maximal}
\end{figure}

\paragraph{Subdigrafo Gerador}
\paragraph{}
Um subdigrafo é tido como gerador se inclui todos os vértices do dígrafo original, ou seja, \(V' = V\). Nesse caso, o subdigrafo é formado por um subconjunto dos arcos do dígrafo original.

\begin{figure}[H]
\centering
\begin{tikzpicture}[>=Stealth]
    % estilos
    	\tikzset{v/.style={circle, draw, fill=blue!10, minimum size=7mm, inner sep=0pt}, a/.style={->, semithick, draw=gray!60}, span/.style={->, very thick, draw=blue!60}}
    % vértices
    \node[v, label=below:$a$] (a) at (0,0) {};
    \node[v, label=below:$b$] (b) at (2,0) {};
    \node[v, label=above:$c$] (c) at (1,1.6) {};
    \node[v, label=above:$d$] (d) at (3,1.6) {};
    \node[v, label=below:$e$] (e) at (4.2,0) {};
    \node[v, label=below:$f$] (f) at (5.4,0) {};
    % arcos do dígrafo original (cinza)
    \draw[a] (a) -- (b);
    \draw[a] (c) -- (a);
    \draw[a] (b) -- (c);
    \draw[a] (d) -- (b);
    \draw[a] (e) -- (d);
    \draw[a] (f) -- (e);
    \draw[a] (b) to[bend left=20] (e);
    \draw[a] (e) to[bend left=20] (b);
    % arcos do subdígrafo gerador (azul): V'=V e A' \subseteq A
    \draw[span] (a) -- (b);
    \draw[span] (b) -- (c);
    \draw[span] (d) -- (b);
    \draw[span] (e) -- (d);
    \draw[span] (f) -- (e);
    % anotação
    \node[align=left, anchor=west] at (6.4,1.0) {$V'=V$\\ $A'\subseteq A$};
\end{tikzpicture}
\caption{Subdígrafo gerador: inclui todos os vértices do dígrafo original ($V'=V$) e apenas um subconjunto dos arcos (em azul).}
\label{fig:subdigrafo-gerador}
\end{figure}

\paragraph{}
Com essas definições em mente, podemos explorar as subdigrafos específicos que citaremos ao longo da dissertação, começando pelas trilhas, circuitos, componentes fortemente conexas, componentes-fonte e arborescências.

\subsubsection{Subdigrafos Especiais}

\paragraph{Trilhas}

\paragraph{}
Uma \textbf{trilha} (ou caminho direcionado) em um dígrafo é uma sequência de vértices conectados por arcos que respeitam a direção. Formalmente, uma trilha \(P\) de comprimento \(k \geq 1\) é uma sequência de vértices \(P = (v_1, v_2, \ldots, v_{k+1})\) tal que cada par consecutivo \((v_i, v_{i+1})\) é um arco em \(A\). O comprimento da trilha é o número de arcos que ela contém, que é \(k\).

\begin{figure}[H]
\centering
\begin{tikzpicture}[>=Stealth]
    % estilos
    \tikzset{v/.style={circle, draw, fill=blue!10, minimum size=7mm, inner sep=0pt}, a/.style={->, semithick, draw=gray!60}, p/.style={->, draw=blue!60}};
    % vértices do caminho
    \node[v, label=below:$v_1$] (v1) at (0,0) {};
    \node[v, label=below:$v_2$] (v2) at (1.8,0) {};
    \node[v, label=below:$v_3$] (v3) at (3.6,0) {};
    \node[v, label=below:$v_4$] (v4) at (5.4,0) {};
    % vértices extras (arcos que não fazem parte do caminho)
    \node[v, label=above:$x$] (x) at (1.8,1.2) {};
    \node[v, label=above:$y$] (y) at (3.6,1.2) {};
    % arcos não pertencentes ao caminho (cinza)
    \draw[a] (v1) -- (x);
    \draw[a] (x) -- (v3);
    \draw[a] (y) -- (v4);
    % caminho destacado (azul)
    \draw[p] (v1) -- (v2);
    \draw[p] (v2) -- (v3);
    \draw[p] (v3) -- (v4);
    % legenda
    \node[align=left, anchor=west] at (6.2,0.6) {$P=(v_1,v_2,v_3,v_4)$\\ $|P|=3$};
\end{tikzpicture}
\caption{Trilha em dígrafo: a trilha $P=(v_1,v_2,v_3,v_4)$ está destacada em azul. Seu comprimento é o número de arcos percorridos, $|P|=3$.}
\label{fig:trilha}
\end{figure}

\paragraph{}
Uma conceito importante relacionado às trilhas é o de cortes. 

\paragraph{Cortes e Min-cortes}
\paragraph{}
Um \textbf{corte} em um dígrafo é um conjunto de arcos cuja remoção desconecta o dígrafo, ou seja, impede que haja uma trilha entre certos pares de vértices. Formalmente, dado um dígrafo \(D = (V, A)\), um corte \(C\) é um subconjunto de arcos \(C \subseteq A\) tal que a remoção dos arcos em \(C\) resulta em um dígrafo \(D' = (V, A \setminus C)\) onde não existe mais uma trilha (caminho direcionado) entre pelo menos um par de vértices \(u, v \in V\).

\begin{figure}[H]
\centering
\begin{tikzpicture}[>=Stealth]
    % estilos
    \tikzset{v/.style={circle, draw, fill=blue!10, minimum size=7mm, inner sep=0pt}, a/.style={->, semithick, draw=gray!70}, cut/.style={->, very thick, draw=red!70}};
    % vértices
    \node[v, label=below:$a$] (a) at (0,0) {};
    \node[v, label=below:$b$] (b) at (2,0) {};
    \node[v, label=above:$c$] (c) at (1,1.5) {};
    \node[v, label=below:$d$] (d) at (4,0) {};
    \node[v, label=above:$e$] (e) at (3,1.5) {};
    \node[v, label=below:$f$] (f) at (6,0) {};
    % arcos
    \draw[a] (a) -- (b);
    \draw[a] (b) -- (c);
    \draw[a] (c) -- (a);
    \draw[a] (b) -- (d);
    \draw[a] (d) -- (e);
    \draw[a] (e) -- (b);
    \draw[a] (d) -- (f);
    \draw[a] (f) -- (e);
    % corte destacado (vermelho)
    \draw[cut] (b) -- (d);
    % legenda
    \node[align=left, anchor=west] at (6.5,1.0) {Corte $C=\{(b,d)\}$\\ Remover $C$ desconecta $D$};
\end{tikzpicture}
\caption{Corte em dígrafo: o corte $C=\{(b,d)\}$ está destacado em vermelho. Remover esse arco desconecta o dígrafo, impedindo caminhos direcionados entre certos pares de vértices.}
\label{fig:corte}
\end{figure}

\paragraph{}
De forma resumida, dado um dígrafo \(D=(V,A)\) e um subconjunto \(X\subseteq V\), denotamos por um corte \(s\text{--}t\) é determinado pela escolha de um conjunto de vértices \(X\subseteq V\) tal que \(s\in X\) e \(t\notin X\); pensa-se nele como a “divisão” do grafo em dois lados: \(X\) e \(V\setminus X\).

Para tornar a notação precisa e fácil de ler:
\begin{itemize}
    \item \textbf{\(s\text{--}t\)}: lê-se “de \(s\) para \(t\)”. Aqui, \(s\) é a fonte (onde o fluxo nasce) e \(t\) é o sumidouro (onde o fluxo chega).
    \item \textbf{\(\delta^+(X)\)} (fronteira de saída de \(X\)): conjunto de todos os arcos que \emph{saem} de \(X\) para fora, isto é, para \(V\setminus X\).
    \item \textbf{\(\delta^-(X)\)} (fronteira de entrada de \(X\)): conjunto de todos os arcos que \emph{entram} em \(X\) vindos de \(V\setminus X\). Note que \(\delta^-(X)=\delta^+(V\setminus X)\).
    \item \textbf{Valor do corte}: dado um peso (ou custo) \(c:A\to\mathbb{R}_+\) para cada arco, o valor do corte induzido por \(X\) é a soma dos pesos dos arcos que cruzam de \(X\) para fora: 
    \[c(\delta^+(X))=\sum_{a\in\delta^+(X)} c(a).\]
    No caso não ponderado, esse valor coincide com a \emph{quantidade} de arcos que saem de \(X\).
\end{itemize}

\paragraph{Exemplo:} se \(\delta^+(X)=\{(u_1,v_1),(u_2,v_2)\}\) com \(c((u_1,v_1))=2\) e \(c((u_2,v_2))=3\), então \(c(\delta^+(X))=2+3=5\).

\paragraph{}
Um min-corte é um corte de tamanho mínimo, ou seja, é o corte com o menor número possível de arcos cuja remoção desconecta o dígrafo. Formalmente, dado um dígrafo \(D = (V, A)\), um min-corte \(C_{min}\) é um corte tal que para qualquer outro corte \(C\), \(|C_{min}| \leq |C|\). O tamanho do min-corte é o número de arcos em \(C_{min}\).

\begin{figure}[H]
\centering
\begin{tikzpicture}[>=Stealth]
    % estilos
    \tikzset{v/.style={circle, draw, fill=blue!10, minimum size=7mm, inner sep=0pt}, a/.style={->, semithick, draw=gray!70}, cut/.style={->, very thick, draw=red!70}};
    % vértices 
    \node[v, label=below:$a$] (a) at (0,0) {};
    \node[v, label=below:$b$] (b) at (2,0) {};
    \node[v, label=above:$c$] (c) at (1,1.5) {};
    \node[v, label=below:$d$] (d) at (4,0) {};
    \node[v, label=above:$e$] (e) at (3,1.5) {};
    \node[v, label=below:$f$] (f) at (6,0) {};
    % arcos
    \draw[a] (a) -- (b);
    \draw[a] (b) -- (c);
    \draw[a] (c) -- (a);
    \draw[a] (b) -- (d);
    \draw[a] (d) -- (e);
    \draw[a] (e) -- (b);
    \draw[a] (d) -- (f);
    \draw[a] (f) -- (e);
    % min-corte destacado (vermelho)
    \draw[cut] (b) -- (d);
    % legenda
    \node[align=left, anchor=west] at (6.5,1.0) {Min-corte $C_{min}=\{(b,d)\}$\\ $|C_{min}|=1$ é o menor corte que desconecta $D$};
\end{tikzpicture}
\caption{Min-corte em dígrafo: o min-corte $C_{min}=\{(b,d)\}$ está destacado em vermelho. Remover esse arco desconecta o dígrafo, e é o menor corte possível, com tamanho $|C_{min}|=1$.}
\label{fig:min-corte}
\end{figure}

Um teorema importante relacionado a min-cortes é o Teorema do Fluxo Máximo - Corte Mínimo, que estabelece uma relação entre o fluxo máximo que pode ser enviado de uma fonte \(s\) para um sumidouro \(t\) em um dígrafo e o valor do min-corte que separa \(s\) de \(t\). Escolhemos apresensentar esse teorema aqui pois ele traz uma intuição interessante sobre a relação entre fluxos e cortes em dígrafos, relevantes para os algoritmos que discutiremos mais adiante.

\paragraph{}
\begin{teobox}{Fluxo–Corte Máximo = Mínimo Corte.}{fluxo-corte}
Em dígrafos com limites/pesos não negativos nos arcos, o valor de um fluxo máximo de \(s\) para \(t\) é igual ao valor de um min-corte \(s\text{--}t\). Em símbolos: \(\max\,\text{valor}(f) = \min\, c(\delta^+(X))\), onde o mínimo é sobre \(X\subseteq V\) com \(s\in X\), \(t\notin X\), e \(c(\delta^+(X))=\sum_{a\in\delta^+(X)} c(a)\).
\paragraph{}
    \textbf{Prova (esboço):}
    \paragraph{}
    \emph{(i) Desigualdade \(\le\).} Seja \(f\) um fluxo qualquer. Para um corte \((X, V\setminus X)\) com \(s\in X\), \(t\notin X\), a conservação de fluxo implica que o fluxo líquido que sai de \(X\) é exatamente \(\text{valor}(f)\).

    Logo, \[\text{valor}(f)= \sum_{a\in\delta^+(X)} f(a) - \sum_{a\in\delta^-(X)} f(a) \le \sum_{a\in\delta^+(X)} f(a) \le \sum_{a\in\delta^+(X)} c(a)=c(\delta^+(X)),\]

    pois \(f(a)\le c(a)\) para todo arco (limite). Como isso vale para todo \(X\), obtemos \(\text{valor}(f)\le \min_X c(\delta^+(X))\).

    \paragraph{}
    \emph{(ii) Desigualdade \(\ge\) e igualdade.} Considere um fluxo máximo \(f\) sem caminho aumentante no \emph{grafo residual} \(R_f\) (isto é, não há como aumentar o valor do fluxo). Defina \(X\) como o conjunto de vértices alcançáveis a partir de \(s\) em \(R_f\). Então, não existe arco residual de \(X\) para \(V\setminus X\); logo, todo arco original que sai de \(X\) está saturado (\(f(a)=c(a)\)), e todo arco que entra em \(X\) carrega fluxo zero. Assim,

    \[\text{valor}(f)=\sum_{a\in\delta^+(X)} f(a)=\sum_{a\in\delta^+(X)} c(a)=c(\delta^+(X)).\]
    Portanto, \(f\) atinge exatamente o valor de um corte \(s\text{--}t\); em particular, esse corte é mínimo e \(f\) é máximo. \hfill$\square$

\paragraph{}
\smallskip
\textbf{Comentário:} Esse resultado é um protótipo de teorema \emph{min--max}: “empacotar” muito fluxo (caminhos) equivale a “cobrir” pouco com um corte. Ver, por exemplo, \cite{schrijver2003comb}.
\end{teobox}

\paragraph{}
Quando falamos em trilhas, precisamos também falar sobre circuitos, que são ciclos direcionados.
A diferença entre trilhas e circuitos é que trilhas são caminhos direcionados que não necessariamente retornam ao ponto de origem, enquanto circuitos são caminhos direcionados que começam e terminam no mesmo vértice.

\paragraph{Circuitos}
\paragraph{}
 Um \textbf{circuito} é um caminho direcionado que começa e termina no mesmo vértice, ou seja, \(v_1 = v_{k+1}\). Formalmente, um circuito \(C\) é uma sequência de vértices \(C = (v_1, v_2, \ldots, v_k, v_1)\) tal que cada par consecutivo \((v_i, v_{i+1})\) é um arco em \(A\) e \(k \geq 2\). O comprimento do circuito é o número de arcos que ele contém, que é \(k\).

\begin{figure}[H]
\centering
\begin{tikzpicture}[>=Stealth]
    % estilos
    \tikzset{v/.style={circle, draw, fill=blue!10, minimum size=7mm, inner sep=0pt}, a/.style={->, semithick, draw=gray!60}, c/.style={->, draw=blue!60}};
    % vértices do ciclo (dispostos aproximadamente em círculo)
    \node[v, label=below:$v_1$] (v1) at (0,0) {};
    \node[v, label=right:$v_2$] (v2) at (2.0,0.8) {};
    \node[v, label=above:$v_3$] (v3) at (1.2,2.1) {};
    \node[v, label=left:$v_4$] (v4) at (-0.8,1.6) {};
    % arcos não pertencentes ao ciclo (cinza)
    \node[v, label=right:$x$] (x) at (2.6,1.8) {};
    \draw[a] (x) -- (v2);
    \draw[a] (x) -- (v3);
    % ciclo destacado (azul)
    \draw[c] (v1) -- (v2);
    \draw[c] (v2) -- (v3);
    \draw[c] (v3) -- (v4);
    \draw[c] (v4) -- (v1);
    % legenda
    \node[align=left, anchor=west] at (3.2,1.0) {$C=(v_1,v_2,v_3,v_4,v_1)$\\ $|C|=4$};
\end{tikzpicture}
\caption{Ciclo direcionado em dígrafo: o ciclo $C=(v_1,v_2,v_3,v_4,v_1)$ está destacado em azul. Seu comprimento é o número de arcos, $|C|=4$.}
\label{fig:ciclo-direcionado}
\end{figure}

\paragraph{}
Propriedades importantes dos circuitos incluem:
\begin{itemize}
    \item \textbf{Circuito simples}: um circuito é dito simples se não repete vértices, exceto o vértice inicial/final. Ou seja, \(v_i \neq v_j\) para \(1 \leq i < j \leq k\).
    \item \textbf{Circuito Euleriano}: um circuito que percorre cada arco exatamente uma vez. Um dígrafo possui um circuito euleriano se e somente se é fortemente conexo e o grau de entrada é igual ao grau de saída para cada vértice.
    \item \textbf{Circuito Hamiltoniano}: um circuito que visita cada vértice exatamente uma vez, exceto o vértice inicial/final. Determinar a existência de um circuito hamiltoniano é um problema que chamamos de NP-completo. Vamos explicar mais sobre isso na seção de algoritmos e complexidade computacional.
\end{itemize}       

\paragraph{}
Existe um princípio chamado de princípio da casa dos pombos, que diz que se você tem mais pombos do que casas, pelo menos uma casa deve conter mais de um pombo. Em termos de grafos, isso se traduz na ideia de que se um grafo tem mais arestas do que vértices, ele deve conter pelo menos um ciclo.

\paragraph{}
Esse princípio também se aplica a dígrafos, mas com uma nuance importante: em dígrafos, o critério correto para garantir a existência de um circuito dirigido é que o grau mínimo de saída (ou de entrada) seja pelo menos 1. Ou seja, se cada vértice em um dígrafo tem pelo menos um arco saindo dele (ou entrando nele), então o dígrafo deve conter pelo menos um circuito dirigido. Abaixo apresentamos esse resultado formalmente.

\paragraph{}
\begin{lemabox}{Princípio da casa dos pombos para circuitos.}{casa-dos-pombos}
Se \(D=(V,A)\) é um dígrafo finito em que todo vértice tem grau de saída ao menos 1, isto é, \(d^+(v)\ge 1\) para todo \(v\in V\), então \(D\) contém pelo menos um circuito dirigido. (De forma equivalente, a afirmação vale trocando ``saída'' por ``entrada''.)

\paragraph{}
	\textbf{Prova:} Escolha para cada \(v\in V\) um arco \((v,f(v))\) que sai de \(v\) (possível porque \(d^+(v)\ge 1\)). Fixa\-do um vértice \(v_0\), considere a sequência \(v_0, v_1=f(v_0), v_2=f(v_1),\dots\). Como \(V\) é finito, algum vértice repete: existem \(i<j\) com \(v_i=v_j\). O trecho \(v_i\to v_{i+1}\to\cdots\to v_j=v_i\) é um circuito dirigido em \(D\). A versão com graus de entrada segue aplicando o argumento ao dígrafo com arcos invertidos. \hfill$\square$

\paragraph{}
\smallskip
	\textbf{Observação:} A condição \(|A|>|V|\) \emph{não} garante a existência de circuito dirigido em geral (há orientações acíclicas com muitos arcos). O critério correto, simples e útil, é o grau mínimo de saída (ou de entrada) ser pelo menos 1. Ver, por exemplo, \cite{schrijver2003comb}.

\end{lemabox}

\paragraph{}
Esse princípio ajuda a entender o comportamento básico dos métodos que os algoritmos empregam para encontrar as arborescências de custo mínimo. Vamos elaborar melhor esse ponto na seção de algoritmos em arborescências, especialmente ao discutir o algoritmo de Chu--Liu/Edmonds.

\paragraph{}
No algoritmo de Chu--Liu/Edmonds que exploraremos em detalhes em capítulo posterior, para cada vértice \(v\neq r\), escolhemos a aresta de menor custo que entra em \(v\), o subgrafo obtido fica com grau de entrada igual a 1 em todos os \(v\neq r\). Pelo lema, enquanto esse subgrafo ainda não for uma arborescência, ele necessariamente contém um circuito: assim o algoritmo se baseia em detectar o circuitos, contraí-lo a um único vértice e repetir a seleção sob custos reduzidos. Quando não houver mais circuitos, as arestas escolhidas formam uma arborescência ótima enraizada em \(r\).

\paragraph{Componentes fortemente conexas}
\paragraph{}Uma \textbf{componente fortemente conexa} (abreviaremos como \textbf{CFC}) é um subdígrafo maximal onde existe um caminho direcionado (trilha) entre qualquer par de vértices. 

\paragraph{}
Formalmente, uma componente fortemente conexa \(C\) é um subdígrafo \(C = (V_C, A_C)\) onde \(V_C \subseteq V\) e \(A_C \subseteq A\), que satisfaz a seguinte propriedade:
\begin{itemize}
    \item \(C\) é fortemente conexo: existe um caminho direcionado entre qualquer par de vértices em \(V_C\).
\end{itemize}
Além disso, \(C\) é maximal, o que significa que não é possível adicionar mais vértices ou arcos a \(C\) sem perder a propriedade de forte conexidade.
\begin{figure}[H]
\centering
\begin{tikzpicture}[>=Stealth]
    % estilos
    \tikzset{v/.style={circle, draw, fill=blue!10, minimum size=7mm, inner sep=0pt}};
    \tikzset{a/.style={->, semithick, draw=gray!70}};
    \tikzset{comp/.style={draw=blue!40, rounded corners}};
    % Componente C1 (à esquerda)
    \node[v, label=above:$a$] (a) at (0,1.2) {};
    \node[v, label=below:$b$] (b) at (-0.8,0) {};
    \node[v, label=below:$c$] (c) at (0.8,0) {};
    \draw[a] (a) -- (b);
    \draw[a] (b) -- (c);
    \draw[a] (c) -- (a);
    \node[comp, fit=(a)(b)(c), inner sep=20pt, label={[blue!60]above:$C_1$}] {};
    % Componente C2 (centro)
    \node[v, label=below:$d$] (d) at (4,0) {};
    \node[v, label=below:$e$] (e) at (5.6,0) {};
    \draw[a] (d) to[bend left=20] (e);
    \draw[a] (e) to[bend left=20] (d);
    \node[comp, fit=(d)(e), inner sep=15pt, label={[blue!60]above:$C_2$}] {};
    % Componente C3 (direita)
    \node[v, label=above:$f$] (f) at (8.6,1.2) {};
    \node[v, label=below:$g$] (g) at (7.8,0) {};
    \node[v, label=below:$h$] (h) at (9.4,0) {};
    \draw[a] (f) to[bend left=20] (g);
    \draw[a] (g) to[bend left=20] (h);
    \draw[a] (h) to[bend left=20] (f);
    \draw[a] (g) to[bend left=20] (f);
    \draw[a] (h) to[bend left=20] (g);
    \draw[a] (f) to[bend left=20] (h);
    \node[comp, fit=(f)(g)(h), inner sep=20pt, label={[blue!60]above:$C_3$}] {};
    % texto explicativo
    \node[align=center, anchor=north west] at (-0.2,-1.0) {Cada caixa destaca uma \emph{componente fortemente conexa}.\\ Não há arcos entre $C_1$, $C_2$ e $C_3$.};
\end{tikzpicture}
\caption{Componentes fortemente conexas: o dígrafo possui três componentes $C_1$, $C_2$ e $C_3$. Cada $C_i$ é fortemente conexo e \emph{maximal}: adicionar qualquer vértice de fora quebraria a propriedade de forte conexidade interna ou exigiria arcos ausentes.}   
\end{figure}

\paragraph{}
A seguir falaremos sobre a propriedade de alcançabilidade mútua em CFC, que é fundamental para entendermos a relação entre elas e arborescências (que apenas mencionaremos aqui, para aprofundarmos na sessão sobre arborescências e com os grafos acíclicos dirigidos (DAGs))\footnote{Um DAG (Directed Acyclic Graph) é um grafo direcionado que não contém ciclos. Em outras palavras, não é possível começar em um vértice e seguir uma sequência de arcos que retorne ao mesmo vértice. Os DAGs são estruturas fundamentais em muitas áreas da computação, incluindo a representação de dependências e a modelagem de processos.}:

\begin{itemize}
    \item \textbf{CFCs e alcançabilidade mútua:} dois vértices \(u\) e \(v\) pertencem à mesma CFC se, e somente se, \(u\leadsto v\) e \(v\leadsto u\). Ou seja, existe um caminho direcionado de \(u\) para \(v\) e um caminho direcionado de \(v\) para \(u\). A relação de pertencer à mesma CFC é uma relação de equivalência que particiona o conjunto de vértices \(V\) em subconjuntos disjuntos, cada um correspondendo a uma CFC.
    \item \textbf{Arborescências em dígrafos fortemente conexos:} um dígrafo é fortemente conexo se, e somente se, para algum (equiv., para todo) vértice $r$ existem uma \emph{arborescência de saída} enraizada em $r$ que alcança todos os vértices e uma \emph{arborescência de entrada} enraizada em $r$ que é alcançada por todos os vértices. De fato, se $D$ é fortemente conexo, basta rodar buscas a partir de $r$; no sentido inverso, $r\leadsto v$ pela arborescência de saída e $v\leadsto r$ pela de entrada, implicando alcançabilidade mútua entre quaisquer dois vértices via $r$.
    \item \textbf{CFC e DAG.} Ao \emph{contrair} cada CFC a um único vértice obtemos o grafo condensado $\mathrm{Cond}(D)$\footnote{O grafo condensado é uma representação simplificada do dígrafo original, onde as CFCs são representadas como vértices únicos.}. Não há circuitos dirigidos em $\mathrm{Cond}(D)$; portanto, ele é um DAG.
    
    \paragraph{Consequências:}
     todo DAG tem ao menos uma componente-fonte (falaremos em seguida sobre eles) e uma componente-sumidouro; logo, $\mathrm{Cond}(D)$ também tem ao menos uma CFC-fonte e ao menos uma CFC-sumidouro.
\end{itemize}

\paragraph{Componentes-fonte}
\paragraph{}Uma \textbf{componente-fonte} é uma componente fortemente conexa que não possui arcos direcionados saindo dela para outras componentes. Formalmente, uma componente-fonte \(C\) é uma componente fortemente conexa \(C = (V_C, A_C)\) onde \(V_C \subseteq V\) e \(A_C \subseteq A\), que satisfaz a seguinte propriedade:
\begin{itemize}
    \item Não existem arcos \((u, v) \in A\) tais que \(u \in V_C\) e \(v \notin V_C\).
    \item \(C\) é maximal: não é possível adicionar mais vértices ou arcos a \(C\) sem perder a propriedade de forte conexidade.
    \item \(C\) é fortemente conexo: existe um caminho direcionado entre qualquer par de vértices em \(V_C\).
\end{itemize}

\begin{figure}[H]
\centering
\begin{tikzpicture}[>=Stealth]
    % estilos
    \tikzset{v/.style={circle, draw, fill=blue!10, minimum size=7mm, inner sep=0pt}, a/.style={->, semithick, draw=gray!70}, comp/.style={draw=blue!40, rounded corners}};
    % Componente-fonte C1 (à esquerda)
    \node[v, label=above:$a$] (a) at (0,1.2) {};
    \node[v, label=below:$b$] (b) at (-0.8,0) {};
    \node[v, label=below:$c$] (c) at (0.8,0) {};
    \draw[a] (a) -- (b);
    \draw[a] (b) -- (c);
    \draw[a] (c) -- (a);
    \node[comp, fit=(a)(b)(c), inner sep=20pt, label={[blue!60]above:$C_1$}] {};
    % Componente C2 (centro)
    \node[v, label=below:$d$] (d) at (4,0) {};
    \node[v, label=below:$e$] (e) at (5.6,0) {};
    \draw[a] (d) to[bend left=20] (e);
    \draw[a] (e) to[bend left=20] (d);
    \node[comp, fit=(d)(e), inner sep=15pt, label={[blue!60]above:$C_2$}] {};
    % Componente C3 (direita)
    \node[v, label=above:$f$] (f) at (8.6,1.2) {};
    \node[v, label=below:$g$] (g) at (7.8,0) {};
    \node[v, label=below:$h$] (h) at (9.4,0) {};
    \draw[a] (f) to[bend left=20] (g);
    \draw[a] (g) to[bend left=20] (h);
    \draw[a] (h) to[bend left=20] (f);
    \draw[a] (g) to[bend left=20] (f);
    \draw[a] (h) to[bend left=20] (g);
    \draw[a] (f) to[bend left=20] (h);
    \node[comp, fit=(f)(g)(h), inner sep=20pt, label={[blue!60]above:$C_3$}] {};
    % arcos entre componentes
    \draw[a] (c) to[bend left=15] (d);
    \draw[a] (e) to[bend left=15] (f);
    % texto explicativo
    \node[align=center, anchor=north west, text width=15.0cm] at (-1.5,-1.0) {A componente $C_1$ é uma \emph{componente-fonte} porque não há arcos saindo dela para outras componentes. Já $C_2$ e $C_3$ não são componentes-fonte, pois há arcos entrando nelas.};
\end{tikzpicture}
\caption{Componente-fonte: o dígrafo possui três componentes $C_1$, $C_2$ e $C_3$. A componente $C_1$ é uma componente-fonte porque não há arcos saindo dela para outras componentes. Já $C_2$ e $C_3$ não são componentes-fonte, pois há ar  cos entrando nelas.}
\label{fig:componente-fonte}
\end{figure}

\paragraph{Componentes-sumidouro}
\paragraph{}Uma \textbf{componente-sumidouro} é uma componente fortemente conexa que não possui arcos direcionados entrando nela vindos de outras componentes. Formalmente, uma componente-sumidouro \(C\) é uma componente fortemente conexa \(C = (V_C, A_C)\) onde \(V_C \subseteq V\) e \(A_C \subseteq A\), que satisfaz a seguinte propriedade:
\begin{itemize}
    \item Não existem arcos \((u, v) \in A\) tais que \(u \notin V_C\) e \(v \in V_C\).
    \item \(C\) é maximal: não é possível adicionar mais vértices ou arcos a \(C\) sem perder a propriedade de forte conexidade.
    \item \(C\) é fortemente conexo: existe um caminho direcionado entre qualquer par de vértices em \(V_C\).
\end{itemize}

\begin{figure}[H]
\centering
\begin{tikzpicture}[>=Stealth]
    % estilos
    \tikzset{v/.style={circle, draw, fill=blue!10, minimum size=7mm, inner sep=0pt}, a/.style={->, semithick, draw=gray!70}, comp/.style={draw=blue!40, rounded corners}};
    % Componente-fonte C1 (à esquerda)
    \node[v, label=above:$a$] (a) at (0,1.2) {};
    \node[v, label=below:$b$] (b) at (-0.8,0) {};
    \node[v, label=below:$c$] (c) at (0.8,0) {};
    \draw[a] (a) -- (b);
    \draw[a] (b) -- (c);
    \draw[a] (c) -- (a);
    \node[comp, fit=(a)(b)(c), inner sep=20pt, label={[blue!60]above:$C_1$}] {};
    % Componente C2 (centro)
    \node[v, label=below:$d$] (d) at (4,0) {};
    \node[v, label=below:$e$] (e) at (5.6,0) {};
    \draw[a] (d) to[bend left=20] (e);
    \draw[a] (e) to[bend left=20] (d);
    \node[comp, fit=(d)(e), inner sep=15pt, label={[blue!60]above:$C_2$}] {};
    % Componente C3 (direita)
    \node[v, label=above:$f$] (f) at (8.6,1.2) {};
    \node[v, label=below:$g$] (g) at (7.8,0) {};
    \node[v, label=below:$h$] (h) at (9.4,0) {};
    \draw[a] (f) to[bend left=20] (g);
    \draw[a] (g) to[bend left=20] (h);
    \draw[a] (h) to[bend left=20] (f);
    \draw[a] (g) to[bend left=20] (f);
    \draw[a] (h) to[bend left=20] (g);
    \draw[a] (f) to[bend left=20] (h);
    \node[comp, fit=(f)(g)(h), inner sep=15pt, label={[blue!60]above:$C_3$}] {};
    % arcos entre componentes
    \draw[a] (c) to[bend left=15] (d);
    \draw[a] (e) to[bend left=15] (f);
    % texto explicativo
    \node[align=center, anchor=north west, text width=15.0cm] at (-1.5,-1.0) {A componente $C_3$ é uma \emph{componente-sumidouro} porque não há arcos entrando nela vindos de outras componentes. Já $C_1$ e $C_2$ não são componentes-sumidouro, pois há arcos saindo delas.};
\end{tikzpicture}
\caption{Componente-sumidouro: o dígrafo possui três componentes $C_1$, $C_2$ e $C_3$. A componente $C_3$ é uma componente-sumidouro porque não há arcos entrando nela vindos de outras componentes. Já $C_1$ e $C_2$ não são componentes-sumidouro, pois há arcos saindo delas.}
\label{fig:componente-sumidouro}
\end{figure}

\paragraph{}
Existe um resultado clássico que relaciona o número de componentes-fonte e componentes-sumidouro em um dígrafo com o número mínimo de arcos necessários para torná-lo fortemente conexo.

\begin{figure}[H]
\centering
\begin{tikzpicture}[>=Stealth]
    % estilos locais para o condensado
    	\tikzset{
        comp/.style={circle, draw, fill=blue!8, minimum size=7mm, inner sep=0pt},
        src/.style={circle, draw=green!60!black, fill=green!15, minimum size=7mm, inner sep=0pt, very thick},
        sink/.style={circle, draw=red!60!black, fill=red!15, minimum size=7mm, inner sep=0pt, very thick},
        arc/.style={->, semithick, draw=gray!70}
    }
    % nós (CFCs do condensado)
    \node[src, label=below:$C_1$] (c1) at (0,0) {};
    \node[comp, label=below:$C_2$] (c2) at (2.2,0.9) {};
    \node[comp, label=below:$C_3$] (c3) at (2.2,-0.9) {};
    \node[sink, label=below:$C_4$] (c4) at (4.4,0) {};
    % arcos do condensado (DAG)
    \draw[arc] (c1) -- (c2);
    \draw[arc] (c1) -- (c3);
    \draw[arc] (c2) -- (c4);
    \draw[arc] (c3) -- (c4);
    % legendas curtas
    \node[align=left, anchor=west] at (5.1,0.6) {CFC-\textit{fonte}: sem entrada ($C_1$)};
    \node[align=left, anchor=west] at (5.1,-0.1) {CFC-\textit{sumidouro}: sem saída ($C_4$)};
    \node[align=left, anchor=west] at (5.1,-0.8) {$s=1,\; t=1$ neste exemplo};
\end{tikzpicture}
\caption{Grafo condensado $\mathrm{Cond}(D)$ e a contagem de CFCs-fonte/sumidouro: $C_1$ não recebe arcos (fonte) e $C_4$ não emite arcos (sumidouro).}
\label{fig:condensado-st}
\end{figure}

\paragraph{}
Seja $D=(V,A)$ um dígrafo com $k$ componentes fortemente conexas (CFCs): 

\paragraph{}
Denote por $\mathrm{Cond}(D)$ o grafo \emph{condensado}, obtido ao contrair cada CFC de $D$ em um único vértice; $\mathrm{Cond}(D)$ é sempre um DAG. Escreva $s$ para o número de CFCs-\emph{fonte} (vértices de $\mathrm{Cond}(D)$ sem arcos de \emph{entrada}) e $t$ para o número de CFCs-\emph{sumidouro} (vértices de $\mathrm{Cond}(D)$ sem arcos de \emph{saída}). Com essa notação, vale o seguinte:

\paragraph{}
\begin{lemabox}{Mínimo de arcos para conexidade forte}{min-arc}
Se $k=1$, então $D$ já é fortemente conexo e o mínimo de arcos a adicionar é $0$. Se $k\ge 2$, o número mínimo de arcos a adicionar para tornar $D$ fortemente conexo é \[\boxed{\;\min = \max\{s,\,t\}\;}\,.\]

\paragraph{}
	\textbf{Prova (esboço).} 
    \paragraph{}
    \emph{Necessidade:} em qualquer supergrafo fortemente conexo, cada CFC-fonte deve receber ao menos um arco \emph{entrando} e cada CFC-sumidouro deve ter ao menos um arco \emph{saindo}; logo, são necessários ao menos $\max\{s,t\}$ arcos novos. 
    
    \paragraph{}
    \emph{Suficiência:} numa ordenação topológica de $\mathrm{Cond}(D)$, conecte CFCs-sumidouro a CFCs-fonte de modo a formar um ciclo que percorra todas as CFCs. Isso pode ser feito com exatamente $\max\{s,t\}$ arcos, mesmo quando $s\ne t$, emparelhando sobras de um lado com o outro. 
    
    \paragraph{}
    Ver, por exemplo, textos clássicos sobre dígrafos (e.g., \cite{schrijver2003comb}).
\end{lemabox}

\paragraph{}
Esse lema explica por que todo dígrafo com mais de uma CFC-fonte ou mais de uma CFC-sumidouro não pode ser fortemente conexo. Além disso, ele é útil em algoritmos que buscam tornar um dígrafo fortemente conexo, pois fornece um limite inferior para o número de arcos que precisam ser adicionados.

\paragraph{}
As noções de CFCs e componentes-fonte conversam diretamente com o conceito de \emph{arborescências}. Pois, em uma arborescência, todos os vértices são alcançáveis a partir da raiz, o que não implica que a arborescência é fortemente conexa, mas encontrar essas componentes dentro de um dígrafo pode nos ajudar em uma busca otimizada por arborescências.

\paragraph{Arborescências}

\paragraph{}Uma \textbf{arborescência} é um dígrafo acíclico e conexo, onde há um vértice especial chamado \emph{raiz} que tem um caminho direcionado para todos os outros vértices. Formalmente, uma arborescência \(T\) é um dígrafo \(T = (V_T, A_T)\) onde \(V_T \subseteq V\) e \(A_T \subseteq A\), que satisfaz as seguintes propriedades:
\begin{itemize}
    \item \(T\) é conexo: existe um caminho direcionado da raiz para qualquer vértice em \(V_T\).
    \item \(T\) é acíclico: não contém ciclos direcionados.
\end{itemize}
Além disso, uma arborescência com \(n\) vértices sempre tem exatamente \(n-1\) arcos.
\begin{figure}[H]
\centering
\begin{tikzpicture}[>=Stealth]
    % estilos
    \tikzset{v/.style={circle, draw, fill=blue!10, minimum size=7mm, inner sep=0pt}, a/.style={->, semithick, draw=blue!70}, p/.style={->, draw=gray!60}};
    % vértices da arborescência
    \node[v, label=below:$r$] (r) at (0,0) {};
    \node[v, label=above:$a$] (a) at (-1.6,1.4) {};
    \node[v, label=above:$b$] (b) at (0.0,1.8) {};
    \node[v, label=above:$c$] (c) at (1.6,1.4) {};
    \node[v, label=above:$d$] (d) at (-2.4,2.8) {};
    \node[v, label=above:$e$] (e) at (-0.8,3.0) {};
    \node[v, label=above:$f$] (f) at (0.8,3.0) {};
    \node[v, label=above:$g$] (g) at (-4.95,3.0) {};
    \node[v, label=above:$h$] (h) at (-3.50,3.0) {};
    % arcos da arborescência (sem ciclos)                      
    \draw[a] (r) -- (a);
    \draw[a] (r) -- (b);
    \draw[a] (r) -- (c);
    \draw[a] (a) -- (d);
    \draw[a] (b) -- (e);
    \draw[a] (c) -- (f);
    % arco extra (não faz parte da arborescência)
    \draw[p] (e) -- (d);
    \draw[p] (f) -- (r);
    \draw[p] (d) -- (b);
    \draw[p] (a) -- (b);
    \draw[p] (g) -- (h);
    
    \node[align=left, anchor=west] at (3.0,1.8) {$|V_T|=7,\; |A_T|=6$\\ $|A_T|=|V_T|-1$};
\end{tikzpicture}
\caption{Arborescência: dígrafo conexo e acíclico com raiz $r$ de onde há um caminho direcionado para todos os outros vértices em azul. No exemplo, $|V_T|=7$ e $|A_T|=6$, satisfazendo $|A_T|=|V_T|-1$. Em cinza, arcos que não fazem parte da arborescência.}
\label{fig:arborescencia}
\end{figure}

\paragraph{Definições e notação adicionais}
\paragraph{}
Para facilitar a discussão sobre arborescências, introduzimos algumas definições e notações adicionais: seja \(D = (V, A)\) um dígrafo e \(r \in V\) um vértice específico (a raiz). Denotamos por \(d_D^+(v)\) o grau de saída de um vértice \(v\) em \(D\), ou seja, o número de arcos que saem de \(v\). Analogamente, \(d_D^-(v)\) é o grau de entrada de \(v\), o número de arcos que entram em \(v\).


\paragraph{}
As arborescências são o principal objeto de investigação desse trabalho, portanto vamos usar uma sessão dedicada a elas para apresentar suas características, variações e aplicações.

\subsection{Arborescências em foco}

\paragraph{}
Já tratamos do conceito básico de arborescência, agora falaremos de arborescências especiais:

\paragraph{Arborescência Geradora:}
Uma arborescência é considerada geradora se inclui todos os vértices do dígrafo original, ou seja, \(V_T = V\). Nesse caso, a arborescência é formada por um subconjunto dos arcos do dígrafo original.

\paragraph{Arborescência Maximal:}
Uma arborescência é dita maximal se não é possível adicionar mais vértices ou arcos a ela sem perder a propriedade de ser uma arborescência, ou seja, sem criar ciclos ou desconectar o dígrafo.

\paragraph{Ramificações Geradoras}
\paragraph{}Uma \textbf{ramificação geradora} é um subdígrafo que é uma arborescência que inclui todos os vértices do dígrafo original. Formalmente, uma ramificação geradora \(R\) é um subdígrafo \(R = (V_R, A_R)\) onde \(V_R = V\) e \(A_R \subseteq A\), que satisfaz as seguintes propriedades:
\begin{itemize}
    \item \(R\) é uma arborescência: existe um vértice especial chamado raiz que tem um caminho direcionado para todos os outros vértices.
    \item \(R\) é maximal: não é possível adicionar mais arcos a \(R\) sem perder a propriedade de ser uma arborescência.
\end{itemize}

\begin{figure}[H]
\centering
\begin{tikzpicture}[>=Stealth]
    % estilos
    \tikzset{v/.style={circle, draw, fill=blue!10, minimum size=7mm, inner sep=0pt}, a/.style={->, semithick, draw=blue!70}, p/.style={->, draw=gray!60}};
    % vértices da ramificação geradora
    \node[v, label=below:$r$] (r) at (0,0) {};
    \node[v, label=above:$a$] (a) at (-1.6,1.4) {};
    \node[v, label=above:$b$] (b) at (0.0,1.8) {};
    \node[v, label=above:$c$] (c) at (1.6,1.4) {};
    \node[v, label=above:$d$] (d) at (-2.4,2.8) {};
    \node[v, label=above:$e$] (e) at (-0.8,3.0) {};
    \node[v, label=above:$f$] (f) at (0.8,3.0) {};
    \node[v, label=above:$g$] (g) at (-4.95,3.0) {};
    \node[v, label=above:$h$] (h) at (-3.50,3.0) {};
    % arcos da ramificação geradora (sem ciclos)                      
    \draw[a] (r) -- (a);
    \draw[a] (r) -- (b);
    \draw[a] (r) -- (c);
    \draw[a] (a) -- (d);
    \draw[a] (b) -- (e);
    \draw[a] (c) -- (f);
    % arco extra (não faz parte da ramificação geradora)
    \draw[p] (e) -- (d);
    \draw[p] (f) -- (r);
    \draw[p] (d) -- (b);    
    \draw[p] (a) -- (b);
    \draw[p] (g) -- (h);

    \node[align=left, anchor=west] at (3.0,1.8) {$|V_T|=7,\; |A_T|=6$\\ $|A_T|=|V_T|-1$};
\end{tikzpicture}
\caption{Ramificação geradora: arborescência que inclui todos os vértices do dígrafo original, em azul. No exemplo, $|V_T|=7$ e $|A_T|=6$, satisfazendo $|A_T|=|V_T|-1$. Em cinza, arcos que não fazem parte da ramificação geradora.}
\label{fig:ramificacao-geradora}
\end{figure} 

\paragraph{}
Quando falamaos de ramificações geradoras, podemos falar de uma estrutura que fixa um vértice raiz \(r\) e constrói uma arborescência que alcança todos os outros vértices a partir dessa raiz. Essa estrutura é conhecida como \emph{r-arborescência}.

\paragraph{Arborescência de Raiz Específica:}
uma arborescência de raiz específica é uma arborescência onde a raiz é um vértice pré-determinado do dígrafo. Isso é útil em situações onde um ponto de origem específico deve ser o início dos caminhos direcionados para todos os outros vértices. Podemos chamá-la de r-arborescência, onde \(r\) é o vértice raiz.

\paragraph{}
Em uma arborescência \(T = (V_T, A_T)\) enraizada em \(r\), temos as seguintes propriedades:
\begin{itemize}
    \item A raiz \(r\) tem grau de entrada zero: \(d_T^-(r) = 0\).
    \item Todo outro vértice \(v \in V_T \setminus \{r\}\) tem grau de entrada exatamente um: \(d_T^-(v) = 1\). Isso significa que há exatamente um arco direcionado entrando em cada vértice, exceto na raiz.
    \item O grau de saída \(d_T^+(v)\) pode variar, mas para garantir que \(T\) seja conexo, deve haver pelo menos um arco saindo de \(r\) para alcançar os outros vértices.
\end{itemize}

\paragraph{Arborescência inversa (in-arborescência):}
uma \emph{arborescência inversa} enraizada em \(r\) — também chamada de \emph{in-arborescência} — é o resultado de inverter a orientação de todos os arcos de uma arborescência (out-arborescência) enraizada em \(r\). Equivalentemente: é um dígrafo acíclico no qual, para todo \(v\neq r\), existe \emph{exatamente um} caminho direcionado de \(v\) até \(r\) (isto é, todos os arcos estão orientados \emph{em direção} à raiz). Em termos de graus, numa in-arborescência cada vértice \(v\neq r\) tem grau de saída igual a 1 (o arco para seu “pai”) e a raiz \(r\) tem grau de saída 0; os graus de entrada são complementares aos de uma out-arborescência.

\paragraph{}
As arborecências podem ter custos associados aos seus arcos, o que nos leva ao conceito de arborescência de custo mínimo.

\paragraph{Arborescência de Custo Mínimo:}
\paragraph{}
Uma \textbf{arborescência de custo mínimo} é uma arborescência que minimiza a soma dos pesos dos arcos que a compõem. Esse conceito é especialmente relevante em aplicações onde os arcos têm custos associados, como em redes de transporte ou comunicação.

\paragraph{}
Finalmente podemos conceituar a principal estrutura que estudaremos nesta dissertação: a r-arborescência de custo mínimo e sua variante, a r-arborescência inversa de custo mínimo.

\paragraph{r-arborescência de custo mínimo:}
é uma arborescência enraizada em um vértice específico \(r\) que minimiza a soma dos pesos dos arcos que a compõem. Formalmente, dada uma função de custo \(c: A \to \mathbb{R}_{\geq 0}\) que atribui um custo a cada arco do dígrafo \(D = (V, A)\), uma r-arborescência de custo mínimo \(T\) é uma arborescência \(T = (V_T, A_T)\) onde \(V_T \subseteq V\) e \(A_T \subseteq A\), que satisfaz as seguintes propriedades:
\begin{itemize}
    \item \(T\) é uma arborescência enraizada em \(r\): existe um caminho direcionado de \(r\) para qualquer vértice em \(V_T\).
    \item \(T\) minimiza o custo total: a soma dos custos dos arcos em \(A_T\) é mínima, ou seja, \(\sum_{a \in A_T} c(a)\) é minimizada.
\end{itemize}
\begin{figure}[H]
\centering
\begin{tikzpicture}[>=Stealth]
    % estilos
    \tikzset{v/.style={circle, draw, fill=blue!10, minimum size=7mm, inner sep=0pt}, a/.style={->, semithick, draw=blue!70}, p/.style={->, draw=gray!60}};
    % vértices da r-arborescência de custo mínimo
    \node[v, label=below:$r$] (r) at (0,0) {};
    \node[v, label=above:$a$] (a) at (-1.6,1.4) {};
    \node[v, label=above:$b$] (b) at (0.0,1.8) {};
    \node[v, label=above:$c$] (c) at (1.6,1.4) {};
    \node[v, label=above:$d$] (d) at (-2.4,2.8) {};
    \node[v, label=above:$e$] (e) at (-0.8,3.0) {};
    \node[v, label=above:$f$] (f) at (0.8,3.0) {};
    % arcos da r-arborescência de custo mínimo (sem ciclos)                      
    \draw[a] (r) -- (a) node[midway, left] {2};
    \draw[a] (r) -- (b) node[midway, right] {3};
    \draw[a] (r) -- (c) node[midway, right] {1};
    \draw[a] (a) -- (d) node[midway, left] {4};
    \draw[a] (b) -- (e) node[midway, right] {2};
    \draw[a] (c) -- (f) node[midway, right] {5};
    % arco extra (não faz parte da r-arborescência de custo mínimo)
    \draw[p] (e) -- (d) node[midway, left] {6};
    \draw[p] (f) -- (r) node[midway, right] {7};
    \draw[p] (d) -- (b) node[midway, right] {8};    
    \draw[p] (a) -- (b) node[midway, right] {3};
    % custo total
    \node[align=left, anchor=west] at (-3.0,-1.5) {Custo total da r-arborescência: $2 + 3 + 1 + 4 + 2 + 5 = 17$};
\end{tikzpicture}
\caption{r-arborescência de custo mínimo: arborescência enraizada em $r$ que minimiza a soma dos custos dos arcos, em azul. No exemplo, o custo total é $17$. Em cinza, arcos que não fazem parte da r-arborescência de custo mínimo.}
\label{fig:r-arborescencia-custo-minimo}
\end{figure}

\paragraph{r-arborescência inversa de custo mínimo:}
é uma arborescência inversa enraizada em um vértice específico \(r\) que minimiza a soma dos pesos dos arcos que a compõem. Formalmente, dada uma função de custo \(c: A \to \mathbb{R}_{\geq 0}\) que atribui um custo a cada arco do dígrafo \(D = (V, A)\), uma r-arborescência inversa de custo mínimo \(T\) é uma arborescência inversa \(T = (V_T, A_T)\) onde \(V_T \subseteq V\) e \(A_T \subseteq A\), que satisfaz as seguintes propriedades:
\begin{itemize}
    \item \(T\) é uma arborescência inversa enraizada em \(r\): existe um caminho direcionado de qualquer vértice em \(V_T\) até \(r\).
    \item \(T\) minimiza o custo total: a soma dos custos dos arcos em \(A_T\) é mínima, ou seja, \(\sum_{a \in A_T} c(a)\) é minimizada.
\end{itemize}

\paragraph{}
\begin{figure}[H]
\centering
\begin{tikzpicture}[>=Stealth]
    % estilos
    \tikzset{v/.style={circle, draw, fill=blue!10, minimum size=7mm, inner sep=0pt}, a/.style={->, semithick, draw=blue!70}, p/.style={->, draw=gray!60}};
    % vértices da r-arborescência inversa de custo mínimo
    \node[v, label=below:$r$] (r) at (0,0) {};
    \node[v, label=above:$a$] (a) at (-1.6,1.4) {};
    \node[v, label=above:$b$] (b) at (0.0,1.8) {};
    \node[v, label=above:$c$] (c) at (1.6,1.4) {};
    \node[v, label=above:$d$] (d) at (-2.4,2.8) {};
    \node[v, label=above:$e$] (e) at (-0.8,3.0) {};
    \node[v, label=above:$f$] (f) at (0.8,3.0) {};
    % arcos da r-arborescência inversa de custo mínimo (sem ciclos)                      
    \draw[a] (a) -- (r) node[midway, left] {2};
    \draw[a] (b) -- (r) node[midway, right] {3};
    \draw[a] (c) -- (r) node[midway, right] {1};
    \draw[a] (d) -- (a) node[midway, left] {4};
    \draw[a] (e) -- (b) node[midway, right] {2};
    \draw[a] (f) -- (c) node[midway, right] {5};
    % arco extra (não faz parte da r-arborescência inversa de custo mínimo)
    \draw[p] (d) -- (e) node[midway, left] {6};
    \draw[p] (r) -- (f) node[midway, right] {7};
    \draw[p] (b) -- (d) node[midway, right] {8};    
    \draw[p] (b) -- (a) node[midway, right] {3};
    % custo total
    \node[align=left, anchor=west] at (-3.0,-1.5) {Custo total da r-arborescência inversa: $2 + 3 + 1 + 4 + 2 + 5 = 17$};
\end{tikzpicture}
\caption{r-arborescência inversa de custo mínimo: arborescência inversa enraizada em $r$ que minimiza a soma dos custos dos arcos, em azul. No exemplo, o custo total é $17$. Em cinza, arcos que não fazem parte da r-arborescência inversa de custo mínimo.}
\label{fig:r-arborescencia-inversa-custo-minimo}
\end{figure}

\paragraph{}
As arborescências são a principal estrutura que exploraremos ao longo desta dissertação, especialmente a r-arborescência de custo mínimo e r-arborescência inversa de custo mínimo, abordaremos o problema de encontrá-las eficientemente em dígrafos com custos associados aos arcos.



\paragraph{Noções aprofundadas em arborescências}

\paragraph{}
Vamos explorar algumas propriedades e teoremas importantes relacionados a arborescências, que serão úteis para entender os algoritmos que discutiremos posteriormente.

\paragraph{Grau e contagem de arcos:}
\paragraph{}
Seja $T$ uma out-arborescência enraizada em $r$ com $n$ vértices. Ela é exatamente a estrutura que satisfaz as três condições combinadas abaixo (todas muito fáceis de checar):
\begin{enumerate}\setlength{\itemsep}{2pt}
    \item (Contagem) $|A_T| = n-1$.
    \item (Entrada única) Cada vértice $v\neq r$ recebe exatamente um arco: $d_T^-(v)=1$.
    \item (Raiz sem entrada) A raiz não recebe arcos: $d_T^-(r)=0$.
\end{enumerate}
De forma simétrica, numa in-arborescência (arborescência inversa) valem as versões “espelhadas”: cada $v\neq r$ tem exatamente um arco \emph{saindo} ($d_T^+(v)=1$) e a raiz tem grau de saída zero ($d_T^+(r)=0$).

\paragraph{}
Reciprocamente, qualquer subdígrafo que satisfaça (1)--(3) é uma out-arborescência enraizada em $r$ (e análogamente no caso inverso). 

\paragraph{Discussões importantes sobre arborescências}

\paragraph{}
Dado um Dígrafo \(D = (V, A)\) e um vértice raiz \(r \in V\), uma questão fundamental é determinar quando existe uma arborescência enraizada em \(r\).
Existem alguns resultados clássicos que caracterizam a existência de arborescências em dígrafos, bem como condições para a existência de múltiplas arborescências disjuntas. Vamos apresentar dois teoremas fundamentais nesse contexto.

\paragraph{Teorema de Fulkerson}

\paragraph{}
Existem várias formas de caracterizar a existência de arborescências em um dígrafo. Uma delas é via a condição de cortes, que estabelece uma relação entre a existência de arborescências e a estrutura dos cortes no dígrafo.

\paragraph{}
Esse resultado é conhecido como o \textbf{Teorema de Fulkerson} e para entendermos ele precisamos ter em mente as seguintes definições:

\begin{itemize}
    \item Seja \(D = (V, A)\) um dígrafo e \(X \subseteq V\) um subconjunto de vértices. O conjunto \(\delta^-(X)\) é definido como o conjunto de todos os arcos que entram em \(X\) vindos de \(V \setminus X\). Formalmente,
    \[
    \delta^-(X) = \{(u, v) \in A : u \in V \setminus X, v \in X\}.
    \]
    \item Um corte em um dígrafo é uma partição dos vértices em dois subconjuntos disjuntos. O conjunto \(\delta^-(X)\) representa o corte que separa \(X\) do resto do grafo.
\end{itemize}

\paragraph{}
A seguir apresentamos o teorema propriamente dito e um esboço de sua prova.

\paragraph{}
\begin{teobox}{Condição de existência via cortes (Fulkerson)}{fulkerson-existencia}
Seja $D=(V,A)$ e $r\in V$. Existe uma out-arborescência (arborescência dirigida) enraizada em $r$ se, e somente se,
\[
\forall\, X\subseteq V\setminus\{r\},\ X\neq\emptyset:\  \delta^-(X)\neq\emptyset.
\]
Isto é: todo subconjunto não vazio que não contém a raiz recebe ao menos um arco vindo de fora.

\paragraph{}
	\textbf{Prova (esboço):} 

\paragraph{}
\emph{(Só se:)} Suponha que $T$ é uma out-arborescência enraizada em $r$. Pegue qualquer $X\neq\emptyset$ sem $r$. Considere o primeiro vértice de $X$ alcançado a partir de $r$ no caminho dentro de $T$; o arco imediatamente anterior entra em $X$ e pertence a $\delta^-(X)$. Logo $\delta^-(X)\neq\emptyset$.

\paragraph{}
\emph{(Se:)} Agora suponha que toda parte $X$ não vazia sem $r$ recebe um arco. Construímos $T$ iterativamente: comece com $S=\{r\}$. Enquanto $S\neq V$, tome um vértice $v\in V\setminus S$ tal que existe um arco $(u,v)$ com $u\in S$ (existe porque, caso contrário, o conjunto $X=V\setminus S$ não receberia arco). Adicione $v$ e o arco $(u,v)$. Não criamos ciclos porque cada novo vértice entra com exatamente um arco e só aponta para frente (a direção é de um vértice já inserido para um novo). Ao final, cada $v\neq r$ tem exatamente um arco de entrada e o grafo é conexo a partir de $r$, logo obtivemos uma out-arborescência.

\medskip
	\textbf{Intuição curta.} A condição “todo $X$ tem um arco entrando” impede que qualquer bloco de vértices fique isolado da raiz; o processo guloso de anexar o primeiro arco que entra em cada bloco produz a arborescência sem retrocessos.

\medskip
\emph{Referência:} ver, por exemplo, \cite{schrijver2003comb}.
\label{thm:fulkerson-cut-arborescencia}
\end{teobox}

\paragraph{}
Outro resultado clássico é o teorema que caracteriza a existência de múltiplas arborescências arcodisjuntas em um dígrafo, conhecido como o \textbf{Teorema de Edmonds}. Precisamos de algumas definições antes de enunciá-lo:

\begin{itemize}
    \item Duas arborescências são ditas \emph{arcodisjuntas} se não compartilham nenhum arco, ou seja, \(A_{T_1} \cap A_{T_2} = \emptyset\).
    \item A condição de cortes para múltiplas arborescências estabelece que, para qualquer subconjunto \(X \subseteq V \setminus \{r\}\), o número de arcos que entram em \(X\) deve ser pelo menos igual ao número de arborescências desejadas.
    \item Uma out-arborescência enraizada em \(r\) é uma arborescência onde todos os caminhos direcionados partem de \(r\) e alcançam todos os outros vértices.
    \item O conjunto \(\delta^-(X)\) é definido como o conjunto de todos os arcos que entram em \(X\) vindos de \(V \setminus X\). Formalmente,
    \[
    \delta^-(X) = \{(u, v) \in A : u \in V \setminus X, v \in X\}.
    \]
    \item Um corte em um dígrafo é uma partição dos vértices em dois subconjuntos disjuntos. O conjunto \(\delta^-(X)\) representa o corte que separa \(X\) do resto do grafo.
    \end{itemize}

\paragraph{}
Antes de enunciar o teorema, vale a pena mencionar o conceito de \emph{interseção de matroides}, mas, para não alongar demais, deixamos a explicação detalhada para o Apêndice \ref{ap:matroides}. Aqui, apenas uma breve introdução:
\begin{itemize}
    \item Matroides, são estruturas combinatórias que generalizam a noção de independência linear em álgebra linear. A interseção de matroides é um conceito que permite combinar duas ou mais estruturas de matroides para formar uma nova estrutura que mantém certas propriedades de independência.
    \item A interseção de matroides é frequentemente utilizada em problemas de otimização combinatória, onde é necessário encontrar soluções que satisfaçam múltiplas condições de independência simultaneamente.
    \item Familia de conjuntos independentes: cada matroide é definido por uma coleção de subconjuntos de um conjunto finito, chamados de conjuntos independentes, que satisfazem certas propriedades.
    \item No contexto de arborescências, a interseção de matroides pode ser usada para modelar a seleção de arcos que formam múltiplas arborescências arcodisjuntas, garantindo que cada arborescência mantenha suas propriedades de independência.
\end{itemize}

\paragraph{}
\begin{figure}[H]
\centering
\begin{tikzpicture}[>=Stealth]
    % estilos
    \tikzset{v/.style={circle, draw, fill=blue!10, minimum size=7mm, inner sep=0pt}, a/.style={->, semithick, draw=blue!70}, p/.style={->, draw=gray!60}};
    % vértices do dígrafo
    \node[v, label=below:$r$] (r) at (0,0) {};
    \node[v, label=above:$a$] (a) at (-1.6,1.4) {};
    \node[v, label=above:$b$] (b) at (0.0,1.8) {};
    \node[v, label=above:$c$] (c) at (1.6,1.4) {};
    \node[v, label=above:$d$] (d) at (-2.4,2.8) {};
    \node[v, label=above:$e$] (e) at (-0.8,3.0) {};
    \node[v, label=above:$f$] (f) at (0.8,3.0) {};
    % arcos do dígrafo                      
    \draw[a] (r) -- (a);
    \draw[a] (r) -- (b);
    \draw[a] (r) -- (c);
    \draw[a] (a) -- (d);
    \draw[a] (b) -- (e);
    \draw[a] (c) -- (f);
    \draw[a] (e) -- (d);
    \draw[a] (f) -- (r);
    \draw[a] (d) -- (b);    
    \draw[a] (a) -- (b);
    % arcos extras (não fazem parte das arborescências)
    \draw[p] (e) -- (f);
    \draw[p] (f) -- (e);
    \draw[p] (d) -- (c);    
    \draw[p] (c) -- (d);
    \draw[p] (g) -- (h);
    \draw[p] (h) -- (g);
\end{tikzpicture}
\caption{Dígrafo de exemplo para múltiplas arborescências arcodisjuntas.}
\label{fig:exemplo-multiplas-arborescencias}
\end{figure}

\paragraph{}
Agora podemos enunciar o teorema de Edmonds, que fornece uma condição necessária e suficiente para a existência de \(k\) arborescências arcodisjuntas enraizadas em um vértice \(r\).

\paragraph{}
\begin{teobox}{$k$ arborescências arcodisjuntas (Edmonds)}{edmonds-k-arborescencias}
Seja $D=(V,A)$, $r\in V$ e $k\ge 1$ inteiro. São equivalentes:
\begin{enumerate}\setlength{\itemsep}{4pt}
    \item Existem $k$ out-arborescências enraizadas em $r$ que são par a par \emph{arcodisjuntas}.
    \item (Condição de cortes) Para todo subconjunto $X\subseteq V\setminus\{r\}$ vale $|\delta^-(X)| \ge k$.
\end{enumerate}
Em palavras: cada “bloco” $X$ que não contém a raiz precisa ter pelo menos $k$ arcos distintos chegando de fora; isso é exatamente o que permite "alimentar" $X$ a partir de $r$ em $k$ estruturas de ramificação independentes.

\paragraph{}
\textbf{Prova (esboço):}
\emph{(1 $\Rightarrow$ 2)} Se temos $k$ out-arborescências arcodisjuntas, então cada arborescência deve entrar em qualquer $X$ (senão não alcançaria seus vértices). Como os arcos são distintos entre as $k$ estruturas, precisamos de pelo menos $k$ arcos entrando em $X$; logo $|\delta^-(X)|\ge k$.

\paragraph{}
\emph{(2 $\Rightarrow$ 1)} Trata-se a construção como um problema de \emph{interseção de matroides} ou aplicamos um procedimento incremental de troca ("augmenting"). O conjunto de arcos pode suportar no máximo $k(n-1)$ arcos selecionados se quisermos $k$ arborescências, onde cada vértice $v \neq r$ recebe exatamente $k$ arcos de entrada (um de cada arborescência). A condição de cortes impede gargalos: se algum subconjunto $X$ tivesse menos que $k$ arcos entrando, seria impossível abastecer seus vértices com $k$ escolhas independentes.

\paragraph{}
Uma prova clássica (Edmonds) formula o problema como interseção de duas famílias independentes: 

\paragraph{}
(i) uma família que limita a quantidade de arcos entrando em cada vértice a no máximo $k$; 

\paragraph{}
(ii) uma família que evita a criação de ciclos dirigidos ao selecionar arcos (estrutura de matroide de partição + matroide gráfico orientado). 

\paragraph{}
A hipótese de cortes garante que o algoritmo de aumento (que tenta adicionar um arco e, se criar ciclo ou saturar um vértice, realiza trocas) nunca fica travado antes de atingir $k(n-1)$ arcos. Agrupando, particionamos esses $k(n-1)$ arcos em $k$ coleções de $(n-1)$ arcos cada, que formam as $k$ out-arborescências arcodisjuntas.

\medskip
\emph{Referências:} Edmonds (teorema das branchings) \cite{edmonds1967optimum}, apresentações modernas em \cite{schrijver2003comb}.
\label{thm:edmonds-disjoint-arborescencias} 
\end{teobox}

\paragraph{}
Teoremas como esses servem para responder perguntas do tipo “quando existe?” e “quão rica pode ser a estrutura?”. Em particular, eles nos dizem que:
\begin{itemize}\setlength{\itemsep}{2pt}
    \item A existência de uma arborescência enraizada em \(r\) é garantida se, e somente se, todo subconjunto não vazio que não contém \(r\) recebe pelo menos um arco vindo de fora (Teorema de Fulkerson).
    \item A existência de \(k\) arborescências arcodisjuntas enraizadas em \(r\) é garantida se, e somente se, todo subconjunto não vazio que não contém \(r\) recebe pelo menos \(k\) arcos vindos de fora (Teorema de Edmonds).
\end{itemize}

\paragraph{}
Mas, agora estamos interessados em achar essas arborescências de forma eficiente, especialmente quando os arcos têm custos associados. Queremos encontrar a r-arborescência de custo mínimo, ou seja, a arborescência enraizada em \(r\) que minimiza a soma dos custos dos arcos que a compõem.

\paragraph{}
Um resultado central agora é a caracterização de \emph{optimalidade} para r-arborescências de custo mínimo: as chamadas \emph{condições de Fulkerson}. Elas conectam a solução primal (os arcos escolhidos) a um certificado dual (potenciais em subconjuntos) via custos reduzidos.

\paragraph{Terminologia:} 
\paragraph{}
Para um dígrafo $D=(V,A)$, raiz $r$ e custos $c:A\to \mathbb{R}_{\ge 0}$, um subconjunto não vazio $X\subseteq V\setminus\{r\}$ é dito \textbf{apertado} (para uma família de pesos $y$) se exatamente um arco da solução escolhida entra em $X$ e $y(X)>0$. 

\paragraph{}
Diremos que um arco $a=(u,v)$ \emph{entra} em $X$ se $u\notin X$ e $v\in X$. 

\paragraph{}
Dada uma família de pesos $y: \{X\subseteq V\setminus\{r\}: X\neq\emptyset\}\to \mathbb{R}_{\ge 0}$, definimos o \textbf{custo reduzido} de $a$ por
\[
 c'(a) \;=\; c(a)\; - \sum_{\substack{X\subseteq V\setminus\{r\},\\ X\neq\emptyset,\ u\notin X,\ v\in X}} y(X).
\]

\paragraph{}
\begin{teobox}{Optimalidade de Fulkerson (r-arborescência de custo mínimo)}{fulkerson-opt}
Seja $D=(V,A)$, raiz $r$ e custos $c:A\to\mathbb{R}_{\ge 0}$. Seja $T$ uma out-arborescência enraizada em $r$. As afirmações são equivalentes: 
\begin{enumerate}\setlength{\itemsep}{4pt}
    \item $T$ tem custo mínimo entre todas as out-arborescências enraizadas em $r$.
    \item Existem pesos $y(X)\ge 0$ para cada $\emptyset\neq X\subseteq V\setminus\{r\}$ tais que:
    \begin{enumerate}\setlength{\itemsep}{2pt}
         \item[(a)] $c'(a)\ge 0$ para todo arco $a\in A$ (não negatividade dos custos reduzidos);
         \item[(b)] $c'(a)=0$ para todo arco $a\in T$ (complementaridade em arcos usados);
         \item[(c)] Para todo $X$ com $y(X)>0$ entra \emph{exatamente um} arco de $T$ em $X$ (complementaridade em conjuntos apertados).
    \end{enumerate}
\end{enumerate}
Além disso, quando (2) vale, o valor $\sum_X y(X)$ é exatamente o custo de $T$.

\paragraph{}
	\textbf{Prova (esboço):}

\paragraph{(2 $\Rightarrow$ 1).} Para qualquer arborescência $B$ temos
\[
 	\textbf{custo}(B) = \sum_{a\in B} c(a) = \sum_{a\in B} \Big( c'(a) + \sum_{X: a\text{ entra }X} y(X) \Big).
\]
Trocando a ordem da soma:
\[
 	\textbf{custo}(B) = \sum_{a\in B} c'(a) + \sum_X y(X)\,\big| \{a\in B: a \text{ entra } X\}\big|.
\]
Pelas condições, $c'(a)\ge 0$, logo a primeira soma é $\ge 0$. Como uma out-arborescência entra em qualquer $X\neq\emptyset$ (senão $X$ estaria desconectado de $r$), temos $|\{a\in B: a \text{ entra } X\}|\ge 1$. Assim
\[
 	\textbf{custo}(B) \ge \sum_X y(X).
\]
Para $B=T$, pela complementaridade $c'(a)=0$ se $a\in T$ e para cada $X$ com $y(X)>0$ entra \emph{exatamente} um arco de $T$, obtendo
\[
 	\textbf{custo}(T) = 0 + \sum_X y(X),
\]
logo $\textbf{custo}(T) \le \textbf{custo}(B)$ para qualquer $B$; $T$ é ótimo.

\paragraph{(1 $\Rightarrow$ 2).} (Ideia) Execute o procedimento clássico: enquanto houver vértice (ou componente contraída) $v\neq r$ sem arco de custo reduzido zero entrando, subtraia do custo de todos os arcos que entram em $v$ o menor custo positivo entre eles (isso equivale a aumentar uniformemente $y(X)$ para cada subconjunto $X$ cujo primeiro arco zero estamos “criando”). Quando um ciclo de arcos de custo reduzido zero surge, contraia-o e continue no dígrafo comprimido. Ao final, os arcos de custo reduzido zero selecionados formam $T$. As quantidades subtraídas definem $y$: cada vez que subtraímos $\alpha>0$ para um subconjunto/componente $X$, somamos $\alpha$ a $y(X)$. Construção garante (a)–(c).

\paragraph{Intuição.} Os pesos $y$ “pagam” parcialmente cada arco de fora para dentro dos subconjuntos; arcos da solução ficam exatamente “quitados” (custo reduzido 0). Se algum arco restante tivesse custo reduzido negativo, poderíamos baixar o custo da solução trocando-o por um arco de $T$, contradizendo optimalidade. Conjuntos com $y(X)>0$ exigem uso único de um arco para não desperdiçar potencial.

\medskip
\emph{Referências:} Fulkerson (condições de optimalidade), apresentações modernas em \cite{frank2014, schrijver2003comb}.
\label{thm:fulkerson-optimalidade-arborescencia}
\end{teobox}

\paragraph{}
O teorema anterior nos diz como reconhecer, de forma concreta, que a arborescência encontrada é realmente de custo mínimo. Fazemos uma normalização simples de custos\footnote{Por “normalização de custos” entendemos subtrair a mesma constante de todos os arcos que entram em um mesmo subconjunto (ou componente) do grafo, para simplificar os valores e criar arcos de custo reduzido zero, sem alterar qual solução é ótima; em outras palavras, trabalhar com custos reduzidos.}: para cada “parte” do grafo, subtraímos, dos arcos que entram nessa parte, o menor custo observado; com isso, pelo menos um arco que entra em cada parte zera. A solução ótima pode ser construída usando apenas arcos com custo reduzido zero e, sob esse ajuste, não sobra nenhuma troca que diminua o custo.

\paragraph{}
Na prática, a verificação de optimalidade se reduz a checar condições locais:
\begin{itemize}\setlength{\itemsep}{2pt}
    \item não há arcos com custo reduzido negativo;
    \item todo arco que compõe a arborescência tem custo reduzido zero;
    \item para cada conjunto “apertado” (isto é, que recebeu desconto positivo no ajuste), entra exatamente um arco da arborescência.
\end{itemize}
Se alguma dessas condições falhar, existe uma troca que barateia a solução; se todas forem satisfeitas, temos um certificado de optimalidade curto e fácil de verificar.

\paragraph{}
Com essa ideia em mãos, saímos do “o que é ótimo?” para “como chegar lá, passo a passo?”. No próximo capítulo apresentamos a noção de algoritmo que adotaremos e descrevemos os métodos clássicos para este problema: o algoritmo de Chu–Liu/Edmonds (que cria arcos de custo zero e contrai ciclos) e o procedimento em duas fases de András Frank. Veremos as etapas, a intuição por trás e como vamos implementá-los no projeto.

\subsection{Algoritmos}
\paragraph{}
Quando falamos em passo a passo é muito comum vir à mente a ideia de receitas de cozinha, instruções de montagem ou manuais de operação. Em ciência da computação, o termo \emph{algoritmo} captura essa ideia de forma mais formal e precisa.

\paragraph{}O primeiro uso documentado do termo “algoritmo” em inglês data de 1230, em uma tradução latina do trabalho de Al-Khwarizmi. No entanto, o conceito de algoritmos é muito mais antigo, remontando a procedimentos matemáticos e lógicos desenvolvidos ao longo dos séculos.

\paragraph{}
Um dos primeiros algoritmos conhecidos é o \emph{método de Euclides} para encontrar o máximo divisor comum (mdc) de dois números inteiros, descrito por Euclides em sua obra "Os Elementos" por volta de 300 a.C. 

\paragraph{}
\begin{algobox}{Método de Euclides (mdc)}{mdc}
Dados inteiros positivos $a$ e $b$:
\begin{enumerate}\setlength{\itemsep}{2pt}
    \item enquanto $b>0$, substitua $(a,b)$ por $(b, a\bmod b)$;
    \item quando $b=0$, devolva $a$.
\end{enumerate}
\end{algobox}

\paragraph{}
Mas, o que diferencia uma mera receita de um algoritmo? A resposta está na clareza, precisão e capacidade de execução repetitiva das instruções. Um algoritmo deve ser:
\begin{itemize}\setlength{\itemsep}{2pt}
    \item \textbf{Não ambiguidade}: cada passo deve ser definido de maneira inequívoca, sem ambiguidade.
    \item \textbf{Especificidade}: as instruções devem ser detalhadas o suficiente para que possam ser seguidas sem interpretação subjetiva.
    \item \textbf{Executabilidade}: deve ser possível executar o algoritmo de forma sistemática, sem necessidade de criatividade ou intuição.
\end{itemize}

\paragraph{}
Por isso, que chamamos o método de Euclides de algoritmo: os passos são não ambíguos; termina porque a segunda coordenada diminui até zerar; é correto pois mantém o invariante $\gcd(a,b)=\gcd(b,a\bmod b)$; e o custo é baixo (proporcional ao número de dígitos de $a$ e $b$).

\paragraph{}
Além dessas características, precisamos citar mais alguns conceitos úteis na análise de algoritmos:
\begin{itemize}\setlength{\itemsep}{2pt}
    \item \textbf{Invariante}: uma propriedade que permanece verdadeira durante a execução do algoritmo. Por exemplo, em um algoritmo de ordenação, um invariante pode ser que os elementos à esquerda de um índice específico estão sempre ordenados. (ex.: “não há custos reduzidos negativos” ou “cada componente tem ao menos um arco zero entrando”).
    \item \textbf{Correção}: a garantia de que o algoritmo produz a saída correta para todas as entradas válidas. Isso geralmente é demonstrado por meio de provas formais ou argumentos lógicos. (ex.: justificativa de que o resultado final é uma arborescência válida e de custo mínimo)
    \item \textbf{Terminação}: a garantia de que o algoritmo sempre chegará a um ponto final, ou seja, que não entrará em um loop infinito. Isso pode ser demonstrado mostrando que alguma medida (como o tamanho da entrada) diminui a cada passo. (ex.: cada contração reduz $|V|$; cada ajuste cria um novo arco zero).
\end{itemize}

\paragraph{}
Essas características não definem formalmente o que é um algoritmo, mas ajudam a entender o conceito. A definição formal envolve a ideia de \emph{computabilidade}\footnote{A computabilidade é um conceito na teoria da computação, que se refere à capacidade de um problema ser resolvido por um algoritmo em um tempo finito. \emph{Comentário formal.} Esse conceito é formalizado por meio de modelos como máquinas de Turing, funções recursivas, RAM, entre outros. Essas formalizações são equivalentes quanto ao que é computável (Tese de Church–Turing) e permitem discutir com rigor correção e complexidade (tempo e memória).}, e isso envolve uma discussão profunda demais para o escopo deste trabalho.

\subsubsection{Complexidade de Algoritmos}

\paragraph{}
Porém, precisamos nos aprofunda em um dos conceitos que estão envolvidos em computabilidade: o de \emph{complexidade de algoritmos}, que se refere à quantidade de recursos computacionais (tempo e espaço) que um algoritmo consome em função do tamanho da entrada.

\paragraph{}
A complexidade de um algoritmo pode ser analisada em termos de \emph{complexidade de tempo} e \emph{complexidade de espaço}. A complexidade de tempo refere-se ao tempo que um algoritmo leva para ser executado, enquanto a complexidade de espaço refere-se à quantidade de memória que um algoritmo utiliza durante sua execução.

\paragraph{}
A notação assintótica é frequentemente usada para expressar a complexidade de algoritmos, permitindo descrever o comportamento do algoritmo à medida que o tamanho da entrada cresce. As notações mais comuns são:
\begin{itemize}\setlength{\itemsep}{2pt}
    \item \textbf{O grande (Big O)}: descreve um limite superior para o crescimento da função. Por exemplo, se um algoritmo tem complexidade \(O(n^2)\), isso significa que o tempo de execução do algoritmo cresce no máximo proporcional a \(n^2\) para entradas grandes.
    \item \textbf{Ômega (\(\Omega\))}: descreve um limite inferior para o crescimento da função. Se um algoritmo tem complexidade \(\Omega(n)\), isso significa que o tempo de execução do algoritmo cresce no mínimo proporcional a \(n\) para entradas grandes.
    \item \textbf{Theta (\(\Theta\))}: descreve um limite assintótico preciso, indicando que a função cresce exatamente proporcional a uma determinada função. Se um algoritmo tem complexidade \(\Theta(n \log n)\), isso significa que o tempo de execução do algoritmo cresce proporcional a \(n \log n\) para entradas grandes.
\end{itemize}

\paragraph{}
Essas notações ajudam a comparar a eficiência de diferentes algoritmos e a entender como eles se comportam à medida que o tamanho da entrada aumenta\footnote{Por “tamanho da entrada” entendemos a quantidade de símbolos necessária para codificar a instância (tipicamente, o número de bits). Exemplos: (i) para grafos, mede-se usualmente por \(n=|V|\) e \(m=|E|\); se há pesos, também se contabiliza o número de bits para representá-los; (ii) para inteiros, é o número de dígitos; (iii) para strings, o comprimento. Em análises de alto nível, é comum expressar custos como funções de \(n\) e \(m\) no modelo RAM (palavra de \(\Theta(\log n)\) bits), mas quando os pesos são grandes a complexidade em bits pode prevalecer.}. Ao analisar a complexidade de um algoritmo, é importante considerar o pior caso, o caso médio e o melhor caso, dependendo do contexto em que o algoritmo será utilizado.

\paragraph{}
Para ilustrar a análise de complexidade, consideremos o exemplo da busca linear vs busca binária em um vetor ordenado\footnote{Por vetor ordenado entendemos um arranjo (array) em que os elementos estão armazenados em posições consecutivas e dispostos segundo uma ordem total (tipicamente crescente ou não decrescente). Essa organização permite algoritmos como a busca binária, que dependem de comparações para descartar metades do intervalo.}. 

\paragraph{Exemplo: Busca Linear vs Busca Binária}
\paragraph{}
O algoritmo de busca linear percorre cada elemento do vetor até encontrar o valor desejado ou chegar ao final do vetor. A complexidade desse algoritmo é \(O(n)\) no pior caso, onde \(n\) é o tamanho do vetor, pois pode ser necessário verificar todos os elementos.

\begin{algobox}{Busca Linear}{busca-linear}
Dado um vetor \(V\) de tamanho \(n\) e um valor \(x\):
\begin{enumerate}\setlength{\itemsep}{2pt}
    \item Para cada índice \(i\) de \(0\) a \(n - 1\):
    \begin{enumerate}\setlength{\itemsep}{2pt}
        \item Se \(V[i] = x\), retorne \(i\).
    \end{enumerate}
    \item Retorne \(-1\) (indica que \(x\) não está no vetor).
\end{enumerate}
\end{algobox}

\paragraph{}
Já o algoritmo de busca binária aproveita o fato de que o vetor está ordenado para reduzir o espaço de busca pela metade a cada iteração.

\begin{algobox}{Busca Binária}{busca-binaria}
Dado um vetor ordenado \(V\) de tamanho \(n\) e um valor \(x\):
\begin{enumerate}\setlength{\itemsep}{2pt}
    \item Defina \(\text{início} = 0\) e \(\text{fim} = n - 1\).
    \item Enquanto \(\text{início} \leq \text{fim}\):
    \begin{enumerate}\setlength{\itemsep}{2pt}
        \item Calcule \(meio = \left\lfloor \dfrac{\text{início} + \text{fim}}{2} \right\rfloor\).
        \item Se \(V[meio] = x\), retorne \(meio\).
        \item Se \(V[meio] < x\), defina \(\text{início} = meio + 1\).
        \item Caso contrário, defina \(\text{fim} = meio - 1\).
    \end{enumerate}
    \item Retorne \(-1\) (indica que \(x\) não está no vetor).
\end{enumerate}
\end{algobox}  

O algoritmo de busca linear tem a seguinte complexidade:
\begin{itemize}\setlength{\itemsep}{2pt}
    \item \textbf{Melhor caso}: \(O(1)\) - o elemento procurado está na primeira posição.
    \item \textbf{Caso médio}: \(O(n)\) - em média, metade dos elementos precisam ser verificados.
    \item \textbf{Pior caso}: \(O(n)\) - o elemento procurado está na última posição ou não está no vetor.
\end{itemize}

Já o algoritmo de busca binária tem a seguinte complexidade:
\begin{itemize}\setlength{\itemsep}{2pt}
    \item \textbf{Melhor caso}: \(O(1)\) - o elemento procurado está no meio do vetor.
    \item \textbf{Caso médio}: \(O(\log n)\) - em média, a cada iteração, o tamanho do vetor é reduzido pela metade.
    \item \textbf{Pior caso}: \(O(\log n)\) - o elemento procurado não está no vetor ou está na extremidade.
\end{itemize}
 
\paragraph{}
Esse exemplo ilustra como a análise de complexidade pode fornecer insights sobre a eficiência de um algoritmo em diferentes cenários. A busca binária é muito mais eficiente do que uma busca linear (\(O(n)\)) para grandes vetores, graças à sua capacidade de reduzir o espaço de busca pela metade a cada iteração.

\subsubsection{Os problemas e suas complexidades}

Não avaliamos só o desempenho de \emph{um algoritmo}; também queremos saber \emph{quão difícil é o próprio problema}, assim temos  a seguinte forma de classificar problemas:    
\begin{itemize}\setlength{\itemsep}{2pt}
    \item \textbf{Problemas de decisão}: problemas que podem ser respondidos com "sim" ou "não". Ex.: "Existe um caminho entre dois vértices em um grafo?"
    \item \textbf{Problemas de otimização}: problemas que envolvem encontrar a melhor solução possível entre várias opções. Ex.: "Qual é o caminho mais curto entre dois vértices em um grafo ponderado?"
    \item \textbf{Problemas de contagem}: problemas que envolvem contar o número de soluções possíveis. Ex.: "Quantos caminhos existem entre dois vértices em um grafo?"
\end{itemize}

\paragraph{}
Cada classe de problemas pode ter diferentes níveis de dificuldade, que avaliamos em termos de \emph{complexidade computacional}, que mede os recursos necessários (tempo e espaço) para resolver o problema.

Problemas são considerados "fáceis" quando são resolvíveis em tempo polinomial, enquanto outros são "difíceis" quando não se conhece nenhum algoritmo eficiente para resolvê-los.

\paragraph{Classes de complexidade de problemas}

\paragraph{}
 Como regra prática, consideramos \emph{tratáveis} os problemas que admitem soluções em tempo (ou espaço) \emph{polinomial} no tamanho da entrada e \emph{intratáveis} os que não admitem. Essa distinção é formalizada por meio de \emph{classes de complexidade}, que agrupam problemas segundo sua dificuldade intrínseca. Abaixo apresentamos-as:

\begin{itemize}\setlength{\itemsep}{2pt}
    \item \textbf{P} (tempo polinomial). “Resolver é fácil”: existe um algoritmo que encontra a resposta em tempo que cresce como \(n^k\) para algum \(k\). Exemplos: conectividade em grafos, árvore geradora mínima (MST), caminho mínimo com pesos não negativos, fluxo máximo.
    \item \textbf{NP} (verificação polinomial). “Conferir é fácil”: se alguém propõe uma solução, conseguimos \emph{verificar} em tempo polinomial se ela está correta (achar pode ser difícil). Exemplos: \emph{SAT} (satisfatibilidade booleana), \emph{Clique}, \emph{Vertex Cover}.
    \item \textbf{co-NP}. Complementos dos problemas em NP — “conferir o ‘não’ é fácil” em vez do “sim”. Exemplo: \emph{TAUT} (verificar se uma fórmula é tautologia) está em co-NP.
    \item \textbf{NP-difícil}. “Tão difíceis quanto o mais difícil de NP”: todo problema de NP reduz-se (em tempo polinomial) a eles. Podem ser de decisão, otimização ou contagem e \emph{não precisam} estar em NP. Em geral, não se espera algoritmo polinomial para todos os casos. Exemplos: versão de otimização do \emph{TSP} (caixeiro-viajante), programação inteira, coloração mínima de grafos.
    \item \textbf{NP-completo}. “Os mais difíceis \emph{dentro} de NP”: problemas de decisão que estão em NP e são NP-difíceis. Se algum NP-completo tiver algoritmo polinomial, então \(\mathrm{P}=\mathrm{NP}\). Exemplos: \emph{SAT}, \emph{3-SAT}, problema \emph{Hamiltoniano} (existe ciclo hamiltoniano?).
    \item \textbf{PSPACE} (espaço polinomial). “Memória polinomial, tempo possivelmente enorme”: resolvíveis usando memória que cresce polinomialmente com o tamanho da entrada. Exemplo: \emph{QBF} (satisfatibilidade com quantificadores) é PSPACE-completo.
\end{itemize}

\paragraph{Reduções polinomiais}

\paragraph{}
Para comparar dificuldades, usamos reduções de problemas, reduzimos o problema \(A\) ao problema \(B\) (escrevemos \(A\le_p B\)) quando conseguimos transformar qualquer instância de \(A\) em uma instância de \(B\) em tempo polinomial, de modo que resolver \(B\) nos dê a resposta de \(A\) com apenas um sobrecusto polinomial. Logo: se \(A\le_p B\), então \textbf{\(B\) é pelo menos tão difícil quanto \(A\)} (um resolvedor para \(B\) resolveria \(A\) via redução). \footnote{Consequência útil: se \(A\le_p B\) e \(B\) tem algoritmo polinomial, então \(A\) também tem. Para mostrar que um problema \(C\) é NP-difícil, reduzimos \emph{de} um NP-completo conhecido \(P\) \emph{para} \(C\) (isto é, \(P\le_p C\)). Para provar que \(C\) é NP-completo, além disso precisamos que \(C\in\mathrm{NP}\). Exemplo: \(\text{3-SAT}\le_p \text{Clique}\) — resolver \textit{Clique} eficientemente daria um método eficiente para \textit{3-SAT}.}

\paragraph{Relações conhecidas}

\paragraph{}
Temos inclusões básicas: \(\mathrm{P}\subseteq \mathrm{NP}\), \(\mathrm{P}\subseteq \mathrm{co\text{-}NP}\) e \(\mathrm{NP}\subseteq \mathrm{PSPACE}\subseteq \mathrm{EXP}\). Acredita-se que muitas dessas inclusões sejam estritas, mas isso não foi provado; em particular, o problema \(\mathrm{P}\) vs \(\mathrm{NP}\) permanece em aberto. Também não se sabe se \(\mathrm{NP}=\mathrm{co\text{-}NP}\).

\paragraph{}
Essas classes não só categorizam problemas por sua dificuldade intrínseca, como também orientam a \emph{estratégia de solução}. Em linhas gerais: (i) quando o problema está em \(\mathrm{P}\), preferimos \textbf{algoritmos exatos} com tempo polinomial; (ii) para problemas NP-completos/NP-difíceis, \emph{não se conhecem} algoritmos exatos polinomiais (a menos que \(\mathrm{P}=\mathrm{NP}\)), e métodos gerais costumam ter pior caso exponencial. Por isso, são comuns \textbf{heurísticas}, \textbf{algoritmos de aproximação} e abordagens de \textbf{complexidade parametrizada} (FPT), além de algoritmos \textbf{pseudo-polinomiais} em casos numéricos. Muitas vezes, estruturas especiais (ex.: largura de árvore pequena, aciclicidade, graus limitados) também permitem soluções exatas polinomiais para subclasses. A seguir, explicitamos essa distinção entre \emph{algoritmos exatos} e \emph{heurísticas}.

\subsubsection{Tipificando Algoritmos}

É comum ouvirmos que “o ótimo é inimigo do bom”. Essa frase, atribuída a Voltaire, expressa a ideia de que buscar a perfeição pode impedir que se alcance um resultado satisfatório. Essa tensão entre buscar o ideal do “ótimo”  ou aceitar o “suficientemente bom” quando recursos e tempo são limitados\footnote{Na teoria da decisão, essa postura pragmática é conhecida como \emph{satisficing}, termo introduzido por Herbert A. Simon.} essa noção se materializa em uma forma de tipificação de algoritmos.

\paragraph{Algoritmos Exatos vs Heurísticos}

\paragraph{}
Essa distinção é especialmente relevante em problemas de otimização, onde o objetivo é encontrar a melhor solução possível entre um conjunto de soluções viáveis. Existem dois tipos principais de algoritmos para abordar esses problemas: os \emph{algoritmos exatos} e os \emph{algoritmos heurísticos}.

\begin{itemize}\setlength{\itemsep}{2pt}
    \item \textbf{Algoritmos Exatos}: são aqueles que garantem encontrar a solução ótima para um problema, se uma solução existe. Eles exploram todas as possibilidades ou utilizam técnicas matemáticas rigorosas para garantir a optimalidade. Exemplos incluem algoritmos de programação linear, algoritmos de busca exaustiva e algoritmos baseados em teoria dos grafos, como o algoritmo de Dijkstra para caminhos mínimos.
    \item \textbf{Algoritmos Heurísticos}: são métodos que buscam soluções boas (mas não necessariamente ótimas) para problemas complexos, especialmente quando o espaço de soluções é muito grande ou quando o problema é NP-difícil. Eles utilizam regras práticas, aproximações ou estratégias de busca para encontrar soluções rapidamente. Exemplos incluem algoritmos genéticos, algoritmos de busca local e algoritmos de otimização por enxame de partículas.
\end{itemize}

\paragraph{}
Um tipo de algoritmo heurístico que merece destaque são os \emph{algoritmos gulosos}, pois os algoritmos que estudaremos para encontrar r-arborescências de custo mínimo se enquadram nessa categoria.

\paragraph{Algoritmos Gulosos}
\paragraph{}
Os algoritmos gulosos são uma classe de algoritmos heurísticos que tomam decisões locais ótimas em cada etapa, na esperança de que essas escolhas levem a uma solução globalmente ótima. Eles são frequentemente utilizados em problemas de otimização, onde uma solução ótima é desejada, mas encontrar essa solução pode ser computacionalmente inviável.

\paragraph{}
Os algoritmos gulosos são caracterizados por:
\paragraph{}

1. \textbf{Escolha Local Ótima}: Em cada etapa do algoritmo, uma escolha é feita com base em algum critério de otimização local. Essa escolha é feita sem considerar as consequências futuras, ou seja, o algoritmo "se contenta" com a melhor opção disponível no momento.

\paragraph{}
2. \textbf{Decisões defitivas}: Uma vez que uma escolha é feita, o algoritmo não reconsidera essa decisão. Isso significa que, se uma escolha levar a uma solução subótima, o algoritmo não tentará corrigir esse erro mais tarde.

\paragraph{}
3. \textbf{Eficiência}: Os algoritmos gulosos tendem a ser mais eficientes em termos de tempo de execução do que métodos exatos, pois não exploram todo o espaço de soluções. No entanto, essa eficiência pode vir à custa da qualidade da solução encontrada.

\paragraph{}
Exemplos clássicos de algoritmos gulosos incluem:

\begin{itemize}
        \item \textbf{Kruskal}: seleciona as arestas de menor peso, evitando formar ciclos; produz uma árvore geradora mínima.
        \item \textbf{Prim}: inicia em um vértice e, a cada passo, adiciona a aresta mais leve que cruza o corte entre a árvore e o restante do grafo.
        \item \textbf{Dijkstra}: em dígrafos (ou grafos) com pesos não negativos, expande pelo vértice de menor distância conhecida e relaxa suas saídas.
        \item  \textbf{Kahn} (ordenação topológica): em DAGs, remove repetidamente vértices de grau de entrada zero e elimina suas saídas, construindo uma ordem topológica.
        \item \textbf{Chu–Liu/Edmonds} (arborescência mínima): escolhe, para cada \(v\neq r\), o arco de menor custo que entra em \(v\); ao formar ciclos, contrai-os e usa custos reduzidos até obter a r‑arborescência de custo mínimo.
       \item \textbf{Frank} (arborescência mínima em duas fases): na primeira fase, constrói uma arborescência qualquer; na segunda, ajusta os custos reduzidos e troca arcos para minimizar o custo total.
\end{itemize}

\paragraph{}
Com esses conceitos em mente, estamos prontos para explorar os algoritmos específicos para encontrar r-arborescências de custo mínimo, que serão detalhados no próximo capítulo.

\section{Em busca da Arborescência Perdida}

\paragraph{}
Vamos usar esse capítulo para situar a evolução do problema: começamos revisitando como se encontra conectividade de menor custo em grafos não dirigidos por meio de \emph{árvores geradoras mínimas} (MST), onde estratégias gulosas são corretas graças aos princípios de \emph{corte} e de \emph{ciclo}. Em seguida veremos por que, ao passar para \emph{dígrafos} e buscar uma \textbf{r‑arborescência de custo mínimo}, essas mesmas receitas não se aplicam literalmente: surgem ciclos dirigidos e falta um “corte seguro” direto. Essa transição motiva as ferramentas certas — \emph{custos reduzidos} e \emph{contração de ciclos} — que aparecem no algoritmo de \textbf{Chu–Liu/Edmonds} e, adiante, no procedimento em duas fases de \textbf{Frank}.

\subsection{Contexto Histórico}
O problema de encontrar uma r-arborescência de custo mínimo em um dígrafo ponderado é de certa forma uma evolução do problema de conectividade de menor custo em grafos não dirigidos, mas traz desafios adicionais que exigem novas ferramentas e estratégias.

\paragraph{A busca em grafos}

\paragraph{}
Antes de tratarmos do caso \emph{dirigido}, vamos falar sobre a intuição dominante de \emph{como construir estruturas de conectividade de menor custo} vinha do caso de \emph{grafos não dirigidos}: as \textbf{árvores geradoras mínimas}\footnote{Definição. Em um grafo não dirigido, conexo e ponderado \(G=(V,E)\) com pesos \(w:E\to\mathbb{R}\), uma árvore geradora mínima é um subconjunto de arestas \(T\subseteq E\) que forma uma árvore (conecta todos os vértices, é acíclica e tem \(|T|=|V|-1\)) e que minimiza \(\sum_{e\in T} w(e)\).} (\emph{Minimum Spanning Trees}, MST). 

\paragraph{}
De modo geral, funciona a seguinte regra para esse caso: “escolha sempre a aresta mais barata disponível e encontraremos uma estrutura ótima”. Existem dois princípios que justificam essa intuição:

\begin{itemize}\setlength{\itemsep}{2pt}
    \item \textbf{Princípio do corte seguro.} Um \emph{corte} é uma separação do conjunto de vértices em duas partes \(S\) e \(V\setminus S\). Dizemos que uma aresta “cruza” o corte se tem uma ponta em cada lado. O princípio afirma: \emph{a aresta de menor peso que cruza qualquer corte é segura}, ou seja, pode ser incluída em alguma MST sem perder optimalidade. É o mesmo que dizer
    intuitivamente, que se alguma solução ótima usa uma aresta \(e^*\) que cruza um certo corte e existe outra aresta \(e\) \emph{mais barata} cruzando o mesmo corte, podemos trocar \(e^*\) por \(e\). A troca mantém o grafo conectado (o corte continua sendo cruzado) e não aumenta o custo. Portanto, a mais barata do corte é sempre segura.
    \begin{figure}[htbp]
    \centering
    % Ilustração do princípio do corte seguro
    \begin{tikzpicture}[scale=1]
        % Estilos
        	\tikzset{
            v/.style={circle, draw, fill=blue!10, minimum size=6mm, inner sep=0pt},
            edgeG/.style={line width=0.9pt, draw=gray!65},
            cross/.style={line width=1pt, draw=gray!65},
            safe/.style={line width=1.6pt, draw=green!50!black},
            cutline/.style={red!70, dashed, line width=1pt}
        }
        % Nós
        \node[v, label=left:$a$] (A) at (-2, 1) {};
        \node[v, label=left:$b$] (B) at (-2,-1) {};
        \node[v, label=right:$c$] (C) at ( 2, 1) {};
        \node[v, label=right:$d$] (D) at ( 2,-1) {};

        % Lados do corte (rótulos)
        \node[anchor=east, gray!70] at (-2.8, 0) {$S$};
        \node[anchor=west, gray!70] at ( 2.8, 0) {$V\setminus S$};

        % Linha do corte
        \draw[cutline] (0, 1.6) -- (0,-1.6);

        % Arestas internas (apenas contexto)
        \draw[edgeG] (A) -- (B);
        \draw[edgeG] (C) -- (D);

        % Arestas que cruzam o corte (com pesos)
        \draw[edgeG] (A) -- node[above, sloped, fill=white, inner sep=1pt] {4} (C);
        \draw[safe]  (A) -- node[below, sloped, fill=white, inner sep=1pt] {\textbf{2}} (D);
        \draw[edgeG] (B) -- node[below, sloped, fill=white, inner sep=1pt] {3} (C);

    % Destaque textual
    \node[green!40!black] at (0.4,-2.0) {A aresta mais barata que cruza o corte};
    \end{tikzpicture}
    \caption{Princípio do corte seguro: entre as arestas que cruzam \((S, V\setminus S)\), a de menor peso (em verde) é \emph{segura} — pode ser incluída em alguma MST sem perder optimalidade.}
    \label{fig:mst-cut-safe}
\end{figure}
    \item \textbf{Princípio do uso da aresta mais pesada em um ciclo.} Em qualquer \emph{ciclo}, a aresta de maior peso \emph{não} pode pertencer a uma MST, pois existe uma troca que reduz (ou não aumenta) o custo total removendo essa aresta pesada, podemos entender que em um ciclo \(C\), remover a aresta \emph{mais pesada} não desconecta o grafo (há caminho alternativo dentro do próprio ciclo). Como é a mais cara, retirá-la só pode reduzir (ou manter) o custo. Logo, nenhuma MST precisa conter a aresta mais pesada de um ciclo.

\begin{figure}[htbp]
    \centering
    % Ilustração do princípio da aresta mais pesada do ciclo
    \begin{tikzpicture}[scale=1]
        % Estilos
        	\tikzset{
            v/.style={circle, draw, fill=blue!10, minimum size=6mm, inner sep=0pt},
            edgeG/.style={line width=0.9pt, draw=gray!65},
            heavy/.style={line width=1.6pt, draw=red!70},
            note/.style={gray!70}
        }
        % Nós do ciclo
        \node[v, label=left:$u$]  (U) at (-2, 0) {};
        \node[v, label=above:$v$] (V) at ( 0, 1.7) {};
        \node[v, label=right:$x$] (X) at ( 2, 0) {};
        \node[v, label=below:$y$] (Y) at ( 0,-1.7) {};

        % Arestas do ciclo com pesos
        \draw[edgeG] (U) -- node[above left,  fill=white, inner sep=1pt] {1} (V);
        \draw[heavy] (V) -- node[above right, fill=white, inner sep=1pt] {\textbf{5}} (X);
        \draw[edgeG] (X) -- node[below right, fill=white, inner sep=1pt] {2} (Y);
        \draw[edgeG] (Y) -- node[below left,  fill=white, inner sep=1pt] {3} (U);

        % Observação
        \node[red!90!] at (0, -3.0) {A aresta mais pesada do ciclo (vermelha) não precisa aparecer em nenhuma MST};
    \end{tikzpicture}
    \caption{Princípio do ciclo: em qualquer ciclo, a aresta mais pesada (em vermelho) pode ser removida sem desconectar o grafo, reduzindo (ou não aumentando) o custo. Portanto, nenhuma MST contém a aresta mais pesada de um ciclo.}
    \label{fig:mst-cycle-heavy}
\end{figure}
\end{itemize}

Assim o problema de encontrar uma árvore geradora mínima (MST) consiste em dado um grafo (não dirigido), conexo e ponderado \(G=(V,E)\) com pesos \(w:E\to\mathbb{R}\), queremos um subconjunto de arestas \(T\subseteq E\) que conecta todos os vértices sem ciclos (forma uma árvore) e minimiza \(\sum_{e\in T} w(e)\). 
Com base nos princípios acima, duas soluções gulosas são propostas: \textbf{Kruskal} e \textbf{Prim}.

\begin{itemize}\setlength{\itemsep}{2pt}
    \item \textbf{Kruskal}: ordena as arestas por peso e adiciona enquanto não formar ciclo; usa o princípio do ciclo para evitar carregar a aresta mais pesada de um ciclo.
    \item \textbf{Prim}: começa em um vértice e cresce a árvore; a cada passo escolhe a aresta mais leve que cruza o corte entre “dentro” e “fora” — aplicação direta do princípio do corte.
\end{itemize}


\begin{algobox}{Kruskal (MST, guloso por peso crescente)}{mst-kruskal}
Entrada: grafo não dirigido \(G=(V,E)\), pesos \(w\).
\begin{enumerate}\setlength{\itemsep}{2pt}
    \item Ordene as arestas por peso crescente.
    \item Inicialize um \emph{Union-Find}\footnote{Também conhecido como \emph{Disjoint Set Union} (DSU) ou \emph{estrutura de conjuntos disjuntos}. Mantém uma partição dinâmica dos vértices em componentes, oferecendo operações \texttt{find} (descobrir o representante do conjunto) e \texttt{union} (unir dois conjuntos). Com as heurísticas de \emph{união por rank/tamanho} e \emph{compressão de caminhos}, ambas operam em tempo amortizado \(\alpha(n)\) (a função inversa de Ackermann), efetivamente constante na prática. Em Kruskal, essa estrutura detecta ciclos rapidamente ao verificar se as pontas de uma aresta pertencem a componentes distintas.} com cada vértice em seu próprio conjunto; comece com \(T=\emptyset\).
    \item Para cada aresta \(e=\{u,v\}\) na ordem: se \(u\) e \(v\) estão em componentes diferentes, una as componentes e adicione \(e\) a \(T\).
    \item Pare quando \(|T|=|V|-1\). Devolva \(T\).
\end{enumerate}
\end{algobox}

\paragraph{}Kruskal é correto pelos princípios de corte e ciclo; com Union-Find eficiente, roda em \(O(m\log m)\) (ou \(O(m\log n)\)).

\begin{algobox}{Prim (MST, expansão por corte mínimo)}{mst-prim}
Entrada: grafo não dirigido \(G=(V,E)\), pesos \(w\), vértice inicial \(s\).
\begin{enumerate}\setlength{\itemsep}{2pt}
    \item Inicialize \(T=\{s\}\) e uma fila de prioridades\footnote{Estrutura que mantém elementos com chaves de prioridade e permite extrair rapidamente o de menor (ou maior) chave. Implementações típicas: \emph{heap} binário (\(\mathrm{push}/\mathrm{decrease\text{-}key}/\mathrm{pop}\) em \(O(\log n)\)), \emph{heap} de Fibonacci (\(\mathrm{decrease\text{-}key}\) amortizado \(O(1)\), \(\mathrm{pop}\) em \(O(\log n)\)), e, em grafos com pesos pequenos, fila bucket (Dial) com tempos quase-lineares. No Prim, a fila é chaveada pelo menor peso de aresta que conecta o vértice fora da árvore ao conjunto \(T\).} com as arestas que saem de \(T\), chaveando pelo menor peso.
    \item Enquanto \(|T|<|V|\): extraia a aresta mais leve \(\{u,v\}\) com \(u\in T\) e \(v\notin T\); adicione \(v\) e \(\{u,v\}\) à árvore; atualize as chaves das arestas que cruzam o novo corte.
    \item Devolva a árvore construída.
\end{enumerate}
\end{algobox}

\paragraph{}Prim também é correto pelo princípio do corte; com fila de prioridades binária, executa em \(O(m\log n)\) (ou em \(O(m+n\log n)\)); em grafos densos com \emph{heaps} de Fibonacci\footnote{\emph{Heaps} (montes) são implementações clássicas de filas de prioridades. O \textbf{heap binário} mantém uma árvore quase completa e executa \texttt{insert}/\texttt{extract-min}/\texttt{decrease-key} em \(O(\log n)\). Já o \textbf{heap de Fibonacci} é uma estrutura amortizada com \texttt{decrease-key} e \texttt{meld} (união) em \(O(1)\) amortizado e \texttt{extract-min} em \(O(\log n)\). Em algoritmos como Prim e Dijkstra, onde \texttt{decrease-key} é frequente, isso leva a \(O(m+n\log n)\). Apesar da melhor garantia assintótica, constantes e implementação mais simples fazem heaps binários (ou \emph{pairing heaps}) serem frequentemente competitivos na prática.}, pode-se obter \(O(m+n\log n)\) \cite{cormen2009,kleinberg2006,west2001introduction,diestel2017graph}.

\paragraph{}
Os algoritmos gulosos de MST são corretos em grafos não dirigidos, mas a passagem para dígrafos \emph{não} é direta. No caso dirigido, buscamos uma \textbf{r-arborescência de custo mínimo}: para cada \(v\neq r\), exatamente um arco entra em \(v\), e o conjunto deve ser acíclico e alcançável a partir de \(r\). Se imitarmos a receita de MST (escolher sempre o arco de entrada mais barato), aparecem \emph{ciclos dirigidos}, e não há um análogo imediato do “corte seguro”.

\paragraph{}
Duas abordagens clássicas contornam essas dificuldades: (i) \textbf{Chu–Liu/Edmonds}, que mantém \emph{custos reduzidos} (criando arcos de custo reduzido zero) e resolve conflitos por \emph{contração de ciclos}; e (ii) o procedimento em duas fases de \textbf{Frank}, que parte de uma arborescência qualquer e a refina via ajustes de custos e trocas de arcos. Em ambos os casos, escolhas locais são acopladas a um mecanismo global de consistência, garantindo otimalidade no caso dirigido \cite{schrijver2003comb}.

\subsubsection{A busca em digrafos}

\paragraph{}
O primeiro avanço significativo na busca por arborescências de custo mínimo em dígrafos foi feito por Y. Chu e T. Liu em 1965, que propuseram um algoritmo para encontrar a arborescência de custo mínimo em um dígrafo. Esse algoritmo foi posteriormente aprimorado por Jack Edmonds em 1967, que introduziu o conceito de custos reduzidos e a técnica de contração de ciclos, tornando o algoritmo mais eficiente e robusto.

\paragraph{}
Desde então, a pesquisa nessa área tem se concentrado em melhorar a eficiência dos algoritmos existentes, bem como em explorar novas técnicas e abordagens para lidar com diferentes tipos de dígrafos e restrições adicionais. A contribuição de András Frank, que propôs um procedimento em duas fases para encontrar arborescências de custo mínimo, é um exemplo notável dessa evolução contínua.

\subsection{Os meios para um fim}

\paragraph{}
Maquiável é conhecido por uma de suas citações: "Os fins justificam os meios". Essa frase ficou famosa, porque tem uma interpretação polêmica: em certas circunstâncias, qualquer ação pode ser justificada se o resultado final for considerado positivo ou benéfico. Muitos, não concordam com essa visão, argumentando que os meios também importam e que ações imorais não podem ser justificadas por bons resultados.

\paragraph{}
Por um lado, na matemática essa frase pode ser validada quando falamos em duas formas distintas de construir algoritmos: por \emph{iteratividade} ou \emph{recursividade}.

\paragraph{Iteratividade}
\paragraph{}
Muitos algoritmos — incluindo os gulosos — são construídos por \emph{iteração}: repetimos um bloco de instruções enquanto uma condição não é satisfeita. Para projetar e analisar laços com clareza, três ideias são centrais:

\begin{itemize}\setlength{\itemsep}{2pt}
    \item \textbf{Invariante de laço}: uma propriedade que é verdadeira antes do laço e permanece verdadeira a cada iteração. Ela explica \emph{o que} está sendo mantido correto durante a construção.
    \item \textbf{Variante (medida de progresso)}: uma quantidade que melhora estritamente a cada iteração (ex.: aumenta $|T|$, diminui $|V|$, reduz um potencial). Garante \emph{terminação}.
    \item \textbf{Critério de parada e pós-condição}: quando o laço termina, o invariante implica a especificação desejada.
\end{itemize}

\paragraph{}
	\textit{Na prática.} Em \textbf{Kruskal}, o invariante é “$T$ é uma floresta acíclica e cada componente foi conectado por arestas seguras”; a variante é $|T|$, que cresce até $|V|-1$. Em \textbf{Prim}, “$T$ conecta um conjunto de vértices e as chaves refletem o menor corte atual”; a variante é o tamanho de $T$. Muitas análises usam \emph{custo por iteração} ou \emph{análise amortizada}\footnote{A análise amortizada distribui o custo de operações caras sobre uma sequência, garantindo um custo médio por operação (ex.: \texttt{decrease-key} em heaps de Fibonacci).} para capturar o desempenho agregado.

\paragraph{Recursão}
\paragraph{}
Recursão resolve instâncias grandes chamando o próprio algoritmo em subinstâncias menores. Um projeto claro inclui:

\begin{itemize}\setlength{\itemsep}{2pt}
    \item \textbf{Casos base}: instâncias mínimas resolvidas diretamente.
    \item \textbf{Passo recursivo}: como decompor e combinar soluções dos subproblemas.
    \item \textbf{Medida decrescente}: uma grandeza que estritamente diminui a cada chamada (ex.: número de vértices após contração), assegurando terminção.
    \item \textbf{Corretude por indução}: assumimos corretas as chamadas recursivas (hipótese indutiva) e provamos que a combinação produz uma solução correta.
    \item \textbf{Custo por recorrência}: tempo expresso por $T(n)$ e resolvido por \emph{árvore de recursão} ou Teorema Mestre\footnote{Esboço: quando $T(n)=a\,T(n/b)+f(n)$, com $a\ge 1$, $b>1$, comparamos $f(n)$ a $n^{\log_b a}$. Não é necessário aqui, mas a técnica guia estimativas assintóticas.}.
\end{itemize}

\paragraph{}
	\textit{Na prática.} Em \textbf{Chu–Liu/Edmonds}, o passo recursivo contrai um ciclo dirigido e ajusta custos; a medida decrescente é $|V|$ (a cada contração reduzimos o número de vértices do problema), e a expansão final preserva otimalidade. No procedimento em duas fases de \textbf{Frank}, a primeira fase produz uma arborescência inicial; a segunda aplica \emph{refinamentos iterativos} guiados por custos reduzidos — um exemplo de mistura entre recursão estrutural e iteração local.

\paragraph{}
Para ilustrar, resolvemos o mesmo problema — calcular o fatorial \(n!\) — de forma \emph{iterativa} e \emph{recursiva}.

\begin{algobox}{Fatorial (iterativo)}{fatorial-iterativo}
Entrada: inteiro \(n\ge 0\)
\begin{enumerate}\setlength{\itemsep}{2pt}
    \item Se \(n=0\), devolva \(1\).
    \item Defina \(r\leftarrow 1\).
    \item Para \(i\) de \(1\) até \(n\): \(r\leftarrow r\cdot i\).
    \item Devolva \(r\).
\end{enumerate}
\end{algobox}

\begin{algobox}{Fatorial (recursivo)}{fatorial-recursivo}
Entrada: inteiro \(n\ge 0\)
\begin{enumerate}\setlength{\itemsep}{2pt}
    \item Se \(n\le 1\), devolva \(1\). \hfill (caso base)
    \item Caso contrário, devolva \(n\cdot \textsc{Fatorial}(n-1)\). \hfill (passo recursivo)
\end{enumerate}
\end{algobox}

\paragraph{}
Ambas as versões computam a mesma função. A iterativa evidencia a \emph{variante} (o contador \(i\)) e um \emph{invariante} simples (\(r= i!\) ao fim da iteração \(i\)); a recursiva explicita o \emph{caso base} e o \emph{passo indutivo}, e corresponde, operacionalmente, a empilhar chamadas com parâmetros decrescentes até \(n=1\).    

\paragraph{}
Existe inclusive uma prova matemática\footnote{Em modelos padrão de computação (máquinas de Turing, RAM), \emph{iteração} e \emph{recursão} têm o mesmo poder expressivo: laços podem ser reescritos como recursão (sobre um contador/estado) e chamadas recursivas podem ser eliminadas por uma simulação explícita da pilha (iteração com uma estrutura \textit{stack}). Demonstrações e variantes aparecem em textos clássicos de teoria da computação e projeto de algoritmos; ver, por exemplo, \cite{cormen2009} (eliminação de recursão via pilha explícita). Aqui registramos apenas a equivalência conceitual, sem apresentá-la.} que diz que qualquer algoritmo iterativo pode ser reescrito de forma recursiva, e vice-versa. Ou seja, \emph{os fins justificam os meios}: a escolha entre iteração e recursão é muitas vezes uma questão de preferência ou conveniência, já que ambos podem alcançar o mesmo objetivo. Porém, algoritmos recursivos podem ser mais elegantes e fáceis de entender, enquanto algoritmos iterativos podem ser mais eficientes em termos de uso de memória (evitando a sobrecarga da pilha de chamadas). Ou seja, os meios também importam. E os trabalhos de Chu–Liu/Edmonds e Frank ilustram bem essa tensão:
\begin{itemize}\setlength{\itemsep}{2pt}
    \item \textbf{Chu–Liu/Edmonds} é um algoritmo recursivo que contrai ciclos e resolve o problema em subinstâncias menores, usando custos reduzidos para manter a otimalidade.
    \item O procedimento em \textbf{Frank} é iterativo, começando com uma arborescência qualquer e refinando-a por trocas locais guiadas por custos reduzidos, até alcançar a otimalidade.
\end{itemize}
Ambos os algoritmos são corretos e eficientes, mas adotam meios diferentes para alcançar o mesmo fim: encontrar uma r-arborescência de custo mínimo em um dígrafo ponderado.

\paragraph{}
Antes de entrar nos detalhes, faremos uma breve revisão dos conceitos e técnicas que utilizaremos adiante, para uniformizar a notação e tornar a leitura mais fluida.

\paragraph{Revisão: conceitos fundamentais e técnicas}

\paragraph{}
Antes de mergulharmos nos algoritmos específicos, é importante revisitar alguns conceitos fundamentais que serão cruciais para nossa compreensão:

\paragraph{Conceitos Fundamentais:}
\begin{itemize}\setlength{\itemsep}{2pt}
    \item \textbf{Dígrafo}: um grafo direcionado onde os arcos têm uma direção específica, indo de um vértice a outro.
    \item \textbf{Arborescência}: uma árvore direcionada onde todos os caminhos partem de um vértice raiz e alcançam todos os outros vértices.
    \item \textbf{Custo dos Arcos}: cada arco em um dígrafo pode ter um custo associado, representando, por exemplo, o custo de transporte ou a distância.
    \item \textbf{r-Arborescência de Custo Mínimo}: uma arborescência enraizada em um vértice \(r\) que minimiza a soma dos custos dos arcos que a compõem.
    \item \textbf{Cortes e Conectividade}: a importância dos cortes em dígrafos para garantir a conectividade e a existência de arborescências.
    \item \textbf{Condicionalidade de Fulkerson}: as condições necessárias e suficientes para a existência de uma r-arborescência de custo mínimo.
\end{itemize}

\paragraph{Técnicas e Abordagens:}
\paragraph{}
Para encontrar r-arborescências de custo mínimo, utilizaremos algumas técnicas e abordagens específicas:
\begin{itemize}\setlength{\itemsep}{2pt}
    \item \textbf{Normalização de Custos}: ajustaremos os custos dos arcos para facilitar a identificação de arcos de custo reduzido zero.
    \item \textbf{Contração de Ciclos}: quando formos encontrar ciclos de arcos de custo reduzido zero, os contrairemos para simplificar o dígrafo.
    \item \textbf{Custos Reduzidos}: utilizaremos custos reduzidos para identificar arcos que podem ser incluídos na arborescência sem aumentar o custo total.
    \item \textbf{Estratégias Gulosas}: aplicaremos estratégias gulosas para selecionar arcos de forma eficiente, garantindo que cada escolha local contribua para a solução global ótima.
    \item \textbf{Recursão e Expansão}: usaremos recursão para resolver subproblemas em dígrafos contraídos e expandiremos as soluções para o dígrafo original.
    \item \textbf{Análise de Complexidade}: avaliaremos a eficiência dos algoritmos em termos de tempo e espaço, garantindo que sejam viáveis para grandes dígrafos.
    \item \textbf{Provas de Corretude}: forneceremos argumentos formais para garantir que os algoritmos realmente produzem a r-arborescência de custo mínimo.
\end{itemize}

\paragraph{}
No capítulo seguinte, detalharemos o algoritmo de Chu–Liu/Edmonds, bem como os detalhes da implementação em Python; o subsequente será dedicado ao procedimento em duas fases de Frank e à respectiva implementação.

\section{Algoritmo de Chu–Liu/Edmonds}

\paragraph{}
O algoritmo de Chu–Liu/Edmonds é um método clássico para encontrar uma r-arborescência de custo mínimo em um dígrafo ponderado. Ele combina estratégias gulosas com técnicas de normalização de custos e contração de ciclos para garantir a otimalidade da solução.

\paragraph{}
Se tentarmos copiar a receita das MSTs — dar a cada vértice \(v\neq r\) o arco de entrada mais barato — corremos o risco de fechar um \emph{ciclo dirigido} que não chega à raiz \(r\). 

\paragraph{}
Por que isso é proibido? Em uma r‑arborescência cada \(v\neq r\) deve ter exatamente um arco de entrada e \(r\) tem grau de entrada zero. Se houvesse um ciclo dirigido \(C\), todos os vértices de \(C\) já receberiam seu único arco de entrada de dentro do próprio \(C\), logo nenhum arco entraria em \(C\) a partir de \(V\setminus C\) (o corte \(\delta^-(C)\) ficaria vazio). Como \(r\notin C\), não existe caminho de \(r\) para os vértices de \(C\), contrariando a alcançabilidade exigida. Portanto, ciclos dirigidos são incompatíveis com a estrutura de r‑arborescência.

\paragraph{}
Dessa forma, o desafio é duplo: preservar a informação local de “mais barato por vértice” (que é valiosa) e, ao mesmo tempo, impedir que essas escolhas locais se combinem em ciclos. 

\paragraph{}
Uma maneira direta de enxergar isso é com um microexemplo: tome três vértices \(a,b,c\) (todos fora de \(r\)). Se o arco mais barato que entra em \(b\) vem de \(a\), o de \(c\) vem de \(b\) e o de \(a\) vem de \(c\), então as escolhas “mais baratas” formam o ciclo \(a\to b\to c\to a\). Note que, entre essas escolhas locais, nenhum deles recebe o arco vindo de \(r\) (mesmo que existam \(r\to a\), \(r\to b\), \(r\to c\) mais caros); ficamos presos dentro do ciclo e não alcançamos a raiz. É exatamente esse impasse que o algoritmo resolve ao zerar custos por vértice e contrair ciclos, deixando para decidir qual arco interno remover apenas na expansão.

\begin{figure}[htbp]
    \centering
    \begin{tikzpicture}[>=Stealth, node distance=2.0cm]
        % estilos
        	\tikzset{
            v/.style={circle, draw, fill=blue!8, minimum size=7mm, inner sep=0pt},
            cheap/.style={->, very thick, draw=blue!70},
            expensive/.style={->, dashed, draw=gray!60}
        }
        % nós
        \node[v] (r) {\small $r$};
        \node[v] (a) [right=2.2cm of r] {\small $a$};
        \node[v] (b) [above right=1.2cm and 1.6cm of a] {\small $b$};
        \node[v] (c) [below right=1.2cm and 1.6cm of a] {\small $c$};
        % ciclo de escolhas mais baratas (custo 1)
        \draw[cheap] (a) to[bend left=12] node[midway, above, sloped] {\scriptsize 1} (b);
        \draw[cheap] (b) to[bend left=12] node[midway, above, sloped] {\scriptsize 1} (c);
        \draw[cheap] (c) to[bend left=14] node[midway, below, sloped] {\scriptsize 1} (a);
        % arcos da raiz mais caros (não escolhidos pelo critério local)
        \draw[expensive] (r) to[bend left=8] node[midway, above, sloped] {\scriptsize 3} (a);
        \draw[expensive] (r) to[bend left=18] node[midway, above, sloped] {\scriptsize 4} (b);
        \draw[expensive] (r) to[bend right=10] node[midway, below, sloped] {\scriptsize 5} (c);
    \end{tikzpicture}
    \caption{Ciclo gerado pelas escolhas locais “mais baratas por vértice”. Os arcos grossos (custo 1) entram em \(a,b,c\) e formam \(a\to b\to c\to a\). Os arcos tracejados partindo de \(r\) existem, mas são mais caros e por isso não são escolhidos pelo critério local.}
    \label{fig:chu-liu-cycle-micro}
\end{figure}

\paragraph{}
Partindo desse cenário, a ideia é \emph{normalizar os custos por vértice}: para cada \(v\neq r\), “descontamos” de todo arco que entra em \(v\) o menor custo que chega a \(v\). Após esse ajuste (custos reduzidos), cada \(v\neq r\) passa a ter ao menos um arco de custo reduzido zero entrando. Se os arcos de custo zero forem acíclicos, já temos a r‑arborescência. Se formarem um ciclo \(C\), isso indica que, dentro de \(C\), todos os vértices atingiram seus mínimos locais; então \emph{contraímos} \(C\) em um \textbf{supervértice} \(x_C\) e repetimos o processo no grafo menor. Ao final, \emph{expandimos} as contrações e, em cada ciclo expandido, removemos exatamente um arco para manter grau de entrada 1 e a aciclicidade global.

\paragraph{Supervértices e contração de ciclos}

\paragraph{}
Dado um subconjunto \(C\subseteq V\) que forma um ciclo dirigido, a \emph{contração de \(C\)} substitui todos os vértices de \(C\) por um único vértice \(x_C\) - \textbf{o supervértice}. Todo arco com exatamente uma ponta em \(C\) passa a ser incidente a \(x_C\):
\begin{itemize}\setlength{\itemsep}{2pt}
    \item arcos \((u,w)\) com \(u\notin C\), \(w\in C\) tornam-se \((u, x_C)\);
    \item arcos \((w,v)\) com \(w\in C\), \(v\notin C\) tornam-se \((x_C, v)\);
    \item arcos com as duas pontas em \(C\) tornam-se laços em \(x_C\) e são descartados.
\end{itemize}
Quando trabalhamos com \emph{custos reduzidos}, ajustamos em particular os arcos que \emph{entram} em \(C\) para preservar a comparação relativa: para um arco \((u,w)\) com \(w\in C\), definimos \(c'(u,x_C) = c(u,w) - c(a_w)\), onde \(a_w\) é o arco mais barato que entra em \(w\). Essa normalização garante que, ao resolver no grafo contraído, decisões ótimas podem ser traduzidas de volta na etapa de expansão.

\begin{figure}[htbp]
    \centering
    \begin{minipage}[t]{0.52\textwidth}
        \centering
        \begin{tikzpicture}[>=Stealth, node distance=1.4cm]
            	\tikzset{v/.style={circle, draw, fill=blue!8, minimum size=7mm, inner sep=0pt},
                     cheap/.style={->, very thick, draw=blue!70},
                     e/.style={->, semithick, draw=gray!65}}
            % ciclo C e arcos internos (a_w em negrito)
            \node[v] (a) {\small $a$};
            \node[v] (b) [above right=0.9cm and 1.4cm of a] {\small $b$};
            \node[v] (c) [below right=0.9cm and 1.4cm of a] {\small $c$};
            % interno: a->b é a_b (mais barato em b), custo 5
            \draw[cheap] (a) to[bend left=12] node[midway, above, sloped] {\scriptsize $5$} (b);
            % outros do ciclo (custos quaisquer)
            \draw[e] (b) to[bend left=12] node[midway, above, sloped] {\scriptsize $4$} (c);
            \draw[e] (c) to[bend left=14] node[midway, below, sloped] {\scriptsize $6$} (a);
            % arco externo u->b com custo 7
            \node[v] (u) [left=1.9cm of b] {\small $u$};
            \draw[e] (u) -- node[midway, above, sloped] {\scriptsize $7$} (b);
            % contorno do ciclo C
            \node[draw=blue!40, rounded corners, fit=(a)(b)(c), inner sep=6pt, label={[blue!60]below:{\small $C$}}] {};
        \end{tikzpicture}
        \vspace{2pt}
        \small (a) Antes: $a_b=(a\!\to\!b)$ tem custo $5$; o arco externo $(u\!\to\!b)$ tem custo $7$.
    \end{minipage}\hfill
    \begin{minipage}[t]{0.44\textwidth}
        \centering
        \begin{tikzpicture}[>=Stealth, node distance=2.0cm]
            	\tikzset{v/.style={circle, draw, fill=blue!8, minimum size=7mm, inner sep=0pt},
                     e/.style={->, very thick, draw=blue!70}}
            \node[v] (x) {\small $x_C$};
            \node[v] (u) [left=2.1cm of x] {\small $u$};
            \draw[e] (u) -- node[midway, above, sloped] {\scriptsize $7-5=2$} (x);
        \end{tikzpicture}
        \vspace{2pt}
        \small (b) Depois: $(u\!\to\!x_C)$ recebe custo reduzido $c'(u,x_C)=7-5=2$.
    \end{minipage}
    \caption{Ajuste de custo reduzido para um arco \emph{entrando} em $C$. Para $(u,w)$ com $w\in C$, define-se $c'(u,x_C)=c(u,w)-c(a_w)$, onde $a_w$ é o arco mais barato que entra em $w$. No exemplo, $c'(u,x_C)=7-5=2$.}
    \label{fig:chu-liu-reduced-cost}
\end{figure}

Para cada arco \((u,w)\) com \(w\in C\), ajustamos o custo reduzido para \(c'(u,x_C)=c(u,w)-c(a_w)\), onde \(a_w\) é o arco mais barato que entra em \(w\). No exemplo da Figura \ref{fig:chu-liu-reduced-cost}, o arco \((u,b)\) com custo \(7\) torna-se \((u,x_C)\) com custo reduzido \(7-5=2\), já que \(a_b=(a\to b)\) tem custo \(5\). Arcos que saem de \(C\) ou laços internos não são ajustados.

\subsection{Descrição do algoritmo}

\paragraph{}
Em computação falamos em linguagem de alto nível quando uma linguagem de programação é próxima da linguagem humana, com abstrações que facilitam o entendimento. Em contraste, linguagens de baixo nível são mais próximas do código de máquina, exigindo detalhes explícitos. 

\paragraph{}
Podemos falar também em visão operacional de alto nível quando descrevemos um algoritmo focando na lógica e nos passos principais, sem entrar em detalhes de implementação específicos.

\paragraph{}
Aqui, apresentamos o algoritmo de Chu–Liu/Edmonds em uma visão operacional de alto nível, focando na lógica e nos passos principais, sem entrar em detalhes de implementação específicos. E dedicaremos a próxima subseção apenas para discutir detalhes práticos de implementação.

\paragraph{Visão Operacional - Chu–Liu/Edmonds}
\paragraph{}
Denotamos por \(A'\) o conjunto de arcos escolhidos na construção da r-arborescência. 

\paragraph{}
Construa \(A'\) escolhendo, para cada \(v\neq r\), um arco de menor custo que \emph{entra} em \(v\). Se \((V,A')\) é acíclico, então, pela caracterização de arborescências (grau de entrada 1 para todo \(v\neq r\) e ausência de ciclos), \(A'\) já é uma r‑arborescência; e é \emph{ótima}, pois realizamos o menor custo de entrada em cada vértice e nenhuma troca pode reduzir o custo mantendo as restrições \cite[Sec.~4.9]{kleinberg2006}. 

\paragraph{}
Se \(A'\) contiver um ciclo dirigido \(C\) (que não inclui \(r\)), normalizamos os custos de entrada (custos reduzidos) e \emph{contraímos} \(C\) em um supervértice \(x_C\), ajustando apenas arcos que \emph{entram} em \(C\) por \(c'(u,x_C)=c(u,w)-c(a_w)\). 

\paragraph{}
Resolvemos recursivamente no grafo contraído. As arborescências do grafo contraído correspondem, em bijeção, às arborescências do grafo original com exatamente um arco entrando em \(C\); como os arcos de \(C\) têm custo reduzido zero, os custos são preservados na ida e na volta. 

\begin{figure}[htbp]
    \centering
    \begin{minipage}{.47\textwidth}
        \centering
        \begin{tikzpicture}[>=Latex]
            % styles
            	\tikzset{
                vertex/.style={circle,draw,fill=white,inner sep=1pt,font=\small},
                sel/.style={-Latex,very thick,green!60!black},
                zero/.style={-Latex,very thick,blue!70},
                ext/.style={-Latex,dashed,gray},
                normal/.style={-Latex,thin}
            }
            % nodes (contracted graph)
            \node[vertex] (r) at (-0.1,1.2) {$r$};
            \node[vertex] (u) at (-0.9,0.0) {$u$};
            \node[vertex,very thick] (x) at (0.8,0.0) {$x_C$};
            \node[vertex] (v) at (2.2,0.0) {$v$};
            % arcs
            \draw[sel]   (u) to[bend left=8] (x);       % chosen arc entering x_C
            \draw[normal](x) to[bend left=8] (v);       % some outgoing from x_C
            \draw[ext]   (r) to[bend left=15] (x);      % optional from r
            \draw[ext]   (r) to[bend left=12] (u);
        \end{tikzpicture}
        \\[2pt]
        \small (a) Grafo contraído: arborescência com um único arco entrando em $x_C$.
    \end{minipage}\hfill
    \begin{minipage}{.47\textwidth}
        \centering
        \begin{tikzpicture}[>=Latex]
            % styles
            	\tikzset{
                vertex/.style={circle,draw,fill=white,inner sep=1pt,font=\small},
                sel/.style={-Latex,very thick,green!60!black},
                zero/.style={-Latex,very thick,blue!70},
                ext/.style={-Latex,dashed,gray},
                normal/.style={-Latex,thin}
            }
            % nodes (expanded original graph)
            \node[vertex] (r2) at (-0.1,1.2) {$r$};
            \node[vertex] (u2) at (-0.9,0.0) {$u$};
            \node[vertex] (a)  at (0.6,0.1) {$a$};
            \node[vertex] (b)  at (1.4,0.3) {$b$};
            \node[vertex] (c)  at (1.0,-0.5) {$c$};
            \node[vertex] (v2) at (2.4,0.0) {$v$};
            % cycle C with zero reduced cost arcs
            \draw[zero] (a) -- (b);
            \draw[zero] (b) -- (c);
            \draw[zero] (c) -- (a);
            % chosen entering arc to some w in C (e.g., u -> b)
            \draw[sel] (u2) to[bend left=8] (b);
            % an outgoing arc from C
            \draw[normal] (c) to[bend left=8] (v2);
            % mark one internal arc to be removed when expanding (break cycle)
            \path (b) -- (c) node[pos=0.5] (mid) {};
            \node[red] at (mid) {$\times$};
            % optional external arcs
            \draw[ext] (r2) to[bend left=12] (a);
            \draw[ext] (r2) to[bend right=12] (u2);
        \end{tikzpicture}
        \\[2pt]
        \small (b) Grafo original: expansão de $C$; mantém-se o arco que entra em $C$ e remove-se um arco interno para quebrar o ciclo.
    \end{minipage}
    \caption{Bijeção entre arborescências após contração e no grafo original. (a) No grafo contraído, toda arborescência seleciona exatamente um arco que entra no supervértice $x_C$. (b) Ao expandir $C$, escolhe-se o arco correspondente \((u,w)\) que entra em algum $w\in C$ e mantêm-se os arcos internos de custo reduzido zero, removendo exatamente um para quebrar o ciclo. Como $c'(u,x_C)=c(u,w)-c(a_w)$ e os arcos internos têm custo reduzido zero, o custo total é preservado na ida e na volta.}
    \label{fig:chu-liu-bijection}
\end{figure}

\paragraph{}
A Figura \ref{fig:chu-liu-bijection} ilustra a bijeção entre arborescências no grafo contraído e no grafo original, destacando a preservação de custos e a manutenção das propriedades estruturais necessárias.

\paragraph{}
Na expansão, reintroduzimos \(C\) e removemos exatamente um arco interno para manter grau de entrada 1 e aciclicidade global \cite{schrijver2003comb,kleinberg2006}.

\begin{figure}[htbp]
    \centering
    % Panel (a): contracted graph just before expansion
    \begin{minipage}{.31\textwidth}
        \centering
        \begin{tikzpicture}[>=Latex]
            	\tikzset{
                vertex/.style={circle,draw,fill=white,inner sep=1pt,font=\small},
                sel/.style={-Latex,very thick,green!60!black},
                zero/.style={-Latex,very thick,blue!70},
                ext/.style={-Latex,dashed,gray},
                normal/.style={-Latex,thin}
            }
            \node[vertex] (r) at (-0.2,1.0) {$r$};
            \node[vertex] (u) at (-0.9,0.0) {$u$};
            \node[vertex,very thick] (x) at (0.6,0.0) {$x_C$};
            \node[vertex] (v) at (1.9,0.0) {$v$};
            \draw[sel]   (u) to[bend left=8] (x);   % chosen entering arc to x_C
            \draw[normal](x) to[bend left=8] (v);   % some outgoing arc
            \draw[ext]   (r) to[bend left=15] (x);
        \end{tikzpicture}
        \\[2pt]
        \small (a) Antes: grafo contraído com o arco que entra em $x_C$ selecionado.
    \end{minipage}\hfill
    % Panel (b): expand C, before removing an internal arc
    \begin{minipage}{.31\textwidth}
        \centering
        \begin{tikzpicture}[>=Latex]
            	\tikzset{
                vertex/.style={circle,draw,fill=white,inner sep=1pt,font=\small},
                sel/.style={-Latex,very thick,green!60!black},
                zero/.style={-Latex,very thick,blue!70},
                ext/.style={-Latex,dashed,gray},
                normal/.style={-Latex,thin}
            }
            \node[vertex] (r2) at (-0.2,1.0) {$r$};
            \node[vertex] (u2) at (-0.9,0.0) {$u$};
            \node[vertex] (a)  at (0.4,0.35) {$a$};
            \node[vertex] (b)  at (1.2,0.35) {$b$};
            \node[vertex] (c)  at (0.8,-0.4) {$c$};
            \node[vertex] (v2) at (2.2,0.0) {$v$};
            % internal cycle C with zero-reduced-cost arcs
            \draw[zero] (a) -- (b);
            \draw[zero] (b) -- (c);
            \draw[zero] (c) -- (a);
            % mapped entering arc to some w in C (e.g., u -> b)
            \draw[sel] (u2) to[bend left=8] (b);
            % an outgoing arc from C
            \draw[normal] (c) to[bend left=8] (v2);
            % optional external arc from r
            \draw[ext] (r2) to[bend left=12] (a);
        \end{tikzpicture}
        \\[2pt]
        \small (b) Expansão: $x_C$ é substituído por $C$, mantendo o arco que entra em $C$.
    \end{minipage}\hfill
    % Panel (c): remove one internal arc to break the cycle
    \begin{minipage}{.31\textwidth}
        \centering
        \begin{tikzpicture}[>=Latex]
            	\tikzset{
                vertex/.style={circle,draw,fill=white,inner sep=1pt,font=\small},
                sel/.style={-Latex,very thick,green!60!black},
                zero/.style={-Latex,very thick,blue!70},
                ext/.style={-Latex,dashed,gray},
                normal/.style={-Latex,thin}
            }
            \node[vertex] (u3) at (-0.9,0.0) {$u$};
            \node[vertex] (a3)  at (0.4,0.35) {$a$};
            \node[vertex] (b3)  at (1.2,0.35) {$b$};
            \node[vertex] (c3)  at (0.8,-0.4) {$c$};
            \node[vertex] (v3) at (2.2,0.0) {$v$};
            % keep entering arc and one outgoing
            \draw[sel]   (u3) to[bend left=8] (b3);
            \draw[normal](c3) to[bend left=8] (v3);
            % keep two internal zero-cost arcs and remove one (b->c removed)
            \draw[zero] (a3) -- (b3);
            % removed arc visual: faded/dashed with cross
            \draw[ext] (b3) -- (c3);
            \path (b3) -- (c3) node[pos=0.5] (mid) {};
            \node[red] at (mid) {$\times$};
            \draw[zero] (c3) -- (a3);
        \end{tikzpicture}
        \\[2pt]
        \small (c) Final: remove-se um arco interno de $C$ para quebrar o ciclo (mantendo grau de entrada 1).
    \end{minipage}
    \caption{Reexpansão de $C$. (a) No grafo contraído, seleciona-se um único arco que entra em $x_C$. (b) Ao expandir, $x_C$ é substituído pelo ciclo $C$ e o arco selecionado passa a entrar em algum $w\in C$. (c) Remove-se exatamente um arco interno de $C$ para eliminar o ciclo, preservando conectividade a partir de $r$ e o custo total, pois os arcos internos têm custo reduzido zero.}
    \label{fig:chu-liu-reexpansion}
\end{figure}

\paragraph{}
A Figura \ref{fig:chu-liu-reexpansion} detalha o processo de expansão e remoção de um arco interno para quebrar o ciclo, garantindo que a estrutura de r-arborescência seja mantida.

\paragraph{}
Abaixo, temos a descrição formal do algoritmo.
\paragraph{}
\begin{algobox}{Chu–Liu/Edmonds (visão operacional)}{chu-liu-edmonds}
Entrada: dígrafo \(D=(V,A)\), custos \(c:A\to\mathbb{R}_{\ge 0}\), raiz \(r\).\footnote{Se algum \(v\neq r\) não possui arco de entrada, não existe r‑arborescência.}
\begin{enumerate}\setlength{\itemsep}{2pt}
    \item Para cada \(v\neq r\), escolha \(a_v\in\operatorname*{argmin}_{(u,v)\in A} c(u,v)\). Defina \(y(v):=c(a_v)\) e \(F^*:=\{a_v: v\neq r\}.\)
    \item Se \((V,F^*)\) é acíclico, devolva \(F^*\). Por \cite[Obs.~4.36]{kleinberg2006}, trata‑se de uma r‑arborescência de custo mínimo.
    \item Caso contrário, seja \(C\) um ciclo dirigido de \(F^*\) (com \(r\notin C\)). \textbf{Contração:} contraia \(C\) em um supervértice \(x_C\) e defina custos \(c'\) por
    \begin{align*}
        c'(u,x_C) &:= c(u,w) - y(w) = c(u,w) - c(a_w) && \text{para } u\notin C,\ w\in C, \\
        c'(x_C,v) &:= c(w,v) && \text{para } w\in C,\ v\notin C,
    \end{align*}
    descartando laços em \(x_C\) e permitindo paralelos. Denote o dígrafo contraído por \(D'=(V',A')\).
    \item \textbf{Recursão:} compute uma r‑arborescência ótima \(T'\) de \(D'\) com custos \(c'\).
    \item \textbf{Expansão:} seja \((u,x_C)\in T'\) o único arco que entra em \(x_C\). No grafo original, ele corresponde a \((u,w)\) com \(w\in C\). Forme
    \[
        T := \bigl(T'\setminus\{\text{arcos incidentes a } x_C\}\bigr)\ \cup\ \{(u,w)\}\ \cup\ \bigl((F^*\cap A(C))\setminus\{a_w\}\bigr).
    \]
    Então \(T\) tem grau de entrada 1 em cada \(v\neq r\), é acíclico e tem o mesmo custo de \(T'\); logo, é uma r‑arborescência ótima de \(D\) \cite[Sec.~4.9]{kleinberg2006,schrijver2003comb}.
\end{enumerate}
\end{algobox}

\paragraph{Corretude}
\begin{enumerate}\setlength{\itemsep}{2pt}
    \item \emph{Normalização por custos reduzidos.} Para cada \(v\neq r\), defina \(y(v):=\min\{c(u,v):(u,v)\in A\}\) e \(c'(u,v):=c(u,v)-y(v)\). Para qualquer r‑arborescência \(T\), vale
    \[
        \sum_{a\in T} c'(a) \,=\, \sum_{a\in T} c(a) \, - \, \sum_{v\neq r} y(v),
    \]
    pois há exatamente um arco de \(T\) entrando em cada \(v\neq r\). O termo \(\sum_{v\neq r} y(v)\) é constante (independe de \(T\)); assim, minimizar \(\sum c\) equivale a minimizar \(\sum c'\) \cite[Obs.~4.37]{kleinberg2006}. Em particular, os arcos \(a_v\) de menor custo que entram em \(v\) têm custo reduzido zero e formam \(F^*\).
    \item \emph{Caso acíclico.} Se \((V,F^*)\) é acíclico, então já é uma r‑arborescência e, por realizar o mínimo custo de entrada em cada \(v\neq r\), é ótima \cite[Obs.~4.36]{kleinberg2006}.
    \item \emph{Caso com ciclo (contração/expansão).} Se \(F^*\) contém um ciclo dirigido \(C\), todos os seus arcos têm custo reduzido zero. Contraia \(C\) em \(x_C\) e ajuste apenas arcos que \emph{entram} em \(C\): \(c'(u,x_C):=c(u,w)-y(w)=c(u,w)-c(a_w)\). Resolva o problema no grafo contraído \(D'\), obtendo uma r‑arborescência ótima \(T'\) sob \(c'\). Na expansão, substitua o arco \((u,x_C)\in T'\) pelo correspondente \((u,w)\) (com \(w\in C\)) e remova \(a_w\) de \(C\). Como os arcos de \(C\) têm custo reduzido zero e \(c'(u,x_C)=c(u,w)-y(w)\), a soma dos custos reduzidos é preservada na ida e na volta; logo, \(T'\) ótimo em \(D'\) mapeia para \(T\) ótimo em \(D\) para \(c'\). Pela equivalência entre \(c\) e \(c'\), \(T\) também é ótimo para \(c\). Repetindo o argumento a cada contração, obtemos a corretude por indução \cite[Sec.~4.9]{kleinberg2006,schrijver2003comb}.
\end{enumerate}
Em termos intuitivos, \(y\) funciona como um potencial nos vértices: torna “apertados” (custo reduzido zero) os candidatos corretos; ciclos de arcos apertados podem ser contraídos sem perder otimalidade.

\paragraph{Complexidade}
\paragraph{}
Na implementação direta, selecionar os \(a_v\), detectar/contrair ciclos e atualizar estruturas custa \(O(m)\) por nível; como o número de vértices decresce a cada contração, temos no máximo \(O(n)\) níveis e tempo total \(O(mn)\), com \(n=|V|\), \(m=|A|\).


\paragraph{}
O uso de memória é \(O(m+n)\), incluindo mapeamentos de contração/expansão e as filas de prioridade dos arcos de entrada.

\paragraph{}
A implementação a seguir adota a versão \(O(mn)\) por simplicidade.

\subsection{Implementação em Python}

\paragraph{}
Esta seção apresenta uma implementação em Python do algoritmo de Chu–Liu/Edmonds, baseada no código do trabalho. A arquitetura segue os passos teóricos:

\begin{itemize}\setlength{\itemsep}{2pt}
    \item seleção dos arcos de menor custo que entram em cada vértice (formação de \(F^*\));
    \item verificação de aciclicidade (se acíclico, retorno imediato);
    \item se houver ciclo, normalização dos custos por vértice (custos reduzidos);
    \item construção do grafo funcional \(F^*\) com arcos de custo reduzido zero;
    \item detecção de ciclo em \(F^*\);
    \item contração do ciclo em um supervértice, com ajuste de custos;
    \item recursão no grafo contraído;
    \item expansão do ciclo e remoção de um arco interno para quebrar o ciclo.
    \item retorno da r‑arborescência ótima.
\end{itemize}

\paragraph{Especificação da interface (entradas, saídas e hipóteses)}

\begin{itemize}\setlength{\itemsep}{2pt}
    \item \textbf{Entrada:} dígrafo ponderado \(D=(V,A)\), custos \(c:A\to\mathbb{R}\), raiz \(r\in V\).
    \item \textbf{Hipóteses:}
        \begin{itemize}\setlength{\itemsep}{2pt}
            \item \(D\) é representado como um objeto \texttt{networkx.DiGraph}, com pesos armazenados no atributo de arestas \texttt{'w'}.
            \item \(D\) é conexo a partir de \(r\):
            \item (i) todo \(v\neq r\) é alcançável a partir de \(r\) (caso contrário, não há r‑arborescência); (ii) para todo subconjunto não vazio \(X\subseteq V\setminus\{r\}\), existe ao menos um arco que entra em \(X\) (\(\delta^-(X)\neq\emptyset\); condições clássicas de existência \`a la Edmonds \cite{schrijver2003comb}).
            \item Os custos são não negativos: \(c(a)\ge 0\) para todo \(a\in A\).
        \end{itemize}
    \item \textbf{Saída:} conjunto \(A^*\subseteq A\) com \(|A^*|=|V|-1\), tal que cada \(v\neq r\) tem grau de entrada 1, todos os vértices são alcançáveis a partir de \(r\) e \(\sum_{a\in A^*} c(a)\) é mínimo.
    \item \textbf{Convenções:} arcos paralelos (múltiplos arcos entre o mesmo par de vértices) são permitidos após contrações; laços (self‑loops) são descartados.
\end{itemize}


\subsubsection{Funções principais}

\paragraph{}
O código a seguir implementa o algoritmo de Chu–Liu/Edmonds em Python, utilizando a biblioteca NetworkX para manipulação de grafos. A implementação segue a estrutura descrita na seção anterior, com funções auxiliares para cada etapa do algoritmo.

\paragraph{}
A seguir, detalhamos as funções auxiliares e as principais para implementação, começando pela normalização dos custos por vértice.

\paragraph{Normalização por vértice}
Para um vértice alvo $v$, a função normaliza os custos das arestas que \emph{entram} em $v$: calcula $y(v)=\min\{w(u,v)\}$ e substitui cada peso $w(u,v)$ por $w(u,v)-y(v)$. Com isso, ao menos uma entrada em $v$ passa a ter custo reduzido zero e a ordem relativa entre as entradas é preservada. A rotina modifica o grafo \emph{in-place} e executa em $O(\deg^-(v))$.

\begin{pybox}{Normalização por vértice: custos reduzidos}
def normalize_incoming_edge_weights(D: nx.DiGraph, node: str, lang="pt"):
    """
    Change the weights of incoming edges into the `node`
    by subtracting the minimum incoming weight from each in the Graph G.

    Parameters:
        - D: A directed graph (networkx.DiGraph)
        - node: The target node whose incoming edges will be adjusted
        - lang: Language for error messages ("en" for English, "pt" for Portuguese)

    Returns:
        - Nothing (the graph G is modified in place)
    """

    if lang == "en":
        assert (
            node in D
        ), f"\nnormalize_incoming_edge_weights: The vertex '{node}' does not exist in the graph."
    elif lang == "pt":
        assert (
            node in D
        ), f"\nnormalize_incoming_edge_weights: O vértice '{node}' não existe no grafo."

    # Get the incoming edges of the node with their weights
    predecessors = list(D.in_edges(node, data="w"))

    if not predecessors:
        return

    # Calculate the minimum weight among the incoming edges
    yv = min((w for _, _, w in predecessors))

    # Subtract Yv from each incoming edge
    for u, _, _ in predecessors:
        D[u][node]["w"] -= yv
\end{pybox}

\paragraph{Construção de \(F^*\)}
A função constrói o grafo funcional \(F^*\) escolhendo, para cada vértice \(v\neq r_0\), um arco de custo reduzido zero que entra em \(v\). Se não houver arco de custo zero, escolhe o de menor custo (fallback). A função retorna um novo dígrafo representando \(F^*\).

\begin{pybox}{Construção de $F^*$ (grafo funcional)}
def get_Fstar(D: nx.DiGraph, r0: str, lang="pt"):
    """
    Creates the set F_star from graph G and root r0.
    An returns a directed graph F_star.

    Parameters:
        - D: A directed graph (networkx.DiGraph)
        - r0: The root node
        - lang: Language for error messages ("en" for English, "pt" for Portuguese)

    Returns:
        - F_star: A directed graph (networkx.DiGraph) representing F*
    """

    if lang == "en":
        assert (
            r0 in D
        ), f"\nget_Fstar: The root vertex '{r0}' does not exist in the graph."
    elif lang == "pt":
        assert r0 in D, f"\nget_Fstar: O vértice raiz '{r0}' não existe no grafo."

    # Create an empty directed graph for F_star
    F_star = nx.DiGraph()

    for v in D.nodes():
        if v != r0:
            in_edges = list(D.in_edges(v, data="w"))
            if not in_edges:
                continue  # No edges entering v
            u = next((u for u, _, w in in_edges if w == 0), None)
            if u:
                F_star.add_edge(u, v, w=0)
    return F_star
\end{pybox}

\paragraph{Detecção de ciclo}
A função detecta um ciclo dirigido em \(F^*\) (se existir) e retorna um subgrafo contendo o ciclo. Caso contrário, retorna None. A função utiliza a função \texttt{find\_cycle} do NetworkX, que implementa um algoritmo eficiente de detecção de ciclos. A função executa em \(O(m)\).

\begin{pybox}{Detecção de ciclo dirigido em $F^*$}
def find_cycle(F_star: nx.DiGraph):
    """
    Finds a directed cycle in the graph.
    Returns a subgraph containing the cycle, or None if there is none.

    Parameters:
        - F_star: A directed graph (networkx.DiGraph)

    Returns:
        - A directed graph (networkx.DiGraph) representing the cycle, or None if no cycle is found.
    """

    try:
        nodes_in_cycle = set()
        # Extract nodes involved in the cycle
        for u, v, _ in nx.find_cycle(F_star, orientation="original"):
            nodes_in_cycle.update([u, v])
        # Create a subgraph containing only the cycle
        return F_star.subgraph(nodes_in_cycle).copy()

    except nx.NetworkXNoCycle:
        return None
\end{pybox}

\paragraph{Contração de ciclo}
A função contrai um ciclo \(C\) em um supervértice \(x_C\), ajustando os arcos que entram e saem de \(C\) conforme os custos reduzidos. Retorna o grafo modificado, além de dicionários que mapeiam os arcos que entram e saem do ciclo. A função modifica o grafo \emph{in-place} e executa em \(O(m)\).

\begin{pybox}{Contração de ciclo}
def contract_cycle(D: nx.DiGraph, C: nx.DiGraph, label: str, lang="pt"):
    """
    Contract a cycle C in graph G, replacing it with a supernode labeled `label`.
    Returns the modified graph G' with the contracted cycle, the list of incoming edges (in_edge), and outgoing edges (out_edge).

    Parameters:
        - D: A directed graph (networkx.DiGraph)
        - C: A directed graph (networkx.DiGraph) representing the cycle to be contracted
        - label: The label for the new supernode
        - lang: Language for error messages ("en" for English, "pt" for Portuguese)

    Returns:
        - in_to_cycle: A dictionary mapping nodes outside the cycle to tuples (node_in_cycle, weight)
        - out_from_cycle: A dictionary mapping nodes outside the cycle to tuples (node_in_cycle, weight)
    """

    if lang == "en":
        assert (
            label not in D
        ), f"\ncontract_cycle: The label '{label}' already exists as a vertex in G."
    elif lang == "pt":
        assert (
            label not in D
        ), f"\ncontract_cycle: O rótulo '{label}' já existe como vértice em G."

    cycle_nodes: set[str] = set(C.nodes())

    # Stores the vertex u outside the cycle and the vertex v inside the cycle that receives the minimum weight edge
    in_to_cycle: dict[str, tuple[str, float]] = {}

    for u in D.nodes:
        if u not in cycle_nodes:
            # Find the minimum weight edge that u has to any vertex in C
            min_weight_edge_to_cycle = min(
                ((v, w) for _, v, w in D.out_edges(u, data="w") if v in cycle_nodes),
                key=lambda x: x[1],
                default=None,
            )
            if min_weight_edge_to_cycle:
                in_to_cycle[u] = min_weight_edge_to_cycle

    for u, (v, w) in in_to_cycle.items():
        D.add_edge(u, label, w=w)

    # Stores the vertex v outside the cycle that receives the minimum weight edge from a vertex u inside the cycle
    out_from_cycle: dict[str, tuple[str, float]] = {}

    for v in D.nodes:
        if v not in cycle_nodes:
            # Find the minimum weight edge that v receives from any vertex in C
            min_weight_edge_from_cycle = min(
                ((u, w) for u, _, w in D.in_edges(v, data="w") if u in cycle_nodes),
                key=lambda x: x[1],
                default=None,
            )
            if min_weight_edge_from_cycle:
                out_from_cycle[v] = min_weight_edge_from_cycle

    for v, (u, w) in out_from_cycle.items():
        D.add_edge(label, v, w=w)

    # Remove all nodes in the cycle from G
    D.remove_nodes_from(cycle_nodes)

    return in_to_cycle, out_from_cycle
\end{pybox}

\paragraph{Remoção de arestas que entram na raiz}
A função remove todas as arestas que entram no vértice raiz \(r_0\) do grafo \(G\). A função modifica o grafo \emph{in-place} e executa em \(O(\deg^-(r_0))\). 

\begin{pybox}{Remoção de arestas que entram na raiz}
def remove_edges_to_r0(
    D: nx.DiGraph, r0: str, log=None, boilerplate: bool = True, lang="pt"
):
    """
    Remove all edges entering the root vertex r0 in graph G.
    Returns the updated graph.

    Parameters:
        - D: A directed graph (networkx.DiGraph)
        - r0: The root node
        - log: Optional logging function to log information
        - boilerplate: If True, enables logging
        - lang: Language for logging messages ("en" for English, "pt" for Portuguese

    Returns:
        - D: The updated directed graph (networkx.DiGraph) with edges to r0 removed
    """

    # Verify that r0 exists in G
    if lang == "en":
        assert (
            r0 in D
        ), f"\nremove_edges_to_r0: The root vertex '{r0}' does not exist in the graph."
    elif lang == "pt":
        assert (
            r0 in D
        ), f"\nremove_edges_to_r0: O vértice raiz '{r0}' não existe no grafo."

    # Remove all edges entering r0
    in_edges = list(D.in_edges(r0))
    if not in_edges:
        if boilerplate and log:
            if lang == "en":
                log(f"\nremove_edges_to_r0: No edges entering '{r0}' to remove.")
            elif lang == "pt":
                log(
                    f"\nremove_edges_to_r0: Nenhuma aresta entrando em '{r0}' para remover."
                )
    else:
        D.remove_edges_from(in_edges)
        if boilerplate and log:
            if lang == "en":
                log(
                    f"\nremove_edges_to_r0: Removed {len(in_edges)} edges entering '{r0}'."
                )
            elif lang == "pt":
                log(
                    f"\nremove_edges_to_r0: Removidas {len(in_edges)} arestas entrando em '{r0}'."
                )
    return D
\end{pybox}

\paragraph{Remoção de arco interno}
Ao expandir o ciclo \(C\), a função remove o arco interno que entra no vértice de entrada \(v\) do ciclo, já que \(v\) agora recebe um arco externo do grafo. A função modifica o subgrafo do ciclo \emph{in-place} e executa em \(O(\deg^-(v))\).

\begin{pybox}{Remover arco interno na reexpansão}
def remove_internal_edge_to_cycle_entry(C: nx.DiGraph, v):
    """
    Remove the internal edge entering the entry vertex `v` from cycle C,
    since `v` now receives an external edge from the graph.

    Parameters:
        - C: subgraph of the cycle
        - external_entry_edge: tuple (u, v, w) — external edge connecting to the cycle

    Returns:
        - The modified cycle (with one less edge)
    """

    predecessor = next((u for u, _ in C.in_edges(v)), None)

    C.remove_edge(predecessor, v)
\end{pybox}

\paragraph{Procedimento principal (recursivo)}
A função principal implementa o algoritmo de Chu–Liu/Edmonds de forma recursiva e atua como um orquestrador das fases do método. Em alto nível, ela mantém a seguinte lógica: (i) prepara a instância (opcionalmente removendo entradas em \(r_0\) e emitindo logs), (ii) normaliza, para cada \(v\neq r_0\), os custos das arestas que \emph{entram} em \(v\) para induzir pelo menos uma entrada de custo reduzido zero, (iii) constrói o grafo funcional \(F^*\) selecionando, para cada \(v\neq r_0\), uma única entrada de menor custo reduzido (preferencialmente zero), (iv) verifica aciclicidade de \(F^*\); se acíclico, devolve \(F^*\) como r‑arborescência, e (v) caso haja ciclo, contrai o ciclo em um supervértice, ajusta custos que \emph{entram} no componente contraído e chama‑se recursivamente na instância reduzida; ao retornar, expande o componente e remove exatamente uma aresta interna do ciclo para restaurar grau de entrada igual a 1 e aciclicidade.

Mais especificamente, o procedimento garante as seguintes propriedades e passos:
\begin{itemize}\setlength{\itemsep}{2pt}
    \item \textbf{Contrato (entradas/saídas).} Entrada: dígrafo ponderado \(D=(V,A)\), raiz \(r_0\), e, opcionalmente, funções \texttt{draw\_fn} e \texttt{log} para visualização e registro. Saída: um subdígrafo dirigido \(T\) de \(D\) com \(|V|-1\) arcos em que todo \(v\neq r_0\) tem grau de entrada 1, todos os vértices alcançam \(r_0\) e o custo total \(\sum_{a\in T} c(a)\) é mínimo.
    \item \textbf{Invariantes.} Após a normalização por vértice, cada \(v\neq r_0\) tem pelo menos uma entrada de custo reduzido zero; o conjunto \(F^*\) contém exatamente uma entrada por vértice distinto de \(r_0\); em toda contração, apenas arcos que \emph{entram} no componente têm seus custos reduzidos ajustados por \(c'(u,x_C)=c(u,w)-c(a_w)\), preservando comparações relativas.
    \item \textbf{Detecção de ciclo e contração.} Se \(F^*\) contém um ciclo \(C\), todos os seus arcos têm custo reduzido zero. O procedimento forma o supervértice \(x_C\), reescreve arcos incidentes (descarta laços internos) e prossegue na instância menor. Essa etapa pode manter arcos paralelos e ignora laços.
    \item \textbf{Recursão e expansão.} Ao obter \(T'\) ótimo no grafo contraído, o método mapeia \(T'\) de volta para \(D\): substitui o arco \((u,x_C)\) por um \((u,w)\) apropriado (com \(w\in C\)) e remove uma única aresta interna de \(C\), restaurando a propriedade “uma entrada por vértice” e a aciclicidade.
    \item \textbf{Empates e robustez.} Empates de custo são resolvidos de modo determinístico/local, sem afetar a otimalidade. Arcos paralelos podem surgir após contrações e são tratados normalmente; laços são descartados por construção.
    \item \textbf{Logs e desenho (opcionais).} Se fornecidos, \texttt{log} recebe mensagens estruturadas por nível de recursão, e \texttt{draw\_fn} pode ser chamado para ilustrar passos relevantes (normalização, detecção/contração de ciclos, retorno da recursão e expansão).
    \item \textbf{Casos‑limite.} Se algum \(v\neq r_0\) não possui arco de entrada na instância corrente, detecta‑se inviabilidade (não existe r‑arborescência). Se \(F^*\) já é acíclico, retorna imediatamente (base da recursão).
    \item \textbf{Complexidade.} Em uma implementação direta, cada nível de recursão executa seleção/checagem/ajustes em tempo proporcional a \(O(m)\), e há no máximo \(O(n)\) níveis devido às contrações, totalizando \(O(mn)\) e memória \(O(m+n)\).
\end{itemize}

Essa rotina encapsula, portanto, a estratégia primal do método: induzir arestas de custo reduzido zero por normalização local, extrair uma estrutura funcional \(F^*\) de uma entrada por vértice, e resolver conflitos cíclicos por contração/expansão, preservando custos e correção em todas as etapas.

\begin{pybox}{Procedimento principal (recursivo)}
def find_optimum_arborescence_chuliu(
    D: nx.DiGraph,
    r0: str,
    level=0,
    draw_fn=None,
    log=None,
    boilerplate: bool = True,
    lang="pt",
):
    """
    Finds the optimum arborescence in a directed graph G with root r0 using the Chu-Liu/Edmonds algorithm.

    Parameters:
        - D: A directed graph (networkx.DiGraph)
        - r0: The root node
        - level: The current recursion level (used for logging and visualization)
        - draw_fn: Optional function to visualize the graph at each step
        - log: Optional logging function to log information
        - boilerplate: If True, enables logging and visualization
        - lang: Language for logging messages ("en" for English, "pt" for Portuguese

    Returns:
        - A directed graph (networkx.DiGraph) representing the optimum arborescence

    Raises:
        - AssertionError: If the root node r0 is not in the graph G
        - AssertionError: If no cycle is found in F_star when expected
        - AssertionError: If the contracted label already exists in the graph G
        - AssertionError: If no incoming edge is found for the contracted node in F_prime
        - AssertionError: If no vertex in the cycle is found to receive the incoming edge
        - AssertionError: If the contracted label is not found in F_prime
        - AssertionError: If vertices u or v are not found in the original graph G
    """

    indent = "  " * level

    if boilerplate and log:
        if lang == "en":
            log(f"\nfind_optimum_arborescence_chuliu:{indent}Starting level {level}")
        elif lang == "pt":
            log(f"\nfind_optimum_arborescence_chuliu:{indent}Iniciando nível {level}")

    if lang == "en":
        assert (
            r0 in D
        ), f"\nfind_optimum_arborescence_chuliu: The root vertex '{r0}' is not present in the graph."
    elif lang == "pt":
        assert (
            r0 in D
        ), f"\nfind_optimum_arborescence_chuliu: O vértice raiz '{r0}' não está presente no grafo."

    D_copy = D.copy()

    if boilerplate and log:
        if lang == "en":
            log(
                f"\nfind_optimum_arborescence_chuliu:{indent}Removing edges entering '{r0}'"
            )
        elif lang == "pt":
            log(
                f"\nfind_optimum_arborescence_chuliu:{indent}Removendo arestas que entram em '{r0}'"
            )
        if draw_fn:
            if lang == "en":
                draw_fn(
                    D_copy,
                    f"\nfind_optimum_arborescence_chuliu:{indent}After removing incoming edges",
                )
            elif lang == "pt":
                draw_fn(
                    D_copy,
                    f"\nfind_optimum_arborescence_chuliu:{indent}Após remoção de entradas",
                )

    for v in D_copy.nodes:
        if v != r0:
            normalize_incoming_edge_weights(D_copy, v, lang=lang)

        if boilerplate and log:
            if lang == "en":
                log(
                    f"\nfind_optimum_arborescence_chuliu:{indent}Normalizing weights of incoming edges to '{v}'"
                )
            elif lang == "pt":
                log(
                    f"\nfind_optimum_arborescence_chuliu:{indent}Normalizando pesos de arestas de entrada para '{v}'"
                )
            if draw_fn:
                if lang == "en":
                    draw_fn(
                        D_copy,
                        f"\nfind_optimum_arborescence_chuliu:{indent}After weight adjustment",
                    )
                elif lang == "pt":
                    draw_fn(
                        D_copy,
                        f"\nfind_optimum_arborescence_chuliu:{indent}Após ajuste de pesos",
                    )

    # Build F_star
    F_star = get_Fstar(D_copy, r0, lang=lang)

    if boilerplate and log:
        if lang == "en":
            log(f"\nfind_optimum_arborescence_chuliu:{indent}Building F_star")
        elif lang == "pt":
            log(f"\nfind_optimum_arborescence_chuliu:{indent}Construindo F_star")
        if draw_fn:
            if lang == "en":
                draw_fn(F_star, f"\nfind_optimum_arborescence_chuliu:{indent}F_star")
            elif lang == "pt":
                draw_fn(F_star, f"\nfind_optimum_arborescence_chuliu:{indent}F_star")

    if nx.is_arborescence(F_star):
        for u, v in F_star.edges:
            F_star[u][v]["w"] = D[u][v]["w"]
        return F_star

    else:
        if boilerplate and log:
            if lang == "en":
                log(
                    f"\nfind_optimum_arborescence_chuliu:{indent}F_star is not an arborescence. Continuing..."
                )
            elif lang == "pt":
                log(
                    f"\nfind_optimum_arborescence_chuliu:{indent}F_star não é uma arborescência. Continuando..."
                )

        C: nx.DiGraph = find_cycle(F_star)

        if lang == "en":
            assert C, f"\nfind_optimum_arborescence_chuliu: No cycle found in F_star."
        elif lang == "pt":
            assert (
                C
            ), f"\nfind_optimum_arborescence_chuliu: Nenhum ciclo encontrado em F_star."

        contracted_label = f"\n n*{level}"
        in_to_cycle, out_from_cycle = contract_cycle(
            D_copy, C, contracted_label, lang=lang
        )

        # Recursive call
        F_prime = find_optimum_arborescence_chuliu(
            D_copy,
            r0,
            level + 1,
            draw_fn=None,
            log=None,
            boilerplate=boilerplate,
            lang=lang,
        )

        # Identify the vertex in the cycle that received the only incoming edge from the arborescence
        in_edge = next(iter(F_prime.in_edges(contracted_label, data="w")), None)

        if lang == "en":
            assert (
                in_edge
            ), f"\nfind_optimum_arborescence_chuliu: No incoming edge found for vertex '{contracted_label}'."
        elif lang == "pt":
            assert (
                in_edge
            ), f"\nfind_optimum_arborescence_chuliu: Nenhuma aresta encontrada entrando no vértice '{contracted_label}'."

        u, _, _ = in_edge

        v, _ = in_to_cycle[u]

        if lang == "en":
            assert (
                v is not None
            ), f"\nfind_optimum_arborescence_chuliu: No vertex in the cycle found to receive the incoming edge from '{u}'."
        elif lang == "pt":
            assert (
                v is not None
            ), f"\nfind_optimum_arborescence_chuliu: Nenhum vértice do ciclo encontrado que recebeu a aresta de entrada de '{u}'."

        # Remove the internal edge entering vertex `v` from cycle C
        remove_internal_edge_to_cycle_entry(
            C, v
        )  # Note: w is coming from F_prime, not from G

        # Add the external edge entering the cycle (identified by in_edge), the weight will be corrected at the end using G
        F_prime.add_edge(u, v)
        if boilerplate and log:
            if lang == "en":
                log(
                    f"\nfind_optimum_arborescence_chuliu:{indent}Adding incoming edge to cycle: ({u}, {v})"
                )
            elif lang == "pt":
                log(
                    f"\nfind_optimum_arborescence_chuliu:{indent}Adicionando aresta de entrada ao ciclo: ({u}, {v})"
                )

        # Add the remaining edges of the modified cycle C
        for u_c, v_c in C.edges:
            F_prime.add_edge(u_c, v_c)
            if boilerplate and log:
                if lang == "en":
                    log(
                        f"\nfind_optimum_arborescence_chuliu:{indent}Adding cycle edge: ({u_c}, {v_c})"
                    )
                elif lang == "pt":
                    log(
                        f"\nfind_optimum_arborescence_chuliu:{indent}Adicionando aresta do ciclo: ({u_c}, {v_c})"
                    )

        # Add the external edges leaving the cycle
        for _, z, _ in F_prime.out_edges(contracted_label, data=True):

            if lang == "en":
                assert (
                    z in out_from_cycle
                ), f"\nfind_optimum_arborescence_chuliu: No outgoing edge found for vertex '{z}'."
            elif lang == "pt":
                assert (
                    z in out_from_cycle
                ), f"\nfind_optimum_arborescence_chuliu: Nenhuma aresta de saída encontrada para o vértice '{z}'."

            u_cycle, _ = out_from_cycle[z]
            F_prime.add_edge(u_cycle, z)

            if boilerplate and log:
                if lang == "en":
                    log(
                        f"\nfind_optimum_arborescence_chuliu:{indent}Adding outgoing edge from cycle: ({u_cycle}, {z})"
                    )
                elif lang == "pt":
                    log(
                        f"\nfind_optimum_arborescence_chuliu:{indent}Adicionando aresta externa de saída: ({u_cycle}, {z})"
                    )

        # Remove the contracted node
        if lang == "en":
            assert (
                contracted_label in F_prime
            ), f"\nfind_optimum_arborescence_chuliu: Vertex '{contracted_label}' not found in the graph."
        elif lang == "pt":
            assert (
                contracted_label in F_prime
            ), f"\nfind_optimum_arborescence_chuliu: Vértice '{contracted_label}' não encontrado no grafo."
        F_prime.remove_node(contracted_label)

        if boilerplate and log:
            if lang == "en":
                log(
                    f"\nfind_optimum_arborescence_chuliu:{indent}Contracted vertex '{contracted_label}' removed."
                )
            elif lang == "pt":
                log(
                    f"\nfind_optimum_arborescence_chuliu:{indent}Vértice contraído '{contracted_label}' removido."
                )

        # Update the edge weights with the original weights from G
        for u, v in F_prime.edges:
            if lang == "en":
                assert (
                    u in D and v in D
                ), f"\nfind_optimum_arborescence_chuliu: Vertex '{u}' or '{v}' not found in the original graph."
            elif lang == "pt":
                assert (
                    u in D and v in D
                ), f"\nfind_optimum_arborescence_chuliu: Vértice '{u}' ou '{v}' não encontrado no grafo original."
            F_prime[u][v]["w"] = D[u][v]["w"]

        if boilerplate and log:
            if lang == "en":
                log(
                    f"\n✅{indent}Final arborescence: {list(F_prime.edges)}"
                )
            elif lang == "pt":
                log(
                    f"\n✅{indent}Arborescência final: {list(F_prime.edges)}"
                )
            if draw_fn:
                if lang == "en":
                    draw_fn(
                        F_prime,
                        f"\n{indent}Final Arborescence.",
                    )
                elif lang == "pt":
                    draw_fn(
                        F_prime,
                        f"\n{indent}Arborescência final.",
                    )
        return F_prime
\end{pybox}

\paragraph{Notas finais}
Para fins didáticos, omitimos alguns detalhes operacionais (por exemplo, o preenchimento completo de \texttt{contract\_cycle} e o mapeamento das saídas na reexpansão); esses trechos seguem diretamente o código do trabalho e podem ser incorporados na íntegra quando desejado. A organização em funções corresponde exatamente às etapas teóricas descritas anteriormente, tornando transparente a relação teoria–implementação.
\begin{itemize}\setlength{\itemsep}{2pt}
    \item \(A'\) define um \emph{grafo funcional} (cada \(v\neq r\) tem exatamente um predecessor). Ciclos nesse grafo podem ser encontrados em tempo linear no tamanho de \(A'\) (por marcação/visitas com ponteiros de pai).
    \item Ao contrair um ciclo \(C\), ajuste apenas arcos que \emph{entram} em \(C\): para \((u,w)\) com \(u\notin V(C)\), \(w\in V(C)\), use o custo reduzido \(c'(u,x_C)=c(u,w)-c(a_w)\). Demais custos (inclusive os que \emph{saem} de \(C\)) permanecem inalterados; paralelos podem surgir e são mantidos, enquanto laços são removidos.
    \item Empates podem ser quebrados arbitrariamente sem afetar a otimalidade. Mantenha estruturas para: (i) rastrear \(a_v\) e \(y(v)\) (mínimo de entrada) por vértice; (ii) mapear contrações/expansões para escolher, em cada ciclo, o arco interno a remover na volta da recursão.
    \item Se algum \(v\neq r\) não possui arco de entrada, o problema é inviável (não existe r‑arborescência), detectando a violação das condições de corte.
\end{itemize}


\section{Procedimento em Duas Fases de András Frank}

\paragraph{Motivação e visão dual}
O método de \textbf{András Frank} organiza o raciocínio anterior em um \emph{esquema primal–dual em duas fases} que torna explícitos os papéis dos \emph{custos reduzidos} e dos \emph{cortes apertados} (tight cuts). Em alto nível, mantemos potenciais \(y(v)\) nos vértices e trabalhamos com custos reduzidos \(c'(u,v)=c(u,v)-y(v)\). A \textbf{Fase I} ajusta os potenciais até garantir, para cada \(v\neq r\), a existência de pelo menos um arco de custo reduzido zero que \emph{entra} em \(v\). A \textbf{Fase II} extrai dentre os arcos de custo reduzido zero uma r-arborescência, tratando ciclos por contração/expansão. Ver \cite{frank2014,schrijver2003comb}.

\paragraph{Conexão com condições de corte}
As condições clássicas de existência dizem que, para todo subconjunto não vazio \(X\subseteq V\setminus\{r\}\), deve existir ao menos um arco que entra em \(X\) (corte \(\delta^-(X)\) não vazio). No método de Frank, cortes “apertados” (aqueles cuja entrada disponível a custo reduzido é mínima) formam uma família laminar que guia as contrações, garantindo que, ao final, uma arborescência de custo mínimo emerge entre os arcos de custo reduzido zero.

\paragraph{Esqueleto do método}
\begin{enumerate}\setlength{\itemsep}{2pt}
    \item \textbf{Fase I (normalização primal–dual).} Inicialize \(y\equiv 0\). Enquanto existir \(v\neq r\) sem arco de custo reduzido zero entrando em \(v\), aumente \(y(v)\) (diminuindo \(c'(u,v)\)) até que algum arco que entra em \(v\) atinja custo reduzido zero. Se aparecer ciclo entre arcos de custo reduzido zero, contraia-o e continue.
    \item \textbf{Fase II (extração).} No grafo (possivelmente contraído), selecione uma r-arborescência usando apenas arcos de custo reduzido zero; se um ciclo surgir, contraia e prossiga. Ao término, expanda as contrações em ordem inversa, escolhendo, em cada expansão, o arco que entra no componente com custo reduzido zero para quebrar o ciclo interno.
\end{enumerate}

\begin{algobox}{Frank: método em duas fases (resumo)}{frank}
Entrada: dígrafo \(D=(V,A)\), custos \(c\), raiz \(r\).
\begin{enumerate}\setlength{\itemsep}{2pt}
    \item (Fase I) Mantenha potenciais \(y\). Enquanto existir \(v\neq r\) sem arco \((u,v)\) com \(c(u,v)-y(v)=0\), aumente \(y(v)\) até algum entrar a zero. Mantenha contrações para ciclos de zeros.
    \item (Fase II) Entre arcos de custo reduzido zero, construa uma r-arborescência; trate ciclos por contração e, no retorno, expanda escolhendo o arco que entra no componente com custo zero.
    \item Devolva a arborescência construída. Pela dualidade implícita, seu custo é mínimo.
\end{enumerate}
\end{algobox}

\paragraph{Corretude e complexidade}
Ao manter custos reduzidos e uma família laminar de cortes apertados, o método garante que sempre existe uma escolha local consistente com a otimalidade global. A análise de complexidade é alinhada à do Chu–Liu/Edmonds: implementações diretas ficam em \(O(mn)\) e versões eficientes, em \(O(m\log n)\); ver \cite{frank2014,schrijver2003comb}.

\paragraph{Quando usar}
Além de fornecer uma forma limpa de provar corretude, a abordagem de Frank é útil quando queremos evidenciar a estrutura dual (custos reduzidos, cortes apertados) ou quando estendemos o problema para variantes com restrições adicionais.
    
\section{Considerações Finais}
\clearpage
\appendix

\section{Notas sobre matroides e sua interseção}
\label{ap:matroides}
Nesta breve nota, registramos definições mínimas para dar contexto às menções a interseção de matroides no corpo do texto. Para referências e desenvolvimento completo, ver, por exemplo, Schrijver \cite{schrijver2003comb}.

Um \textbf{matroide} $M=(E,\mathcal{I})$ é dado por um conjunto finito $E$ e uma família $\mathcal{I}\subseteq 2^{E}$ de conjuntos \emph{independentes} que satisfazem: (i) $\varnothing\in\mathcal{I}$; (ii) se $I\in\mathcal{I}$ e $J\subseteq I$, então $J\in\mathcal{I}$ (hereditariedade); (iii) se $I,J\in\mathcal{I}$ e $|I|<|J|$, então existe $e\in J\setminus I$ com $I\cup\{e\}\in\mathcal{I}$ (troca).

Exemplos clássicos incluem: (a) o matroide gráfico, em que $E$ é o conjunto de arestas de um grafo e $\mathcal{I}$ são os conjuntos acíclicos; (b) o matroide de partição, que impõe no máximo uma escolha por parte; (c) o matroide linear, em que $E$ é um conjunto de vetores e $\mathcal{I}$ são subconjuntos linearmente independentes.

A \textbf{interseção de matroides} pergunta por um conjunto $X\subseteq E$ de maior cardinalidade (ou de menor custo no caso ponderado) que seja independente simultaneamente em dois matroides $M_1=(E,\mathcal{I}_1)$ e $M_2=(E,\mathcal{I}_2)$, isto é, $X\in\mathcal{I}_1\cap\mathcal{I}_2$. O problema admite algoritmos polinomiais gerais, e muitas formulações clássicas em grafos se enquadram nesse arcabouço.

No contexto de arborescências dirigidas, estruturas do tipo “no máximo um arco entrando em cada vértice” podem ser modeladas por matroides de partição, enquanto restrições que evitam ciclos dirigidos aparecem via matroide gráfico orientado e técnicas afins. Isso motiva a citação no corpo do texto quando discutimos o empacotamento de múltiplas arborescências e condições por cortes.

\bigskip
\printbibliography

\end{document}
