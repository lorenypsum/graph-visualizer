def phase2_find_minimum_arborescence_v2(
    D_original, r0, A_zero, draw_fn=None, log=None, boilerplate: bool = True, lang="pt"
):
    """
    Find the minimum arborescence in a directed graph D with root r0.
    The function returns the minimum arborescence as a DiGraph.

    Parameters:
        - D_original: directed graph (DiGraph)
        - r0: root node
        - A_zero: list of arcs (u, v) that form the minimum arborescence

    Returns:
        - Arb: directed graph (DiGraph) representing the minimum arborescence
    """
    Arb = nx.DiGraph()
    for i, (u, v) in enumerate(A_zero):
        Arb.add_edge(u, v, w=i)

    # Set of visited vertices, starting with the root
    V = {r0}

    # Priority queue to store the edges
    q = []
    for u, v, data in Arb.out_edges(r0, data=True):

        # Add edges to the priority queue with their weights
        heapq.heappush(q, (data["w"], u, v))

    A = nx.DiGraph()  # Arborescência resultante

    if boilerplate and draw_fn:
        if lang == "en":
            draw_fn(Arb, title=f"Initial arborescence with weights - Phase 2")
        elif lang == "pt":
            draw_fn(Arb, title=f"Arborescência inicial com pesos - Fase 2")

    # While the queue is not empty
    while q:
        _, u, v = heapq.heappop(q)

        if v in V:  # If the vertex has already been visited, continue
            continue

        # Add the edge to the arborescence
        A.add_edge(u, v, w=D_original[u][v]["w"])

        # Mark the vertex as visited
        V.add(v)

        # Add the outgoing edges of the visited vertex to the priority queue
        for x, y, data in Arb.out_edges(v, data=True):
            heapq.heappush(q, (data["w"], x, y))

    if boilerplate and draw_fn:
        if lang == "en":
            draw_fn(A, title=f"Final arborescence - Phase 2")
        elif lang == "pt":
            draw_fn(A, title=f"Arborescência final - Fase 2")
    # Return the resulting arborescence
    return A
