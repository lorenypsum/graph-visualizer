def contract_cycle(D: nx.DiGraph, C: nx.DiGraph, label: str, lang="pt"):
    """
    Contrai um ciclo C no grafo D, substituindo-o por um supervértice rotulado `label`.
    Modifica o grafo D no próprio lugar (in-place) e devolve dicionários auxiliares para a reexpansão.

    Parâmetros:
        - D: Um grafo direcionado (networkx.DiGraph)
        - C: Um grafo direcionado (networkx.DiGraph) que representa o ciclo a ser contraído
        - label: O rótulo do novo supervértice
        - lang: Idioma das mensagens de erro ("en" para inglês, "pt" para português)

    Retorno:
        - in_to_cycle: Dicionário que mapeia nós fora do ciclo para tuplas (no_do_ciclo, peso) das arestas que entram no ciclo após o ajuste
        - out_from_cycle: Dicionário que mapeia nós fora do ciclo para tuplas (no_do_ciclo, peso) das arestas que saem do ciclo
    """

    if lang == "en":
        assert (
            label not in D
        ), f"\ncontract_cycle: The label '{label}' already exists as a vertex in G."
    elif lang == "pt":
        assert (
            label not in D
        ), f"\ncontract_cycle: O rótulo '{label}' já existe como vértice em G."

    cycle_nodes: set[str] = set(C.nodes())

    # Stores the vertex u outside the cycle and the vertex v inside the cycle that receives the minimum weight edge
    in_to_cycle: dict[str, tuple[str, float]] = {}

    for u in D.nodes:
        if u not in cycle_nodes:
            # Find the minimum weight edge that u has to any vertex in C
            min_weight_edge_to_cycle = min(
                ((v, w) for _, v, w in D.out_edges(u, data="w") if v in cycle_nodes),
                key=lambda x: x[1],
                default=None,
            )
            if min_weight_edge_to_cycle:
                in_to_cycle[u] = min_weight_edge_to_cycle

    for u, (v, w) in in_to_cycle.items():
        D.add_edge(u, label, w=w)

    # Stores the vertex v outside the cycle that receives the minimum weight edge from a vertex u inside the cycle
    out_from_cycle: dict[str, tuple[str, float]] = {}

    for v in D.nodes:
        if v not in cycle_nodes:
            # Find the minimum weight edge that v receives from any vertex in C
            min_weight_edge_from_cycle = min(
                ((u, w) for u, _, w in D.in_edges(v, data="w") if u in cycle_nodes),
                key=lambda x: x[1],
                default=None,
            )
            if min_weight_edge_from_cycle:
                out_from_cycle[v] = min_weight_edge_from_cycle

    for v, (u, w) in out_from_cycle.items():
        D.add_edge(label, v, w=w)

    # Remove all nodes in the cycle from G
    D.remove_nodes_from(cycle_nodes)

    return in_to_cycle, out_from_cycle
