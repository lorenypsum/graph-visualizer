As we’ve seen more and more examples of greedy algorithms, we’ve come to
appreciate that there can be considerable diversity in the way they operate.
Many greedy algorithms make some sort of an initial “ordering” decision on
the input, and then process everything in a one-pass fashion. Others make
more incremental decisions—still local and opportunistic, but without a global
“plan” in advance. In this section, we consider a problem that stresses our
intuitive view of greedy algorithms still further.
The Problem
The problem is to compute a minimum-cost arborescence of a directed graph.
This is essentially an analogue of the Minimum Spanning Tree Problem for
directed, rather than undirected, graphs; we will see that the move to directed
graphs introduces significant new complications. At the same time, the style
of the algorithm has a strongly greedy flavor, since it still constructs a solution
according to a local, myopic rule.
We begin with the basic definitions. Let G=(V, E) be a directed graph in
which we’ve distinguished one node r ∈V as a root. An arborescence (with
respect to r) is essentially a directed spanning tree rooted at r. Specifically, it
is a subgraph T=(V, F) such that T is a spanning tree of G if we ignore the
direction of edges; and there is a path in T from r to each other node v ∈V if
we take the direction of edges into account. Figure 4.18 gives an example of
two different arborescences in the same directed graph.
There is a useful equivalent way to characterize arborescences, and this
is as follows.
178 Chapter 4 Greedy Algorithms
r
r
r
(a)
(b)
(c)
Figure 4.18 A directed graph can have many different arborescences. Parts (b) and (c)
depict two different aborescences, both rooted at node r, for the graph in part (a).
(4.34) A subgraph T=(V, F) of G is an arborescence with respect to root r if
and only if T has no cycles, and for each node v ̸=r, there is exactly one edge
in F that enters v.
Proof. If T is an arborescence with root r, then indeed every other node v
has exactly one edge entering it: this is simply the last edge on the unique r-v
path.
Conversely, suppose T has no cycles, and each node v ̸=r has exactly
one entering edge. In order to establish that T is an arborescence, we need
only show that there is a directed path from r to each other node v. Here is
how to construct such a path. We start at v and repeatedly follow edges in
the backward direction. Since T has no cycles, we can never return to a node
we’ve previously visited, and thus this process must terminate. But r is the
only node without incoming edges, and so the process must in fact terminate
by reaching r; the sequence of nodes thus visited yields a path (in the reverse
direction) from r to v.
It is easy to see that, just as every connected graph has a spanning tree, a
directed graph has an arborescence rooted at r provided that r can reach every
node. Indeed, in this case, the edges in a breadth-first search tree rooted at r
will form an arborescence.
(4.35) A directed graph G has an arborescence rooted at r if and only if there
is a directed path from r to each other node.
4.9 Minimum-Cost Arborescences: A Multi-Phase Greedy Algorithm 179
The basic problem we consider here is the following. We are given a
directed graph G=(V, E), with a distinguished root node r and with a non-
negative cost ce ≥0 on each edge, and we wish to compute an arborescence
rooted at r of minimum total cost. (We will refer to this as an optimal arbores-
cence.) We will assume throughout that G at least has an arborescence rooted
at r; by (4.35), this can be easily checked at the outset.
Designing the Algorithm
Given the relationship between arborescences and trees, the minimum-cost
arborescence problem certainly has a strong initial resemblance to the Mini-
mum Spanning Tree Problem for undirected graphs. Thus it’s natural to start
by asking whether the ideas we developed for that problem can be carried
over directly to this setting. For example, must the minimum-cost arbores-
cence contain the cheapest edge in the whole graph? Can we safely delete the
most expensive edge on a cycle, confident that it cannot be in the optimal
arborescence?
Clearly the cheapest edge e in G will not belong to the optimal arborescence
if e enters the root, since the arborescence we’re seeking is not supposed to
have any edges entering the root. But even if the cheapest edge in G belongs
to some arborescence rooted at r, it need not belong to the optimal one, as
the example of Figure 4.19 shows. Indeed, including the edge of cost 1 in
Figure 4.19 would prevent us from including the edge of cost 2 out of the
root r (since there can only be one entering edge per node); and this in turn
would force us to incur an unacceptable cost of 10 when we included one of
r
r
2
10 10
2
1 4
2 2
4
2 2
8 4
4
(a)
(b)
Figure 4.19 rooted at r for this graph.
(a) A directed graph with costs on its edges, and (b) an optimal arborescence
180 Chapter 4 Greedy Algorithms
the other edges out of r. This kind of argument never clouded our thinking in
the Minimum Spanning Tree Problem, where it was always safe to plunge
ahead and include the cheapest edge; it suggests that finding the optimal
arborescence may be a significantly more complicated task. (It’s worth noticing
that the optimal arborescence in Figure 4.19 also includes the most expensive
edge on a cycle; with a different construction, one can even cause the optimal
arborescence to include the most expensive edge in the whole graph.)
Despite this, it is possible to design a greedy type of algorithm for this
problem; it’s just that our myopic rule for choosing edges has to be a little
more sophisticated. First let’s consider a little more carefully what goes wrong
with the general strategy of including the cheapest edges. Here’s a particular
version of this strategy: for each node v ̸=r, select the cheapest edge entering
v (breaking ties arbitrarily), and let F∗be this set of n−1 edges. Now consider
the subgraph (V, F∗). Since we know that the optimal arborescence needs to
have exactly one edge entering each node v ̸=r, and (V, F∗) represents the
cheapest possible way of making these choices, we have the following fact.
(4.36) If (V, F∗) is an arborescence, then it is a minimum-cost arborescence.
So the difficulty is that (V, F∗) may not be an arborescence. In this case,
(4.34) implies that (V, F∗) must contain a cycle C, which does not include the
root. We now must decide how to proceed in this situation.
To make matters somewhat clearer, we begin with the following observa-
tion. Every arborescence contains exactly one edge entering each node v ̸=r;
so if we pick some node v and subtract a uniform quantity from the cost of
every edge entering v, then the total cost of every arborescence changes by
exactly the same amount. This means, essentially, that the actual cost of the
cheapest edge entering v is not important; what matters is the cost of all other
edges entering v relative to this. Thus let yv denote the minimum cost of any
edge entering v. For each edge e =(u, v), with cost ce ≥0, we define its modi-
fied cost c′
e to be ce−yv. Note that since ce ≥yv, all the modified costs are still
nonnegative. More crucially, our discussion motivates the following fact.
(4.37) T is an optimal arborescence in G subject to costs {ce}if and only if it
is an optimal arborescence subject to the modified costs {c′
e}.
Proof. Consider an arbitrary arborescence T. The difference between its cost
with costs {ce}and {c′
e}is exactly v̸=r yv—that is,
ce−
c′
e
=
yv.e∈T
e∈T
v̸=r
4.9 Minimum-Cost Arborescences: A Multi-Phase Greedy Algorithm 181
This is because an arborescence has exactly one edge entering each node v
in the sum. Since the difference between the two costs is independent of the
choice of the arborescence T, we see that T has minimum cost subject to {ce}
if and only if it has minimum cost subject to {c′
e}.
We now consider the problem in terms of the costs {c′
e}. All the edges in
our set F∗ have cost 0 under these modified costs; and so if (V, F∗) contains
a cycle C, we know that all edges in C have cost 0. This suggests that we can
afford to use as many edges from C as we want (consistent with producing an
arborescence), since including edges from C doesn’t raise the cost.
Thus our algorithm continues as follows. We contract C into a single
supernode, obtaining a smaller graph G′
=(V′
, E′). Here, V′contains the nodes
of V−C, plus a single node c∗representing C. We transform each edge e ∈E to
an edge e′∈E′by replacing each end of e that belongs to C with the new node
c∗. This can result in G′having parallel edges (i.e., edges with the same ends),
which is fine; however, we delete self-loops from E′—edges that have both
ends equal to c∗. We recursively find an optimal arborescence in this smaller
graph G′, subject to the costs {c′
e}. The arborescence returned by this recursive
call can be converted into an arborescence of G by including all but one edge
on the cycle C.
In summary, here is the full algorithm.
For each node v ̸=r
Let yv be the minimum cost of an edge entering node v
Modify the costs of all edges e entering v to c′
e
=ce−yv
Choose one 0-cost edge entering each v ̸=r, obtaining a set F∗
If F∗ forms an arborescence, then return it
Else there is a directed cycle C ⊆F∗
Contract C to a single supernode, yielding a graph G′
=(V′
, E′)
Recursively find an optimal arborescence (V′
, F′) in G′
with costs {c′
e}
Extend (V′
, F′) to an arborescence (V, F) in G
by adding all but one edge of C
Analyzing the Algorithm
It is easy to implement this algorithm so that it runs in polynomial time. But
does it lead to an optimal arborescence? Before concluding that it does, we need
to worry about the following point: not every arborescence in G corresponds to
an arborescence in the contracted graph G′. Could we perhaps “miss” the true
optimal arborescence in G by focusing on G′? What is true is the following.
182 Chapter 4 Greedy Algorithms
The arborescences of G′are in one-to-one correspondence with arborescences
of G that have exactly one edge entering the cycle C; and these corresponding
arborescences have the same cost with respect to {c′
e}, since C consists of 0-
cost edges. (We say that an edge e =(u, v) enters C if v belongs to C but u does
not.) So to prove that our algorithm finds an optimal arborescence in G, we
must prove that G has an optimal arborescence with exactly one edge entering
C. We do this now.
(4.38) Let C be a cycle in G consisting of edges of cost 0, such that r ̸∈C.
Then there is an optimal arborescence rooted at r that has exactly one edge
entering C.
Proof. Consider an optimal arborescence T in G. Since r has a path in T to
every node, there is at least one edge of T that enters C. If T enters C exactly
once, then we are done. Otherwise, suppose that T enters C more than once.
We show how to modify it to obtain an arborescence of no greater cost that
enters C exactly once.
Let e =(a, b) be an edge entering C that lies on as short a path as possible
from r; this means in particular that no edges on the path from r to a can enter
C. We delete all edges of T that enter C, except for the edge e. We add in all
edges of C except for the one edge that enters b, the head of edge e. Let T′
denote the resulting subgraph of G.
We claim that T′ is also an arborescence. This will establish the result,
since the cost of T′ is clearly no greater than that of T: the only edges of
T′ that do not also belong to T have cost 0. So why is T′ an arborescence?
Observe that T′ has exactly one edge entering each node v ̸=r, and no edge
entering r. So T′has exactly n−1 edges; hence if we can show there is an r-v
path in T′ for each v, then T′ must be connected in an undirected sense, and
hence a tree. Thus it would satisfy our initial definition of an arborescence.
So consider any node v ̸=r; we must show there is an r-v path in T′. If
v ∈C, we can use the fact that the path in T from r to e has been preserved
in the construction of T′; thus we can reach v by first reaching e and then
following the edges of the cycle C. Now suppose that v ̸∈C, and let P denote
the r-v path in T. If P did not touch C, then it still exists in T′. Otherwise,
let w be the last node in P ∩C, and let P′ be the subpath of P from w to v.
Observe that all the edges in P′ still exist in T′. We have already argued that
w is reachable from r in T′, since it belongs to C. Concatenating this path
to w with the subpath P′ gives us a path to v as well.
We can now put all the pieces together to argue that our algorithm is
correct.
Solved Exercises 183
(4.39) The algorithm finds an optimal arborescence rooted at r in G.
Proof. The proof is by induction on the number of nodes in G. If the edges
of F form an arborescence, then the algorithm returns an optimal arborescence
by (4.36). Otherwise, we consider the problem with the modified costs {c′
e},
which is equivalent by (4.37). After contracting a 0-cost cycle C to obtain a
smaller graph G′, the algorithm produces an optimal arborescence in G′by the
inductive hypothesis. Finally, by (4.38), there is an optimal arborescence in G
that corresponds to the optimal arborescence computed for G′