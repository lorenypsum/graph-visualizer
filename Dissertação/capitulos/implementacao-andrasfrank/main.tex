\chapter{Algoritmo de András Frank}

Neste capítulo, apresentaremos o algoritmo de András Frank, que também determina
uma arborescência de custo mínimo em um digrafo ponderado.
O algoritmo baseia-se em duas operações fundamentais:
(i) a redução gulosa dos custos dos arcos através da identificação de subconjuntos minimais
e (ii) a contração de ciclos, de modo a resolver recursivamente uma instância menor do
problema e, em seguida, estender a solução para o problema original.
A operação de redução é essencialmente a mesma do algoritmo de Chu--Liu--Edmonds
--- subtrair o menor custo de arco entrando em cada conjunto --- mas enquanto
Chu--Liu--Edmonds opera vértice a vértice, o algoritmo de Frank identifica
\emph{subconjuntos minimais} através de componentes fortemente conexas,
processando todos simultaneamente a cada iteração.
O propósito deste capítulo é fornecer tanto uma descrição teórica do algoritmo quanto detalhes da implementação desenvolvida neste trabalho.

\section{O algoritmo}
O algoritmo de András Frank também recebe uma tripla \((D,c,r)\), em que \(D=(V,A)\) é um digrafo,
\(c\colon A\to\mathbb{R}\) é uma função custo e \(r\in V\) é a raiz,
sob a hipótese de que \(D\) admite ao menos uma \(r\)-arborescência e devolve uma \(r\)-arborescência \(c\)-mínima de \(D\).

Assim como no capítulo anterior, adotamos a terminologia de \(r\)-digrafo ponderado para uma tripla \((D,c,r)\) em que $(D, c)$ é um digrafo ponderado,
$r$ é um vértice de $D$, $\delta^-(r) = \varnothing$
e $D$ possui uma $r$-arborescência.

Vamos desenvolver as ideias do algoritmo utilizando um exemplo que manifeste todas as
etapas do algoritmo, incluindo a formação de ciclos por arcos justos e a necessidade
de contração de componentes fortemente conexas.

Considere o dígrafo \(D\) da Figura~\ref{fig:frank-exemplo-inicial} com seis vértices
\(\{r, a, b, c, d, e\}\) e custos nos arcos cuidadosamente escolhidos para ilustrar
o comportamento completo do algoritmo.

\begin{figure}[H]
	\centering
	\begin{tikzpicture}[>=Stealth, scale=1.1]
		% estilos
		\tikzset{
			vtx/.style={circle, draw,fill=blue!8, thick, inner sep=1.2pt, minimum size=7mm},
			arc/.style={->, semithick, draw=black!50},
			costG/.style={font=\small, fill=white, inner sep=1.5pt, text=black!70}
		}

		% layout
		\node[vtx] (r) at (0,0) {$r$};
		\node[vtx] (a) at (3,2) {$a$};
		\node[vtx] (b) at (3,-2) {$b$};
		\node[vtx] (c) at (6,2) {$c$};
		\node[vtx] (d) at (6,0) {$d$};
		\node[vtx] (e) at (6,-2) {$e$};

		% arcos com custos
		\draw[arc] (r) -- node[costG, above left] {2} (a);
		\draw[arc] (r) -- node[costG, below left] {3} (b);
		\draw[arc] (r) .. controls (2,3.5) and (5,3.5) .. node[costG, above] {7} (c);

		\draw[arc] (a) -- node[costG, above] {5} (c);
		\draw[arc] (a) -- node[costG, right] {4} (d);
		\draw[arc] (b) -- node[costG, below] {2} (e);
		\draw[arc] (b) to[bend right=15] node[costG, left] {5} (a);

		\draw[arc] (c) to[bend left=15] node[costG, right] {1} (d);
		\draw[arc] (d) to[bend left=15] node[costG, left] {1} (c);
		\draw[arc] (d) -- node[costG, right] {3} (e);

		\draw[arc] (c) .. controls (7.5,2.5) and (7.5,-2.5) .. node[costG, right] {6} (e);
	\end{tikzpicture}
	\caption{Dígrafo \(D\) com custos originais. Este exemplo ilustrará todas as etapas
		do algoritmo de András Frank, incluindo formação de ciclos e contração.}
	\label{fig:frank-exemplo-inicial}
\end{figure}

O algoritmo de Frank opera em duas fases principais: (1) redução de custos e (2) construção da arborescência.

A redução de custos é feita em subconjuntos minimais, que são subconjuntos \(X \subseteq V\)
tais que não há arcos justos entrando em \(X\) (arcos com custo reduzido zero).

No início do algoritmo, nenhum arco tem custo reduzido zero. Cada vértice não-raiz forma
seu próprio subconjunto minimal. No dígrafo da Figura~\ref{fig:frank-exemplo-inicial},
os subconjuntos minimais iniciais são \(\{a\}\), \(\{b\}\), \(\{c\}\), \(\{d\}\) e \(\{e\}\).
Para cada vértice \(v \neq r\), encontramos o menor custo
\(\delta(\{v\})\) entre todos os arcos que entram em \(v\), e subtraímos esse valor de
todos esses arcos. Por exemplo, para o vértice \(a\), temos \(\delta(\{a\}) = \min\{c(r,a), c(b,a)\} = \min\{2, 5\} = 2\),
e subtraímos 2 de ambos os arcos \((r,a)\) e \((b,a)\), tornando \((r,a)\) um arco justo,
como ilustrado na Figura~\ref{fig:frank-reducao-exemplo-a}.

\begin{figure}[H]
	\centering
	\begin{tikzpicture}[>=Stealth, scale=0.95]
		\tikzset{
			vtx/.style={circle, draw,fill=blue!8, thick, inner sep=1.2pt, minimum size=7mm},
			vtxH/.style={circle, draw=orange!70, fill=orange!15, thick, inner sep=1.2pt, minimum size=8mm},
			arc/.style={->, semithick, draw=black!35},
			arcH/.style={->, ultra thick, draw=orange!70},
			tight/.style={->, very thick, draw=blue!70},
			costG/.style={font=\small, fill=white, inner sep=1.5pt, text=black!50},
			costO/.style={font=\small, fill=white, inner sep=1.5pt, text=orange!70, font=\small\bfseries},
			costB/.style={font=\small, fill=white, inner sep=1.5pt, text=blue!70}
		}

		% Antes da redução (dígrafo completo)
		\begin{scope}
			\node[font=\bfseries, above] at (3, 3.8) {Antes: custos originais};

			\node[vtx] (r1) at (0,0) {$r$};
			\node[vtxH] (a1) at (3,2) {$a$};
			\node[vtx] (b1) at (3,-2) {$b$};
			\node[vtx] (c1) at (6,2) {$c$};
			\node[vtx] (d1) at (6,0) {$d$};
			\node[vtx] (e1) at (6,-2) {$e$};

			% Arcos destacados entrando em 'a'
			\draw[arcH] (r1) -- node[costO, above left] {2} (a1);
			\draw[arcH] (b1) to[bend right=15] node[costO, left] {5} (a1);

			% Demais arcos
			\draw[arc] (r1) -- node[costG, below left] {3} (b1);
			\draw[arc] (r1) .. controls (1,3.5) and (5,3.5) .. node[costG, above] {7} (c1);
			\draw[arc] (a1) -- node[costG, above] {5} (c1);
			\draw[arc] (a1) -- node[costG, right] {4} (d1);
			\draw[arc] (b1) -- node[costG, below] {2} (e1);
			\draw[arc] (c1) to[bend left=15] node[costG, right] {1} (d1);
			\draw[arc] (d1) to[bend left=15] node[costG, left] {1} (c1);
			\draw[arc] (d1) -- node[costG, right] {3} (e1);
			\draw[arc] (c1) .. controls (7.5,2.5) and (7.5,-2.5) .. node[costG, right] {6} (e1);

			\node[orange!70, font=\small] at (3, -3.2) {$\delta(\{a\}) = \min\{2, 5\} = 2$};
		\end{scope}

		% Depois da redução (dígrafo completo)
		\begin{scope}[xshift=9.5cm]
			\node[font=\bfseries, above] at (3, 3.8) {Após redução de $\delta(\{a\})$};

			\node[vtx] (r2) at (0,0) {$r$};
			\node[vtxH] (a2) at (3,2) {$a$};
			\node[vtx] (b2) at (3,-2) {$b$};
			\node[vtx] (c2) at (6,2) {$c$};
			\node[vtx] (d2) at (6,0) {$d$};
			\node[vtx] (e2) at (6,-2) {$e$};

			% Arco justo
			\draw[tight] (r2) -- node[costB, above left] {0} (a2);
			% Arco reduzido
			\draw[arcH] (b2) to[bend right=15] node[costO, left] {3} (a2);

			% Demais arcos (custos inalterados)
			\draw[arc] (r2) -- node[costG, below left] {3} (b2);
			\draw[arc] (r2) .. controls (1,3.5) and (5,3.5) .. node[costG, above] {7} (c2);
			\draw[arc] (a2) -- node[costG, above] {5} (c2);
			\draw[arc] (a2) -- node[costG, right] {4} (d2);
			\draw[arc] (b2) -- node[costG, below] {2} (e2);
			\draw[arc] (c2) to[bend left=15] node[costG, right] {1} (d2);
			\draw[arc] (d2) to[bend left=15] node[costG, left] {1} (c2);
			\draw[arc] (d2) -- node[costG, right] {3} (e2);
			\draw[arc] (c2) .. controls (7.5,2.5) and (7.5,-2.5) .. node[costG, right] {6} (e2);

			\node[blue!70, font=\small] at (3, -3.2) {$(r,a)$ torna-se \textbf{justo} (custo 0)};
		\end{scope}
	\end{tikzpicture}
	\caption{Exemplo de redução de custo para o vértice \(a\) no dígrafo completo. À esquerda,
		os arcos entrando em \(a\) estão destacados em laranja com custos originais 2 e 5.
		Calculamos \(\delta(\{a\}) = 2\) e subtraímos esse valor de ambos os arcos. À direita,
		após a redução: \((r,a)\) tem custo zero (arco justo, em azul) e \((b,a)\) tem custo
		\(5-2=3\) (em laranja). Os demais arcos permanecem inalterados.}
	\label{fig:frank-reducao-exemplo-a}
\end{figure}

Essa operação vai sendo repetida para todos os conjuntos minimais iniciais.
A Figura~\ref{fig:frank-iter1-result} mostra o resultado dessa primeira iteração no exemplo
da Figura~\ref{fig:frank-exemplo-inicial}, onde aplicamos a redução apenas para os vértices isolados.

\begin{figure}[H]
	\centering
	\begin{tikzpicture}[>=Stealth, scale=1.1]
		\tikzset{
			vtx/.style={circle, draw,fill=blue!8, thick, inner sep=1.2pt, minimum size=7mm},
			tight/.style={->, very thick, draw=blue!70},
			loose/.style={->, semithick, draw=black!35},
			costB/.style={font=\small, fill=white, inner sep=1.5pt, text=blue!70},
			costG/.style={font=\small, fill=white, inner sep=1.5pt, text=black!50}
		}

		\node[vtx] (r) at (0,0) {$r$};
		\node[vtx] (a) at (3,2) {$a$};
		\node[vtx] (b) at (3,-2) {$b$};
		\node[vtx] (c) at (6,2) {$c$};
		\node[vtx] (d) at (6,0) {$d$};
		\node[vtx] (e) at (6,-2) {$e$};

		% arcos justos (apenas alguns)
		\draw[tight] (r) -- node[costB, above left] {0} (a);
		\draw[loose] (a) -- node[costB, above] {4} (c);
		\draw[tight] (c) to[bend left=15] node[costB, right] {0} (d);
		\draw[tight] (b) -- node[costB, below] {0} (e);

		% arcos não justos
		\draw[tight] (r) -- node[costG, below left] {0} (b);  % 3-2 = 1 (ainda não é justo!)
		\draw[loose] (r) .. controls (2,3.5) and (5,3.5) .. node[costG, above] {6} (c);  % 7-1-2 = 4
		\draw[loose] (a) -- node[costG, right] {3} (d);  % 4-2 = 2
		\draw[loose] (b) to[bend right=15] node[costG, left] {3} (a);  % 5-2 = 3
		\draw[tight] (d) to[bend left=15] node[costG, left] {0} (c);  % 1-1 = 0 (forma ciclo!)
		\draw[loose] (d) -- node[costG, right] {1} (e);  % 3-1 = 2
		\draw[loose] (c) .. controls (7.5,2.5) and (7.5,-2.5) .. node[costG, right] {4} (e);  % 6-1-2 = 3
	\end{tikzpicture}
	\caption{Dígrafo após a primeira iteração. Note que \(b\) não possui arco justo entrando
		(apenas \((r,b)\) com custo 1), e os arcos \((c,d)\) e \((d,c)\) formam um ciclo justo.
		Os vértices \(a\), \(c\), \(d\) e \(e\) possuem arcos justos entrando, mas \(b\) e o
		conjunto \(\{c,d\}\) serão identificados como minimais na próxima etapa.}
	\label{fig:frank-iter1-result}
\end{figure}

Se esses arcos de custo zero formam uma \(r\)-arborescência (sem ciclos), o algoritmo termina.
Caso contrário, os arcos de custo zero contêm ciclos. Nesse caso, calculamos as componentes
fortemente conexas do grafo formado pelos arcos de custo zero. Cada componente que não contém
a raiz e não possui arcos de custo zero entrando nela é um novo subconjunto minimal.
A Figura~\ref{fig:frank-sccs} ilustra esse processo no nosso exemplo.

\begin{figure}[H]
	\centering
	\begin{tikzpicture}[>=Stealth, scale=1.1]
		\tikzset{
			vtx/.style={circle, draw,fill=blue!8, thick, inner sep=1.2pt, minimum size=7mm},
			tight/.style={->, very thick, draw=blue!70},
			loose/.style={->, semithick, draw=black!35},
			costB/.style={font=\small, fill=white, inner sep=1.5pt, text=blue!70},
			costG/.style={font=\small, fill=white, inner sep=1.5pt, text=black!50}
		}

		\node[vtx] (r) at (0,0) {$r$};
		\node[vtx] (a) at (3,2) {$a$};
		\node[vtx] (b) at (3,-2) {$b$};
		\node[vtx] (c) at (6,2) {$c$};
		\node[vtx] (d) at (6,0) {$d$};
		\node[vtx] (e) at (6,-2) {$e$};

		% arcos justos
		\draw[tight] (r) -- node[costB, above left] {0} (a);
		\draw[tight] (a) -- node[costB, above] {0} (c);
		\draw[tight] (c) to[bend left=15] node[costB, right] {0} (d);
		\draw[tight] (b) -- node[costB, below] {0} (e);
		\draw[tight] (d) to[bend left=15] node[costB, left] {0} (c);

		% arcos não justos (mais tênues)
		\draw[loose, opacity=0.3] (r) -- node[costG, below left, opacity=0.5] {1} (b);
		\draw[loose, opacity=0.3] (r) .. controls (2,3.5) and (5,3.5) .. node[costG, above, opacity=0.5] {4} (c);
		\draw[loose, opacity=0.3] (a) -- node[costG, right, opacity=0.5] {2} (d);
		\draw[loose, opacity=0.3] (b) to[bend right=15] node[costG, left, opacity=0.5] {3} (a);
		\draw[loose, opacity=0.3] (d) -- node[costG, right, opacity=0.5] {2} (e);
		\draw[loose, opacity=0.3] (c) .. controls (7.5,2.5) and (7.5,-2.5) .. node[costG, right, opacity=0.5] {3} (e);

		% Destacar as SCCs
		% SCC da raiz
		\draw[green!60, ultra thick, dashed, rounded corners] (-0.6,-0.6) rectangle (0.6,0.6);
		\node[green!70!black, font=\small\bfseries, below] at (0,-0.9) {$\{r\}$};

		% SCC trivial de a - possui (r,a) justo entrando
		\draw[blue!60, ultra thick, dashed, rounded corners] (2.4,1.4) rectangle (3.6,2.6);
		\node[blue!70!black, font=\small\bfseries, above] at (3,2.9) {$\{a\}$};

		% SCC trivial de b - MINIMAL (sem arcos justos entrando)
		\draw[orange!70, ultra thick, dashed, rounded corners] (2.4,-2.6) rectangle (3.6,-1.4);
		\node[orange!70, font=\small\bfseries, below] at (3,-2.9) {$\{b\}$ \textbf{minimal}};

		% SCC do ciclo c-d - NÃO é minimal pois (a,c) é justo
		\draw[blue!60, ultra thick, dashed, rounded corners] (5.3,2.6) rectangle (6.7,-0.6);
		\node[blue!70!black, font=\small\bfseries, right] at (6.9,1) {$\{c,d\}$};
		\node[blue!70!black, font=\small\bfseries, right, font=\scriptsize] at (6.9,0.4) {(tem $(a,c)$ justo)};

		% SCC trivial de e - possui (b,e) justo entrando
		\draw[blue!60, ultra thick, dashed, rounded corners] (5.4,-2.6) rectangle (6.6,-1.4);
		\node[blue!70!black, font=\small\bfseries, below] at (6,-2.9) {$\{e\}$};
	\end{tikzpicture}
	\caption{Identificação das componentes fortemente conexas (SCCs) no grafo formado pelos arcos justos
		após a primeira iteração. Apenas \(\{b\}\) (em laranja) é \textbf{minimal} pois não possui arcos
		justos entrando --- o único arco entrando em \(b\) é \((r,b)\) com custo 1. As demais componentes
		\(\{r\}\) (contém a raiz), \(\{a\}\) (tem \((r,a)\) justo), \(\{c,d\}\) (tem \((a,c)\) justo)
		e \(\{e\}\) (tem \((b,e)\) justo) possuem arcos justos entrando e não são minimais.}
	\label{fig:frank-sccs}
\end{figure}

Repetimos o processo: para cada subconjunto minimal \(X\), calculamos \(\delta(X)\)
(o menor custo entre arcos entrando em \(X\)) e subtraímos esse valor.

O algoritmo continua até que os arcos de custo zero formem uma \(r\)-arborescência.
Quando há ciclos, usamos contração exatamente como no Chu--Liu--Edmonds.

\subsection*{Execução do Algoritmo no Exemplo}

Vamos agora executar o algoritmo passo a passo no dígrafo da Figura~\ref{fig:frank-exemplo-inicial}.

\textbf{Fase 1: Redução de custos}

\textbf{Iteração 1 --- Vértices isolados:}

Inicialmente, não há arcos justos (\(A_0 = \emptyset\)). Cada vértice não-raiz forma
seu próprio subconjunto minimal. Calculamos \(\delta(\{v\})\) para cada \(v \neq r\):

\begin{align*}
	\delta(\{a\}) & = \min\{c(r,a), c(b,a)\} = \min\{2, 5\} = 2,            \\
	\delta(\{b\}) & = \min\{c(r,b)\} = 3,                                   \\
	\delta(\{c\}) & = \min\{c(r,c), c(a,c)\} = \min\{7, 1\} = 1,            \\
	\delta(\{d\}) & = \min\{c(a,d), c(c,d)\} = \min\{4, 1\} = 1,            \\
	\delta(\{e\}) & = \min\{c(b,e), c(d,e), c(c,e)\} = \min\{2, 3, 6\} = 2.
\end{align*}

Subtraímos cada \(\delta(\{v\})\) dos arcos entrando em \(v\). Os arcos que atingem custo zero são:
\[
	A_0 = \{(r,a), (a,c), (c,d), (b,e)\}.
\]

\begin{figure}[H]
	\centering
	\begin{tikzpicture}[>=Stealth, scale=1.1]
		\tikzset{
			vtx/.style={circle, draw,fill=blue!8, thick, inner sep=1.2pt, minimum size=7mm},
			tight/.style={->, very thick, draw=blue!70},
			loose/.style={->, semithick, draw=black!35},
			costB/.style={font=\small, fill=white, inner sep=1.5pt, text=blue!70},
			costG/.style={font=\small, fill=white, inner sep=1.5pt, text=black!50}
		}

		\node[vtx] (r) at (0,0) {$r$};
		\node[vtx] (a) at (3,2) {$a$};
		\node[vtx] (b) at (3,-2) {$b$};
		\node[vtx] (c) at (6,2) {$c$};
		\node[vtx] (d) at (6,0) {$d$};
		\node[vtx] (e) at (6,-2) {$e$};

		% arcos justos
		\draw[tight] (r) -- node[costB, above left] {0} (a);
		\draw[tight] (a) -- node[costB, above] {0} (c);
		\draw[tight] (c) to[bend left=15] node[costB, right] {0} (d);
		\draw[tight] (b) -- node[costB, below] {0} (e);

		% arcos não justos
		\draw[loose] (r) -- node[costG, below left] {1} (b);  % 3-2 = 1 (elevou a)
		\draw[loose] (r) .. controls (2,3.5) and (5,3.5) .. node[costG, above] {4} (c);  % 7-1-2 = 4
		\draw[loose] (a) -- node[costG, right] {2} (d);  % 4-2 = 2
		\draw[loose] (b) to[bend right=15] node[costG, left] {3} (a);  % 5-2 = 3
		\draw[loose] (d) to[bend left=15] node[costG, left] {0} (c);  % 1-1 = 0
		\draw[loose] (d) -- node[costG, right] {2} (e);  % 3-1 = 2
		\draw[loose] (c) .. controls (7.5,2.5) and (7.5,-2.5) .. node[costG, right] {3} (e);  % 6-1-2 = 3
	\end{tikzpicture}
	\caption{Custos reduzidos após Iteração 1. Arcos justos em azul. Note que \(b\) não possui arco justo entrando, e os arcos \((c,d)\) e \((d,c)\) formam um ciclo justo.}
	\label{fig:frank-iter1}
\end{figure}

\textbf{Análise:} Observe que:
\begin{itemize}
	\item O vértice \(b\) não possui nenhum arco justo entrando (seu único arco entrando, \((r,b)\), tem custo reduzido 1).
	\item Os arcos \((c,d)\) e \((d,c)\) formam um ciclo de arcos justos.
	\item Como há um ciclo, não temos uma \(r\)-arborescência ainda.
\end{itemize}

\textbf{Iteração 2 --- Identificação de componentes:}

Calculamos as componentes fortemente conexas no grafo formado por \(A_0\):
\begin{itemize}
	\item \(\{r\}\) --- contém a raiz
	\item \(\{a\}\) --- componente trivial
	\item \(\{b\}\) --- componente trivial sem arcos justos entrando (\textbf{minimal})
	\item \(\{c, d\}\) --- componente não-trivial (ciclo) sem arcos justos entrando (\textbf{minimal})
	\item \(\{e\}\) --- componente trivial
\end{itemize}

Os subconjuntos minimais são \(\{b\}\) e \(\{c,d\}\). Calculamos:
\begin{align*}
	\delta(\{b\})   & = \min\{c(r,b)\} = 1,                        \\
	\delta(\{c,d\}) & = \min\{c(r,c), c(a,d)\} = \min\{4, 2\} = 2.
\end{align*}

Subtraímos esses valores dos respectivos arcos entrando:

\begin{figure}[H]
	\centering
	\begin{tikzpicture}[>=Stealth, scale=1.1]
		\tikzset{
			vtx/.style={circle, draw,fill=blue!8, thick, inner sep=1.2pt, minimum size=7mm},
			tight/.style={->, very thick, draw=blue!70},
			cycle/.style={->, ultra thick, draw=red!70},
			loose/.style={->, semithick, draw=black!35},
			costB/.style={font=\small, fill=white, inner sep=1.5pt, text=blue!70},
			costR/.style={font=\small, fill=white, inner sep=1.5pt, text=red!70},
			costG/.style={font=\small, fill=white, inner sep=1.5pt, text=black!50}
		}

		\node[vtx] (r) at (0,0) {$r$};
		\node[vtx] (a) at (3,2) {$a$};
		\node[vtx] (b) at (3,-2) {$b$};
		\node[vtx] (c) at (6,2) {$c$};
		\node[vtx] (d) at (6,0) {$d$};
		\node[vtx] (e) at (6,-2) {$e$};

		% arcos do ciclo
		\draw[cycle] (c) to[bend left=15] node[costR, right] {0} (d);
		\draw[cycle] (d) to[bend left=15] node[costR, left] {0} (c);

		% outros arcos justos
		\draw[tight] (r) -- node[costB, above left] {0} (a);
		\draw[tight] (r) -- node[costB, below left] {0} (b);  % novo!
		\draw[tight] (a) -- node[costB, above] {0} (c);
		\draw[tight] (a) -- node[costB, right] {0} (d);  % novo!
		\draw[tight] (b) -- node[costB, below] {0} (e);

		% arcos não justos
		\draw[loose] (r) .. controls (2,3.5) and (5,3.5) .. node[costG, above] {2} (c);  % 4-2 = 2
		\draw[loose] (b) to[bend right=15] node[costG, left] {3} (a);
		\draw[loose] (d) -- node[costG, right] {2} (e);
		\draw[loose] (c) .. controls (7.5,2.5) and (7.5,-2.5) .. node[costG, right] {3} (e);

		% destaque do ciclo
		\draw[red!60, thick, dashed, rounded corners] (5.3,2.6) rectangle (6.7,-0.6);
		\node[red!70, font=\bfseries] at (7.5,1) {Ciclo};
	\end{tikzpicture}
	\caption{Custos reduzidos após Iteração 2. Os novos arcos justos são \((r,b)\) e \((a,d)\).
		O ciclo \(\{c,d\}\) está destacado em vermelho.}
	\label{fig:frank-iter2}
\end{figure}

Agora todos os vértices não-raiz possuem ao menos um arco justo entrando. O conjunto
atual de arcos justos é:
\[
	A_0 = \{(r,a), (r,b), (a,c), (c,d), (d,c), (a,d), (b,e)\}.
\]

Entretanto, \(A_0\) contém o ciclo \(C = \{c,d\}\). Não temos uma \(r\)-arborescência ainda.

\textbf{Fase 2: Contração e Construção da Arborescência}

Como há um ciclo nos arcos justos, procedemos com a contração. Contraímos o ciclo
\(C = \{c,d\}\) em um supervértice \(x_C\), obtendo o dígrafo contraído \(D'\):

\begin{figure}[H]
	\centering
	\begin{tikzpicture}[>=Stealth, scale=1.1]
		\tikzset{
			vtx/.style={circle, draw,fill=blue!8, thick, inner sep=1.2pt, minimum size=7mm},
			vtxC/.style={circle, draw=red!70, fill=red!10, thick, inner sep=1.2pt, minimum size=9mm},
			tight/.style={->, very thick, draw=blue!70},
			loose/.style={->, semithick, draw=black!35},
			costB/.style={font=\small, fill=white, inner sep=1.5pt, text=blue!70},
			costG/.style={font=\small, fill=white, inner sep=1.5pt, text=black!50}
		}

		\node[vtx] (r) at (0,0) {$r$};
		\node[vtx] (a) at (3,1.5) {$a$};
		\node[vtx] (b) at (3,-1.5) {$b$};
		\node[vtxC] (xc) at (6,0.75) {$x_C$};
		\node[vtx] (e) at (6,-1.5) {$e$};

		% arcos justos
		\draw[tight] (r) -- node[costB, above left] {0} (a);
		\draw[tight] (r) -- node[costB, below left] {0} (b);
		\draw[tight] (a) -- node[costB, above] {0} (xc);
		\draw[tight] (b) -- node[costB, below] {0} (e);

		% arcos não justos
		\draw[loose] (r) .. controls (2,3) and (5,3) .. node[costG, above] {2} (xc);
		\draw[loose] (b) to[bend right=12] node[costG, left] {3} (a);
		\draw[loose] (xc) -- node[costG, right] {2} (e);
	\end{tikzpicture}
	\caption{Dígrafo contraído \(D'\) após contrair o ciclo \(C = \{c,d\}\) no supervértice \(x_C\).
		Observe que \(a\) tem dois arcos justos entrando em \(x_C\): um vindo de \(a\) (correspondente a \((a,c)\))
		e outro de \(r\) (correspondente a \((r,c)\) no original, mas com custo 2).}
	\label{fig:frank-contraction}
\end{figure}

No dígrafo contraído \(D'\), os arcos justos formam uma \(r\)-arborescência:
\[
	T' = \{(r,a), (r,b), (a,x_C), (b,e)\}.
\]

\textbf{Expansão:} O arco \((a,x_C) \in T'\) entra no supervértice \(x_C\). No dígrafo original,
esse arco corresponde a \((a,c)\). Para expandir, removemos um arco do ciclo \(C\) que entra
em \(c\). O ciclo é \(\{(c,d), (d,c)\}\), e o arco entrando em \(c\) é \((d,c)\). Removemos
\((d,c)\) e mantemos \((c,d)\). A arborescência final é:
\[
	T = \{(r,a), (r,b), (a,c), (c,d), (b,e)\}.
\]

\begin{figure}[H]
	\centering
	\begin{tikzpicture}[>=Stealth, scale=1.1]
		\tikzset{
			vtx/.style={circle, draw,fill=blue!8, thick, inner sep=1.2pt, minimum size=7mm},
			chosen/.style={->, ultra thick, draw=blue!70},
			other/.style={->, semithick, draw=black!25},
			costB/.style={font=\small, fill=white, inner sep=1.5pt, text=blue!70},
			costG/.style={font=\small, fill=white, inner sep=1.5pt, text=black!40}
		}

		\node[vtx] (r) at (0,0) {$r$};
		\node[vtx] (a) at (3,2) {$a$};
		\node[vtx] (b) at (3,-2) {$b$};
		\node[vtx] (c) at (6,2) {$c$};
		\node[vtx] (d) at (6,0) {$d$};
		\node[vtx] (e) at (6,-2) {$e$};

		% arborescência ótima
		\draw[chosen] (r) -- node[costB, above left] {2} (a);
		\draw[chosen] (r) -- node[costB, below left] {3} (b);
		\draw[chosen] (a) -- node[costB, above] {1} (c);
		\draw[chosen] (c) to[bend left=15] node[costB, right] {1} (d);
		\draw[chosen] (b) -- node[costB, below] {2} (e);

		% outros arcos
		\draw[other] (r) .. controls (2,3.5) and (5,3.5) .. node[costG, above] {7} (c);
		\draw[other] (a) -- node[costG, right] {4} (d);
		\draw[other] (b) to[bend right=15] node[costG, left] {5} (a);
		\draw[other] (d) to[bend left=15] node[costG, left] {1} (c);
		\draw[other] (d) -- node[costG, right] {3} (e);
		\draw[other] (c) .. controls (7.5,2.5) and (7.5,-2.5) .. node[costG, right] {6} (e);
	\end{tikzpicture}
	\caption{Arborescência ótima final \(T\) com custo total \(2+3+1+1+2 = 9\).
		Os arcos da arborescência estão destacados em azul grosso.}
	\label{fig:frank-final}
\end{figure}

\subsection*{Resumo do Exemplo}

Este exemplo ilustrou todas as principais características do algoritmo de András Frank:

\begin{enumerate}
	\item \textbf{Iteração inicial:} Cada vértice é processado individualmente, reduzindo custos
	      para criar arcos justos.
	\item \textbf{Formação de ciclo:} Os arcos \((c,d)\) e \((d,c)\) formaram um ciclo justo.
	\item \textbf{Identificação de SCCs:} O ciclo \(\{c,d\}\) foi identificado como uma
	      componente fortemente conexa que é um subconjunto minimal.
	\item \textbf{Segunda iteração:} Novos arcos justos foram criados processando o subconjunto
	      \(\{c,d\}\) como uma unidade.
	\item \textbf{Contração e expansão:} O ciclo foi contraído, o problema resolvido recursivamente,
	      e a solução expandida para obter a arborescência ótima.
\end{enumerate}

\subsection*{Conceitos Fundamentais}

\textbf{Custos reduzidos e arcos justos:} Durante a execução, os custos dos arcos são
progressivamente reduzidos. Um arco é \textbf{justo} quando seu custo reduzido atinge zero.
A arborescência final é formada exclusivamente por arcos justos.

\textbf{Subconjuntos minimais:} Um conjunto \(X \subseteq V \setminus \{r\}\) é \textbf{minimal}
se não possui arcos justos entrando e é uma componente fortemente conexa no grafo de arcos justos.
Inicialmente, cada vértice é minimal. Após criar arcos justos, ciclos formam componentes
não-triviais que são tratadas como unidades.

\textbf{Interpretação dual:} Subtrair \(\delta(X)\) dos arcos entrando em \(X\) equivale
a aumentar potenciais duais \(y(v)\) para \(v \in X\) e trabalhar com custos reduzidos
\(c_y(u,v) = c_{\text{original}}(u,v) - y(v)\). A implementação opera diretamente sobre
custos, mas a equivalência é útil para provas de corretude.

\subsection*{Construção da Arborescência}

Se os arcos justos formam uma \(r\)-arborescência (sem ciclos), então encontramos
a solução ótima. Caso contrário, os arcos justos contêm ciclos, e procedemos como
no algoritmo de Chu--Liu--Edmonds: identificamos as componentes fortemente conexas,
contraímos cada componente em um supervértice, e resolvemos recursivamente o problema
no dígrafo contraído.

No nosso exemplo, os cinco arcos justos \(\{(r,a), (r,b), (a,c), (b,d), (b,e)\}\)
formam uma \(r\)-arborescência. Como não há ciclos, o algoritmo termina e retorna
essa arborescência como solução ótima.

\textbf{Por que essa arborescência é ótima?} A seguinte propriedade garante a otimalidade:

\begin{proposicao}
	Uma \(r\)-arborescência \(T\) é de custo mínimo se, e somente se, todos os arcos
	de \(T\) são justos (custo reduzido zero) e todos os demais arcos têm custo reduzido
	não negativo.
\end{proposicao}

\begin{proof}[Prova.]
	Seja \(F\) uma \(r\)-arborescência qualquer. Para cada \(v \in V \setminus \{r\}\),
	seja \(a_v\) o único arco de \(F\) que entra em \(v\). Se interpretarmos as reduções
	de custo através de potenciais duais \(y(v)\), temos
	\begin{align*}
		c(F)
		 & = \sum_{v \in V \setminus \{r\}} c(a_v)                                          \\
		 & = \sum_{v \in V \setminus \{r\}} \bigl(c_y(a_v) + y(v)\bigr)                     \\
		 & = \sum_{v \in V \setminus \{r\}} c_y(a_v) + \sum_{v \in V \setminus \{r\}} y(v).
	\end{align*}
	Como a soma \(\sum_{v \in V \setminus \{r\}} y(v)\) é constante para todas as
	\(r\)-arborescências, minimizar \(c(F)\) equivale a minimizar \(\sum_{v} c_y(a_v)\).
	Se todos os arcos de \(T\) são justos e \(c_y(a) \geq 0\) para todo \(a\),
	então \(\sum_{v} c_y(a_v^T) = 0 \leq \sum_{v} c_y(a_v^F)\) para qualquer \(F\),
	provando que \(T\) é ótima.
\end{proof}

No nosso exemplo, todos os arcos de \(T\) são justos e \(c_y(a) \geq 0\) para todo
arco \(a \in A\), portanto \(T\) é a \(r\)-arborescência de custo mínimo. Evidentemente, nem sempre será o caso que os arcos justos formam uma arborescência e precisaremos tratar ciclos.

\subsection*{Tratamento de Ciclos}

Em geral, após a elevação de potenciais, os arcos justos podem conter ciclos.
Nesse caso, o algoritmo de Frank procede de forma similar ao de Chu--Liu--Edmonds:
contrai cada ciclo justo em um supervértice, resolve o problema recursivamente
no dígrafo contraído, e depois reexpande a solução.

Vamos ilustrar esse processo com um exemplo modificado. Suponha que adicionamos o arco
\((c, a)\) com custo 1 ao dígrafo original:

\begin{figure}[H]
	\centering
	\begin{tikzpicture}[>=Stealth]
		% estilos
		\tikzset{
			vtx/.style={circle, draw,fill=blue!8, thick, inner sep=1.2pt, minimum size=6mm},
			arc/.style={->, semithick, draw=black!35},
			costG/.style={font=\scriptsize, fill=white, inner sep=1pt, text=black!55}
		}

		% layout
		\node[vtx] (r) at (0,0) {$r$};
		\node[vtx] (a) at (3,1.6) {$a$};
		\node[vtx] (b) at (3,-1.6) {$b$};
		\node[vtx] (c) at (6,2.2) {$c$};
		\node[vtx] (d) at (6,0.0) {$d$};
		\node[vtx] (e) at (6,-2.2) {$e$};

		% arcos originais
		\draw[arc] (r) -- node[costG, above] {1} (a);
		\draw[arc] (r) -- node[costG, below] {2} (b);
		\draw[arc] (r) .. controls (0.8,2.4) and (5.2,3.0) .. node[costG, yshift=4pt, pos=0.53] {3} (c);
		\draw[arc] (b) to[bend left=12] node[costG, above] {4} (a);
		\draw[arc] (a) to[bend left=14] node[costG, below] {5} (b);
		\draw[arc] (a) -- node[costG, above] {1} (c);
		\draw[arc] (a) -- node[costG, right] {3} (d);
		\draw[arc] (b) -- node[costG, above] {1} (d);
		\draw[arc] (b) -- node[costG, below] {2} (e);
		\draw[arc] (c) .. controls (7.6,2.6) and (7.6,-2.6) .. node[costG, xshift=8pt, pos=0.52] {5} (e);

		% NOVO arco (c, a)
		\draw[arc, draw=red!60] (c) to[bend left=20] node[costG, left, text=red!60] {1} (a);
	\end{tikzpicture}
	\caption{Dígrafo modificado com o arco \((c,a)\) de custo 1 (em vermelho).}
\end{figure}

Após a elevação de potenciais com \(y(a) = 1, y(c) = 1\), o arco \((c,a)\) torna-se
justo: \(c_y(c,a) = 1 - 1 = 0\).

\begin{figure}[H]
	\centering
	\begin{tikzpicture}[>=Stealth]
		% estilos
		\tikzset{
			vtx/.style={circle, draw,fill=blue!8, thick, inner sep=1.2pt, minimum size=6mm},
			tight/.style={->, very thick, draw=blue},
			cycle/.style={->, ultra thick, draw=red!70},
			loose/.style={->, semithick, draw=black!35},
			costB/.style={font=\scriptsize, fill=white, inner sep=1pt, text=blue},
			costR/.style={font=\scriptsize, fill=white, inner sep=1pt, text=red!70},
			costG/.style={font=\scriptsize, fill=white, inner sep=1pt, text=black!55}
		}

		% layout
		\node[vtx] (r) at (0,0) {$r$};
		\node[vtx] (a) at (3,1.6) {$a$};
		\node[vtx] (b) at (3,-1.6) {$b$};
		\node[vtx] (c) at (6,2.2) {$c$};
		\node[vtx] (d) at (6,0.0) {$d$};
		\node[vtx] (e) at (6,-2.2) {$e$};

		% arcos justos que formam ciclo
		\draw[cycle] (a) -- node[costR, above] {0} (c);
		\draw[cycle] (c) to[bend left=20] node[costR, left] {0} (a);

		% outros arcos justos
		\draw[tight] (r) -- node[costB, above] {0} (a);
		\draw[tight] (r) -- node[costB, below] {0} (b);
		\draw[tight] (b) -- node[costB, above] {0} (d);
		\draw[tight] (b) -- node[costB, below] {0} (e);

		% arcos não justos
		\draw[loose] (r) .. controls (0.8,2.4) and (5.2,3.0) .. node[costG, yshift=4pt, pos=0.53] {2} (c);
		\draw[loose] (b) to[bend left=12] node[costG, above] {3} (a);
		\draw[loose] (a) to[bend left=14] node[costG, below] {3} (b);
		\draw[loose] (a) -- node[costG, right] {2} (d);   % 3 - 1 = 2
		\draw[loose] (c) .. controls (7.6,2.6) and (7.6,-2.6) .. node[costG, xshift=8pt, pos=0.52] {3} (e);  % 5 - 2 = 3
	\end{tikzpicture}
	\caption{Arcos justos após elevação. O ciclo \(C = (a, c, a)\) é destacado em
		\textcolor{red!70}{vermelho}.}
\end{figure}

Nesse caso, contraímos o ciclo \(C = (a, c)\) em um supervértice \(x_C\), ajustamos
os custos dos arcos incidentes, e resolvemos o problema no dígrafo contraído.
A reexpansão é feita removendo um arco do ciclo para manter a estrutura de arborescência,
de forma análoga ao algoritmo de Chu--Liu--Edmonds.

\section{Descrição do algoritmo}

Apresentamos agora uma descrição formal do algoritmo de András Frank.

O algoritmo opera em duas fases. A Fase~1 reduz progressivamente os custos dos arcos,
criando arcos justos (de custo zero) através da identificação de subconjuntos minimais.
A Fase~2 constrói a arborescência a partir dos arcos justos, usando contração e expansão
quando necessário.

A diferença fundamental em relação ao Chu--Liu--Edmonds está na Fase~1:
\begin{itemize}
	\item \textbf{Chu--Liu:} Para cada vértice \(v\), subtrai o menor custo entrando em \(v\).
	      Processa vértice a vértice, uma vez.
	\item \textbf{Frank:} A cada iteração, identifica componentes fortemente conexas no grafo
	      de arcos justos. Para cada componente sem arcos justos entrando (subconjunto minimal \(X\)),
	      subtrai \(\delta(X)\) de todos os arcos entrando em \(X\). Repete até todos os vértices
	      terem arcos justos entrando.
\end{itemize}

A Fase~2 é idêntica em ambos os algoritmos: se há ciclos nos arcos justos, contrai,
resolve recursivamente, e expande.

\begin{algobox}{András Frank}{andras-frank}
	Entrada: dígrafo \(D=(V,A)\), custos \(c:A\to\mathbb{R}_{\ge 0}\), raiz \(r\).\footnote{Se algum \(v\neq r\) não possui arco de entrada, não existe r-arborescência.}

	\textbf{Fase 1: Redução de custos e construção de \(A_0\)}
	\begin{enumerate}\setlength{\itemsep}{2pt}
		\item \textbf{Inicialização:} defina \(A_0 := \emptyset\) (conjunto de arcos justos).
		\item \textbf{Iteração:} enquanto existir subconjunto minimal \(X \subseteq V \setminus \{r\}\):
		      \begin{itemize}\setlength{\itemsep}{2pt}
			      \item Calcule as componentes fortemente conexas de \((V, A_0)\).
			      \item Para cada componente \(X\) que não contém \(r\) e não possui arcos de \(A_0\) entrando:
			            \begin{itemize}
				            \item Calcule \(\delta(X) := \min\{c(u,v) : u \notin X, v \in X\}\).
				            \item Para todo arco \((u,v)\) com \(u \notin X\) e \(v \in X\), atualize \(c(u,v) := c(u,v) - \delta(X)\).
				            \item Adicione a \(A_0\) todos os arcos \((u,v)\) com \(u \notin X, v \in X\) que atingiram custo zero.
			            \end{itemize}
		      \end{itemize}
		      Ao final, todo vértice \(v \neq r\) possui ao menos um arco justo entrando.
	\end{enumerate}

	\textbf{Fase 2: Construção da arborescência}
	\begin{enumerate}\setlength{\itemsep}{2pt}\setcounter{enumi}{2}
		\item Se \((V,A_0)\) forma uma r-arborescência, devolva \(A_0\). Por construção, todos os arcos têm custo reduzido zero e os demais arcos têm custo não negativo, garantindo otimalidade.
		\item Caso contrário, identifique um ciclo dirigido \(C\) em \(A_0\) (com \(r\notin C\)). \textbf{Contração:} contraia \(C\) em um supervértice \(x_C\) e ajuste os custos dos arcos incidentes, descartando laços em \(x_C\) e permitindo paralelos. Denote o dígrafo contraído por \(D'=(V',A')\).
		\item \textbf{Recursão:} compute uma r-arborescência ótima \(T'\) de \(D'\) com os custos ajustados.
		\item \textbf{Expansão:} seja \((u,x_C)\in T'\) o único arco que entra em \(x_C\). No dígrafo original, ele corresponde a \((u,w)\) com \(w\in C\). Forme
		      \[
			      T := \bigl(T'\setminus\{\text{arcos incidentes a } x_C\}\bigr)\ \cup\ \{(u,w)\}\ \cup\ \bigl((A_0\cap A(C))\setminus\{a_w\}\bigr),
		      \]
		      onde \(a_w\) é o arco de \(C\) que entra em \(w\). Então \(T\) é uma r-arborescência ótima de \(D\).
	\end{enumerate}
\end{algobox}

\subsection{Corretude}

A corretude do algoritmo baseia-se em três ideias principais:

\begin{enumerate}\setlength{\itemsep}{2pt}
	\item \emph{Equivalência com potenciais duais:} A operação de subtrair \(\delta(X)\)
	      dos arcos entrando em \(X\) equivale a aumentar um potencial dual \(y(v)\) em \(\delta(X)\)
	      para cada \(v \in X\). Trabalhar com custos reduzidos \(c(u,v)\) é equivalente
	      a trabalhar com \(c_{\text{original}}(u,v) - y(v)\).

	\item \emph{Condições de otimalidade:} Uma \(r\)-arborescência \(T\) é ótima se, e somente se:
	      \begin{itemize}\setlength{\itemsep}{2pt}
		      \item Todos os arcos de \(T\) são justos (custo reduzido zero).
		      \item Todos os arcos do dígrafo têm custo reduzido não negativo.
	      \end{itemize}
	      Isso porque, para qualquer \(r\)-arborescência \(F\),
	      \[
		      c(F) = \sum_{v \neq r} c_y(a_v) + \sum_{v \neq r} y(v),
	      \]
	      onde \(a_v\) é o arco de \(F\) entrando em \(v\). Como \(\sum_{v \neq r} y(v)\)
	      é constante, minimizar \(c(F)\) equivale a minimizar \(\sum_{v \neq r} c_y(a_v)\).

	\item \emph{Identificação de subconjuntos minimais:} O algoritmo usa componentes fortemente
	      conexas para identificar quais conjuntos ainda precisam de arcos justos entrando.
	      Inicialmente cada vértice é sua própria componente. Após criar arcos justos,
	      se formarem ciclos, as componentes agrupam vértices e o processo continua
	      sobre esses conjuntos maiores.
\end{enumerate}

\textbf{Conclusão:} A operação é a mesma do Chu--Liu--Edmonds (subtrair o menor custo
entrando em cada conjunto), mas organizada diferentemente: Chu--Liu opera vértice a vértice;
Frank opera sobre componentes fortemente conexas.

\subsection{Complexidade}

A implementação, baseada em componentes fortemente conexas, detecta em cada iteração, quais conjuntos \(X\) necessitam elevação de potenciais. Calcular componentes fortemente conexas custa \(O(n+m)\) usando algoritmos como Tarjan ou Kosaraju. Para cada componente (exceto a raiz), eleva-se o potencial calculando \(\Delta(X)\) em \(O(m)\), atualizando os custos reduzidos.

No pior caso, cada iteração reduz o número de componentes em pelo menos uma unidade, resultando em \(O(n)\) iterações. Cada iteração processa todos os arcos para atualizar custos reduzidos e recalcular componentes, resultando em \(O(nm)\) no total para a Fase~1. A Fase~2 constrói a arborescência percorrendo \(A_0\) uma vez, custando \(O(n)\).

O uso de memória é \(O(n+m)\), incluindo as estruturas para armazenar o dígrafo, potenciais e componentes. A implementação a seguir adota a versão \(O(nm)\) por simplicidade e está disponível no repositório do projeto (\url{https://github.com/lorenypsum/GraphVisualizer}).

\section{Implementação em Python}

Esta seção descreve a implementação do algoritmo de András Frank em Python, estruturada para refletir com precisão as duas fases formais discutidas anteriormente. A Fase~1 realiza a elevação de potenciais e identifica os arcos justos, enquanto a Fase~2 constrói a arborescência de custo mínimo a partir desses arcos. Utilizamos a biblioteca NetworkX para manipulação de digrafos, aproveitando suas funcionalidades para representar grafos, calcular componentes fortemente conexas e gerenciar atributos de arcos.

A entrada consiste em um dígrafo orientado \(D = (V, A)\), com custos dos arcos registrados no atributo \texttt{"w"}, e uma raiz \(r \in V\). As hipóteses adotadas são: (i) o dígrafo é conexo a partir de \(r\), isto é, todo vértice \(v \neq r\) é alcançável a partir da raiz; (ii) para todo subconjunto \(X \subseteq V \setminus \{r\}\), existe ao menos um arco entrando em \(X\); e (iii) todos os custos são não negativos.

A saída é um subdigrafo \(T\) de \(D\) com \(|A_T| = |V| - 1\) arcos, tal que cada vértice \(v \neq r\) possui grau de entrada igual a 1, todos os vértices são alcançáveis a partir de \(r\), e o custo total \(\sum_{a \in A_T} c(a)\) é mínimo.

A estrutura do código é modular: funções auxiliares tratam cada etapa do algoritmo — cálculo de componentes fortemente conexas, elevação de potenciais, construção do subdigrafo \(A_0\) e construção da arborescência final. Todas operam sobre objetos \texttt{nx.DiGraph} e são coordenadas por uma função principal que gerencia o fluxo das duas fases. As subseções seguintes detalham cada função auxiliar, abordando lógica, parâmetros, saídas e complexidade.

\subsection{Construção do dígrafo \texorpdfstring{\(D_0\)}{D_0} inicial}

Começamos escrevendo uma função que constrói o dígrafo inicial \(D_0\) que será utilizado na Fase~1 do algoritmo. O dígrafo \(D_0\) é inicializado como um grafo vazio contendo apenas os vértices do dígrafo original, sem arcos. Essa estrutura será gradualmente populada com arcos de custo reduzido zero à medida que os potenciais são elevados.

Recebe como entrada um dígrafo \texttt{D} (objeto \texttt{nx.DiGraph}). A implementação cria um novo dígrafo vazio \texttt{D\_zero} (linha 2) e adiciona todos os vértices de \texttt{D} a \texttt{D\_zero} (linhas 3-4), preservando a estrutura de vértices sem incluir arcos inicialmente.

A função devolve o dígrafo \texttt{D\_zero} contendo todos os vértices de \texttt{D} mas nenhum arco. O dígrafo original \texttt{D} não é modificado. A complexidade é \(O(n)\), onde \(n = |V|\), pois itera sobre todos os vértices uma única vez.

\begin{tcolorbox}[
		enhanced, breakable,
		colframe=blue!60!black, colback=blue!2,
		colbacktitle=blue!15, coltitle=black,
		title={Construção do dígrafo $D_0$ inicial},
		boxed title style={sharp corners, boxrule=0.6pt},
		sharp corners, boxrule=0.6pt
	]
	\emph{Constrói um dígrafo vazio contendo apenas os vértices de D, sem arcos. Este dígrafo será populado com arcos justos durante a elevação de potenciais.}
	\tcblower
	\begin{lstlisting}[language=Python]
def build_D_zero(D):
    D_zero = nx.DiGraph()
    for v in D.nodes():
        D_zero.add_node(v)
    return D_zero
\end{lstlisting}
\end{tcolorbox}

\subsection{Identificação de arcos entrando em conjunto \texorpdfstring{\(X\)}{X}}

Esta função auxiliar identifica todos os arcos que entram em um conjunto \(X \subseteq V\), isto é, arcos \((u,v)\) tais que \(u \notin X\) e \(v \in X\). Essa operação é fundamental para calcular o mínimo custo de entrada em \(X\) durante a elevação de potenciais.

Recebe como entrada um dígrafo \texttt{D} e um conjunto de vértices \texttt{X}. A implementação cria uma lista vazia \texttt{arcs} (linha 2) e itera sobre todos os arcos do dígrafo com seus dados (linha 3), incluindo o peso. Para cada arco \((u,v,\text{data})\), verifica se \(u \notin X\) e \(v \in X\) (linha 4), adicionando à lista apenas os arcos que cruzam a fronteira de \(X\) (linha 5).

A função devolve uma lista de tuplas \((u, v, \text{data})\) representando os arcos que entram em \(X\), onde \texttt{data} contém o atributo \texttt{"w"} com o peso do arco. A complexidade é \(O(m)\), onde \(m = |A|\), pois examina cada arco uma vez.

\begin{tcolorbox}[
		enhanced, breakable,
		colframe=blue!60!black, colback=blue!2,
		colbacktitle=blue!15, coltitle=black,
		title={Identificação de arcos entrando em conjunto X},
		boxed title style={sharp corners, boxrule=0.6pt},
		sharp corners, boxrule=0.6pt
	]
	\emph{Identifica todos os arcos $(u,v)$ do dígrafo D tais que $u \notin X$ e $v \in X$, devolvendo uma lista com as tuplas $(u, v, data)$ onde data contém o peso do arco.}
	\tcblower
	\begin{lstlisting}[language=Python]
def get_arcs_entering_X(D, X):
    arcs = []
    for u, v, data in D.edges(data=True):
        if u not in X and v in X:
            arcs.append((u, v, data))
    return arcs
\end{lstlisting}
\end{tcolorbox}

A figura a seguir ilustra o funcionamento da função \texttt{get\_arcs\_entering\_X} em um digrafo que vamos denotar por \(D_{32}\). O dígrafo possui uma raiz \(r_0\) conectada aos vértices \(u_1, u_2, u_3\). Os vértices em laranja pertencem ao conjunto \(X = \{v_1, v_2, v_3\}\), e a função identifica apenas os arcos em vermelho, que saem de vértices fora de \(X\) e entram em vértices dentro de \(X\). Arcos da raiz, arcos internos a \(X\), externos a \(X\), ou saindo de \(X\) não são retornados.

\begin{figure}[H]
	\centering
	\begin{tikzpicture}[>=Stealth]
		% estilos
		\tikzset{
			vtx/.style={circle, draw, fill=blue!8, thick, inner sep=1.2pt, minimum size=7mm},
			vtxRoot/.style={circle, draw, fill=red!15, thick, inner sep=1.2pt, minimum size=7mm},
			vtxX/.style={circle, draw=orange!80!black, fill=orange!15, thick, inner sep=1.2pt, minimum size=7mm},
			arc/.style={->, >=Stealth, thick, draw=black!40},
			arcEntering/.style={->, >=Stealth, very thick, draw=red!70!black},
			cost/.style={font=\scriptsize, fill=white, inner sep=1pt}
		}

		% Raiz
		\node[vtxRoot] (r0) at (2, 4) {$r_0$};

		% Vértices fora de X
		\node[vtx] (u1) at (0, 2) {$u_1$};
		\node[vtx] (u2) at (2, 2) {$u_2$};
		\node[vtx] (u3) at (4, 2) {$u_3$};

		% Vértices dentro de X (destacados)
		\node[vtxX] (v1) at (0.5, -0.5) {$v_1$};
		\node[vtxX] (v2) at (2, -0.5) {$v_2$};
		\node[vtxX] (v3) at (3.5, -0.5) {$v_3$};

		% Arcos da raiz (não retornados, pois r0 não está em consideração para X)
		\draw[arc] (r0) -- node[cost, left, pos=0.4] {1} (u1);
		\draw[arc] (r0) -- node[cost, right] {2} (u2);
		\draw[arc] (r0) -- node[cost, right, pos=0.4] {1} (u3);

		% Arcos externos a X (não retornados)
		\draw[arc] (u1) to[bend left=15] node[cost, above] {1} (u2);
		\draw[arc] (u2) to[bend left=15] node[cost, above] {3} (u3);

		% Arcos entrando em X (destacados em vermelho)
		\draw[arcEntering] (u1) -- node[cost, left] {3} (v1);
		\draw[arcEntering] (u2) -- node[cost, right] {2} (v2);
		\draw[arcEntering] (u3) -- node[cost, right] {4} (v3);
		\draw[arcEntering] (u1) to[bend right=20] node[cost, below, pos=0.3] {5} (v2);

		% Arcos internos a X (não retornados)
		\draw[arc] (v1) -- node[cost, above] {1} (v2);
		\draw[arc] (v2) -- node[cost, above] {2} (v3);

		% Arcos saindo de X (não retornados)
		\draw[arc] (v1) to[bend right=30] node[cost, left, pos=0.3] {2} (u1);

		% Região X destacada
		\draw[orange!60!black, thick, dashed, rounded corners=8pt]
		(-0.3, 0.3) rectangle (4.3, -1.3);
		\node[orange!80!black, font=\bfseries] at (5, 0.3) {$X$};
	\end{tikzpicture}
	\caption{Ilustração da função \texttt{get\_arcs\_entering\_X} em \(D_{32}\). A raiz \(r_0\) (em vermelho claro) conecta-se aos vértices \(u_1, u_2, u_3\). Os vértices em \textcolor{orange!80!black}{laranja} pertencem ao conjunto \(X = \{v_1, v_2, v_3\}\). A função identifica apenas os arcos \textcolor{red!70!black}{em vermelho}: aqueles que saem de vértices fora de \(X\) e entram em vértices dentro de \(X\). Arcos da raiz, arcos internos a \(X\), externos a \(X\), ou saindo de \(X\) não são retornados.}
\end{figure}

\subsection{Cálculo do peso mínimo de corte}

Esta função calcula o peso mínimo entre todos os arcos fornecidos, correspondendo ao valor \(\Delta(X)\) necessário para elevar os potenciais dos vértices em \(X\).

Recebe como entrada uma lista \texttt{arcos} de tuplas \((u, v, \text{data})\). A implementação usa a função \texttt{min} com uma compreensão de gerador (linha 2) que extrai o atributo \texttt{"w"} de cada tupla em \texttt{data}.

A função devolve o peso mínimo encontrado entre todos os arcos da lista. A complexidade é \(O(k)\), onde \(k\) é o número de arcos na lista, pois examina cada arco uma vez para encontrar o mínimo.

\begin{tcolorbox}[
		enhanced, breakable,
		colframe=blue!60!black, colback=blue!2,
		colbacktitle=blue!15, coltitle=black,
		title={Cálculo do peso mínimo de corte},
		boxed title style={sharp corners, boxrule=0.6pt},
		sharp corners, boxrule=0.6pt
	]
	\emph{Calcula o peso mínimo entre todos os arcos fornecidos, correspondendo ao valor $\Delta(X)$ usado na elevação de potenciais.}
	\tcblower
	\begin{lstlisting}[language=Python]
def get_minimum_weight_cut(arcs):
    return min(data["w"] for _, _, data in arcs)
\end{lstlisting}
\end{tcolorbox}

A seguir temos uma ilustração do funcionamento da função \texttt{get\_minimum\_weight\_cut} em \(D_{32}\). Considerando os arcos em vermelho que entram em \(X\) (identificados pela função anterior), esta função calcula o peso mínimo entre eles. O arco em verde possui o menor peso (2), correspondendo ao valor \(\Delta(X) = 2\) que será devolvido pela função.

\begin{figure}[H]
	\centering
	\begin{tikzpicture}[>=Stealth]
		% estilos
		\tikzset{
			vtx/.style={circle, draw, fill=blue!8, thick, inner sep=1.2pt, minimum size=7mm},
			vtxRoot/.style={circle, draw, fill=red!15, thick, inner sep=1.2pt, minimum size=7mm},
			vtxX/.style={circle, draw=orange!80!black, fill=orange!15, thick, inner sep=1.2pt, minimum size=7mm},
			arc/.style={->, >=Stealth, thick, draw=black!40},
			arcEntering/.style={->, >=Stealth, very thick, draw=red!70!black},
			arcMin/.style={->, >=Stealth, ultra thick, draw=green!60!black},
			cost/.style={font=\scriptsize, fill=white, inner sep=1pt},
			costMin/.style={font=\scriptsize\bfseries, fill=green!10, inner sep=2pt, draw=green!60!black, rounded corners=1pt}
		}

		% Raiz
		\node[vtxRoot] (r0) at (2, 4) {$r_0$};

		% Vértices fora de X
		\node[vtx] (u1) at (0, 2) {$u_1$};
		\node[vtx] (u2) at (2, 2) {$u_2$};
		\node[vtx] (u3) at (4, 2) {$u_3$};

		% Vértices dentro de X (destacados)
		\node[vtxX] (v1) at (0.5, -0.5) {$v_1$};
		\node[vtxX] (v2) at (2, -0.5) {$v_2$};
		\node[vtxX] (v3) at (3.5, -0.5) {$v_3$};

		% Arcos da raiz
		\draw[arc] (r0) -- node[cost, left, pos=0.4] {1} (u1);
		\draw[arc] (r0) -- node[cost, right] {2} (u2);
		\draw[arc] (r0) -- node[cost, right, pos=0.4] {1} (u3);

		% Arcos externos a X
		\draw[arc] (u1) to[bend left=15] node[cost, above] {1} (u2);
		\draw[arc] (u2) to[bend left=15] node[cost, above] {3} (u3);

		% Arcos entrando em X (em vermelho, mas o mínimo em verde)
		\draw[arcEntering] (u1) -- node[cost, left] {3} (v1);
		\draw[arcMin] (u2) -- node[costMin, right] {2} (v2);
		\draw[arcEntering] (u3) -- node[cost, right] {4} (v3);
		\draw[arcEntering] (u1) to[bend right=20] node[cost, below, pos=0.3] {5} (v2);

		% Arcos internos a X
		\draw[arc] (v1) -- node[cost, above] {1} (v2);
		\draw[arc] (v2) -- node[cost, above] {2} (v3);

		% Arcos saindo de X
		\draw[arc] (v1) to[bend right=30] node[cost, left, pos=0.3] {2} (u1);

		% Região X destacada
		\draw[orange!60!black, thick, dashed, rounded corners=8pt]
		(-0.3, 0.3) rectangle (4.3, -1.3);
		\node[orange!80!black, font=\bfseries] at (5, 0.3) {$X$};

		% Anotação do resultado
		\node[font=\bfseries, green!60!black] at (2, -2.2) {$\Delta(X) = \min\{3, 2, 4, 5\} = 2$};
	\end{tikzpicture}
	\caption{Ilustração da função \texttt{get\_minimum\_weight\_cut} em \(D_{32}\). Considerando os arcos \textcolor{red!70!black}{em vermelho} que entram em \(X\) (identificados pela função anterior), esta função calcula o peso mínimo entre eles. O arco \textcolor{green!60!black}{em verde} possui o menor peso (2), correspondendo ao valor \(\Delta(X) = 2\).}
\end{figure}

\subsection{Atualização de pesos em \texorpdfstring{\(X\)}{X}}

Esta função auxiliar atualiza os pesos dos arcos que entram em um conjunto \(X\), subtraindo o valor \(\Delta(X)\) de cada peso. Arcos que atingem peso zero são adicionados a \(A_0\) e a \(D_0\).

Recebe como entrada um dígrafo \texttt{D}, lista de \texttt{arcs} entrando em \(X\), o valor \texttt{min\_weight} a ser subtraído, uma lista \texttt{A\_zero} para armazenar arcos de peso zero, e o dígrafo \texttt{D\_zero} para adicionar os arcos justos.

A implementação itera sobre cada arco \((u,v,\_)\) da lista (linha 2), subtrai \texttt{min\_weight} do peso armazenado em \texttt{D[u][v]["w"]} (linha 3), e verifica se o peso resultante é zero (linha 4). Caso sim, adiciona-se \((u,v)\) à lista \texttt{A\_zero} (linha 5) e ao dígrafo \texttt{D\_zero} (linha 6).

A função não devolve valor, pois modifica diretamente as estruturas passadas como parâmetros: o dígrafo \texttt{D} tem seus pesos atualizados, \texttt{A\_zero} acumula arcos justos, e \texttt{D\_zero} é populado com esses arcos. A complexidade é \(O(k)\), onde \(k\) é o número de arcos em \texttt{arcs}.

\begin{tcolorbox}[
		enhanced, breakable,
		colframe=blue!60!black, colback=blue!2,
		colbacktitle=blue!15, coltitle=black,
		title={Atualização de pesos em X},
		boxed title style={sharp corners, boxrule=0.6pt},
		sharp corners, boxrule=0.6pt
	]
	\emph{Atualiza os pesos dos arcos que entram em X, subtraindo o valor mínimo. Arcos que atingem peso zero são registrados em $A_0$ e adicionados a $D_0$.}
	\tcblower
	\begin{lstlisting}[language=Python]
def update_weights_in_X(D, arcs, min_weight, A_zero, D_zero):
    for u, v, _ in arcs:
        D[u][v]["w"] -= min_weight
        if D[u][v]["w"] == 0:
            A_zero.append((u, v))
            D_zero.add_edge(u, v)
\end{lstlisting}
\end{tcolorbox}

A seguir ilustramos o funcionamento da função \texttt{update\_weights\_in\_X} em \(D_{32}\). A figura mostra o dígrafo antes e depois da atualização dos pesos. No estado inicial (esquerda), temos \(\Delta(X) = 2\). A função subtrai esse valor de todos os arcos que entram em \(X\). No estado final (direita), os arcos que atingiram peso zero (destacados em azul) são adicionados a \(A_0\) e \(D_0\).

\begin{figure}[H]
	\centering
	\begin{tikzpicture}[>=Stealth]
		% estilos
		\tikzset{
			vtx/.style={circle, draw, fill=blue!8, thick, inner sep=1.2pt, minimum size=6.5mm},
			vtxRoot/.style={circle, draw, fill=red!15, thick, inner sep=1.2pt, minimum size=6.5mm},
			vtxX/.style={circle, draw=orange!80!black, fill=orange!15, thick, inner sep=1.2pt, minimum size=6.5mm},
			arc/.style={->, >=Stealth, thick, draw=black!40},
			arcEntering/.style={->, >=Stealth, very thick, draw=red!70!black},
			arcTight/.style={->, >=Stealth, ultra thick, draw=blue!70!black},
			cost/.style={font=\scriptsize, fill=white, inner sep=1pt},
			costTight/.style={font=\scriptsize\bfseries, fill=blue!10, inner sep=2pt, draw=blue!70!black, rounded corners=1pt}
		}

		% ===== ANTES (esquerda) =====
		\begin{scope}
			\node[font=\bfseries, blue!80!black] at (2, 4.2) {Antes: pesos originais};

			% Raiz
			\node[vtxRoot] (r0) at (2, 3) {$r_0$};

			% Vértices fora de X
			\node[vtx] (u1) at (0, 1.5) {$u_1$};
			\node[vtx] (u2) at (2, 1.5) {$u_2$};
			\node[vtx] (u3) at (4, 1.5) {$u_3$};

			% Vértices dentro de X
			\node[vtxX] (v1) at (0.5, -0.5) {$v_1$};
			\node[vtxX] (v2) at (2, -0.5) {$v_2$};
			\node[vtxX] (v3) at (3.5, -0.5) {$v_3$};

			% Arcos da raiz
			\draw[arc] (r0) -- node[cost, left, pos=0.4] {1} (u1);
			\draw[arc] (r0) -- node[cost, right] {2} (u2);
			\draw[arc] (r0) -- node[cost, right, pos=0.4] {1} (u3);

			% Arcos externos a X
			\draw[arc] (u1) to[bend left=15] node[cost, above] {1} (u2);
			\draw[arc] (u2) to[bend left=15] node[cost, above] {3} (u3);

			% Arcos entrando em X
			\draw[arcEntering] (u1) -- node[cost, left] {3} (v1);
			\draw[arcEntering] (u2) -- node[cost, right] {2} (v2);
			\draw[arcEntering] (u3) -- node[cost, right] {4} (v3);
			\draw[arcEntering] (u1) to[bend right=20] node[cost, below, pos=0.3] {5} (v2);

			% Arcos internos a X
			\draw[arc] (v1) -- node[cost, above] {1} (v2);
			\draw[arc] (v2) -- node[cost, above] {2} (v3);

			% Arcos saindo de X
			\draw[arc] (v1) to[bend right=30] node[cost, left, pos=0.3] {2} (u1);

			% Região X
			\draw[orange!60!black, thick, dashed, rounded corners=8pt]
			(-0.3, 0.3) rectangle (4.3, -1.3);
			\node[orange!80!black, font=\bfseries\small] at (4.8, 0.1) {$X$};

			\node[font=\small, green!60!black] at (2, -2.2) {$\Delta(X) = 2$};
		\end{scope}

		% Seta indicando transformação
		\draw[->, ultra thick, blue!60!black] (5.3, 0.5) -- node[above, font=\small] {subtrai $\Delta(X)$} (6.7, 0.5);

		% ===== DEPOIS (direita) =====
		\begin{scope}[xshift=7.5cm]
			\node[font=\bfseries, blue!80!black] at (2, 4.2) {Depois: pesos atualizados};

			% Raiz
			\node[vtxRoot] (r0b) at (2, 3) {$r_0$};

			% Vértices fora de X
			\node[vtx] (u1b) at (0, 1.5) {$u_1$};
			\node[vtx] (u2b) at (2, 1.5) {$u_2$};
			\node[vtx] (u3b) at (4, 1.5) {$u_3$};

			% Vértices dentro de X
			\node[vtxX] (v1b) at (0.5, -0.5) {$v_1$};
			\node[vtxX] (v2b) at (2, -0.5) {$v_2$};
			\node[vtxX] (v3b) at (3.5, -0.5) {$v_3$};

			% Arcos da raiz (inalterados)
			\draw[arc] (r0b) -- node[cost, left, pos=0.4] {1} (u1b);
			\draw[arc] (r0b) -- node[cost, right] {2} (u2b);
			\draw[arc] (r0b) -- node[cost, right, pos=0.4] {1} (u3b);

			% Arcos externos a X (inalterados)
			\draw[arc] (u1b) to[bend left=15] node[cost, above] {1} (u2b);
			\draw[arc] (u2b) to[bend left=15] node[cost, above] {3} (u3b);

			% Arcos entrando em X (atualizados)
			\draw[arcEntering] (u1b) -- node[cost, left] {1} (v1b);
			\draw[arcTight] (u2b) -- node[costTight, right] {0} (v2b);
			\draw[arcEntering] (u3b) -- node[cost, right] {2} (v3b);
			\draw[arcEntering] (u1b) to[bend right=20] node[cost, below, pos=0.3] {3} (v2b);

			% Arcos internos a X (inalterados)
			\draw[arc] (v1b) -- node[cost, above] {1} (v2b);
			\draw[arc] (v2b) -- node[cost, above] {2} (v3b);

			% Arcos saindo de X (inalterados)
			\draw[arc] (v1b) to[bend right=30] node[cost, left, pos=0.3] {2} (u1b);

			% Região X
			\draw[orange!60!black, thick, dashed, rounded corners=8pt]
			(-0.3, 0.3) rectangle (4.3, -1.3);
			\node[orange!80!black, font=\bfseries\small] at (4.8, 0.1) {$X$};

			\node[font=\small, blue!70!black] at (2, -2.2) {Arco \textcolor{blue!70!black}{justo} $\to A_0$};
		\end{scope}
	\end{tikzpicture}
	\caption{Ilustração da função \texttt{update\_weights\_in\_X} em \(D_{32}\). À esquerda, o dígrafo antes da atualização, com os arcos \textcolor{red!70!black}{em vermelho} entrando em \(X\) e \(\Delta(X) = 2\). À direita, após subtrair \(\Delta(X)\) de cada arco entrando em \(X\): o peso $(u_1, v_1)$ reduz de 3 para 1, $(u_2, v_2)$ de 2 para \textcolor{blue!70!black}{\textbf{0}} (torna-se justo), $(u_3, v_3)$ de 4 para 2, e $(u_1, v_2)$ de 5 para 3. O arco justo é adicionado a \(A_0\) e \(D_0\). Note que os arcos da raiz e arcos internos/externos a \(X\) permanecem inalterados.}
\end{figure}

\subsection{Verificação de arborescência}

Esta função verifica se um dígrafo \(D\) contém uma r-arborescência com raiz \(r_0\). Utiliza busca em profundidade (DFS) a partir da raiz para verificar se todos os vértices são alcançáveis.

Recebe como entrada um dígrafo \texttt{D} e a raiz \texttt{r0}. A implementação constrói uma árvore DFS a partir de \texttt{r0} usando \texttt{nx.dfs\_tree} (linha 2), que devolve um subdigrafo contendo apenas os vértices alcançáveis a partir da raiz seguindo arcos. Em seguida, compara o número de vértices da árvore DFS com o número total de vértices de \texttt{D} (linha 3).

A função devolve \texttt{True} se todos os vértices são alcançáveis (indicando presença de r-arborescência), \texttt{False} caso contrário. A complexidade é \(O(n+m)\), onde \(n=|V|\) e \(m=|A|\), devido à busca em profundidade. Precisamos dessa verificação para garantir que a Fase~1 produza um dígrafo \(D_0\) que contenha uma r-arborescência antes de prosseguir para a Fase~2.

\begin{tcolorbox}[
		enhanced, breakable,
		colframe=blue!60!black, colback=blue!2,
		colbacktitle=blue!15, coltitle=black,
		title={Verificação de arborescência},
		boxed title style={sharp corners, boxrule=0.6pt},
		sharp corners, boxrule=0.6pt
	]
	\emph{Verifica se o dígrafo D contém uma r-arborescência com raiz r0, usando busca em profundidade para testar alcançabilidade de todos os vértices.}
	\tcblower
	\begin{lstlisting}[language=Python]
def has_arborescence(D, r0):
    tree = nx.dfs_tree(D, r0)
    return tree.number_of_nodes() == D.number_of_nodes()
\end{lstlisting}
\end{tcolorbox}

\subsection{Fase 1: Elevação de potenciais e construção de \texorpdfstring{\(A_0\)}{A_0}}

A seguir apresentamos a função principal da Fase~1, responsável por elevar os potenciais dos vértices iterativamente até que cada conjunto de vértices possua ao menos um arco justo entrando. O processo utiliza componentes fortemente conexas para identificar quais conjuntos necessitam elevação.

Recebe como entrada um dígrafo \texttt{D\_original} e a raiz \texttt{r0}. A implementação cria uma cópia do dígrafo original (linha 2) para preservar a entrada, inicializa estruturas auxiliares \texttt{A\_zero} (lista de arcos justos), \texttt{Dual\_list} (lista de pares \((X, \Delta(X))\) para fins de validação dual), e \texttt{D\_zero} (dígrafo de arcos justos) (linhas 3-5). Um contador de iterações é inicializado na linha 6.

O loop principal (linhas 7-22) itera enquanto houver conjuntos sem arcos justos entrando. Em cada iteração, incrementa-se o contador (linha 8), calcula-se as componentes fortemente conexas de \(D_0\) usando \texttt{nx.condensation} (linha 9), que devolve um grafo acíclico dirigido (DAG, do inglês \emph{directed acyclic graph}) onde cada vértice representa uma componente e contém o atributo \texttt{"members"} com os vértices originais. Utilizamos componentes fortemente conexas porque elas identificam naturalmente os conjuntos maximais de vértices que ainda não possuem arcos justos entrando, evitando a necessidade de rastrear manualmente quais conjuntos já foram processados.

Em seguida, identificam-se as fontes (componentes sem arcos entrando) no grafo de condensação (linha 10). Se há apenas uma fonte, significa que todos os vértices estão em uma única componente alcançável pela raiz através de arcos justos, garantindo que \(D_0\) contém uma r-arborescência e encerrando o loop (linhas 11-12).

Para cada fonte \(u\) no grafo de condensação (linha 13), obtém-se o conjunto \(X\) de vértices da componente (linha 14). Se \(r_0 \in X\), a fonte é ignorada (linhas 15-16), pois a componente contendo a raiz não necessita elevação. Caso contrário, identificam-se os arcos entrando em \(X\) usando \texttt{get\_arcs\_entering\_X} (linha 17), calcula-se o peso mínimo \(\Delta(X)\) usando \texttt{get\_minimum\_weight\_cut} (linha 18), e atualiza-se os pesos com \texttt{update\_weights\_in\_X}, registrando novos arcos justos (linha 19). A elevação simultânea de potenciais para todos os vértices de \(X\) mantém a propriedade de que arcos internos a \(X\) permanecem com o mesmo custo reduzido relativo, preservando a correção do algoritmo. Finalmente, adiciona-se \((X, \Delta(X))\) à lista dual se \(\Delta(X) > 0\) (linhas 20-21), permitindo verificação posterior das condições de otimalidade dual.

A função devolve \texttt{A\_zero} (lista de arcos justos) e \texttt{Dual\_list} (pares \((X, \Delta(X))\) para validação). A complexidade é \(O(nm)\) no pior caso, com \(O(n)\) iterações, cada uma custando \(O(m)\) para calcular componentes e atualizar pesos.

\begin{tcolorbox}[
		enhanced, breakable,
		colframe=blue!60!black, colback=blue!2,
		colbacktitle=blue!15, coltitle=black,
		title={Fase 1: Elevação de potenciais e construção de $A_0$},
		boxed title style={sharp corners, boxrule=0.6pt},
		sharp corners, boxrule=0.6pt
	]
	\emph{Eleva iterativamente os potenciais dos vértices até que cada conjunto possua ao menos um arco justo entrando. Devolve a lista $A_0$ de arcos justos e a lista de pares $(X, \Delta(X))$ para validação dual.}
	\tcblower
	\begin{lstlisting}[language=Python, basicstyle=\ttfamily\fontsize{8}{9}\selectfont]
def phase1(D_original, r0):
    D_copy = D_original.copy()
    A_zero = []
    Dual_list = []
    D_zero = build_D_zero(D_copy)
    iteration = 0
    while True:
        iteration += 1
        C = nx.condensation(D_zero)
        sources = [x for x in C.nodes() if C.in_degree(x) == 0]
        if len(sources) == 1:
            break
        for u in sources:
            X = C.nodes[u]["members"]
            if r0 in X:
                continue
            arcs = get_arcs_entering_X(D_copy, X)
            min_weight = get_minimum_weight_cut(arcs)
            update_weights_in_X(D_copy, arcs, min_weight, A_zero, D_zero)
            if min_weight != 0:
                Dual_list.append((X, min_weight)) 
    return A_zero, Dual_list
\end{lstlisting}
\end{tcolorbox}

A seguir ilustramos a execução da função \texttt{phase1} no dígrafo \(D_{32}\) estendido com a raiz \(r_0\). A figura mostra três estados principais: o dígrafo original \(D\) com seus pesos, o dígrafo \(D_0\) inicial (vazio, sem arcos), e o dígrafo \(D_0\) final após as iterações de elevação de potenciais, contendo apenas os arcos justos (em azul) que formam uma r-arborescência.

\begin{figure}[H]
	\centering
	\begin{tikzpicture}[>=Stealth, scale=0.85, every node/.style={scale=0.85}]
		% Estilos
		\tikzset{
			vtx/.style={circle, draw, fill=blue!8, thick, inner sep=1.2pt, minimum size=6.5mm},
			vtxRoot/.style={circle, draw, fill=red!15, thick, inner sep=1.2pt, minimum size=6.5mm},
			vtxX/.style={circle, draw, fill=orange!20, thick, inner sep=1.2pt, minimum size=6.5mm},
			arc/.style={->, thick, gray!60},
			arcTight/.style={->, ultra thick, blue!70!black},
			cost/.style={font=\scriptsize, fill=white, inner sep=1pt, rounded corners=1pt},
			costTight/.style={font=\scriptsize\bfseries, fill=blue!10, inner sep=2pt, draw=blue!70!black, rounded corners=1pt}
		}

		% ===== DÍGRAFO ORIGINAL D (esquerda) =====
		\begin{scope}
			\node[font=\bfseries, blue!80!black] at (2, 4.2) {Dígrafo original $D$};

			% Raiz
			\node[vtxRoot] (r0) at (2, 3) {$r_0$};

			% Vértices fora de X
			\node[vtx] (u1) at (0, 1.5) {$u_1$};
			\node[vtx] (u2) at (2, 1.5) {$u_2$};
			\node[vtx] (u3) at (4, 1.5) {$u_3$};

			% Vértices dentro de X
			\node[vtxX] (v1) at (0.5, -0.5) {$v_1$};
			\node[vtxX] (v2) at (2, -0.5) {$v_2$};
			\node[vtxX] (v3) at (3.5, -0.5) {$v_3$};

			% Arcos da raiz
			\draw[arc] (r0) -- node[cost, left, pos=0.4] {1} (u1);
			\draw[arc] (r0) -- node[cost, right] {2} (u2);
			\draw[arc] (r0) -- node[cost, right, pos=0.4] {1} (u3);

			% Arcos externos a X
			\draw[arc] (u1) to[bend left=15] node[cost, above] {1} (u2);
			\draw[arc] (u2) to[bend left=15] node[cost, above] {3} (u3);

			% Arcos entrando em X
			\draw[arc] (u1) -- node[cost, left] {3} (v1);
			\draw[arc] (u2) -- node[cost, right] {2} (v2);
			\draw[arc] (u3) -- node[cost, right] {4} (v3);
			\draw[arc] (u1) to[bend right=20] node[cost, below, pos=0.3] {5} (v2);

			% Arcos internos a X
			\draw[arc] (v1) -- node[cost, above] {1} (v2);
			\draw[arc] (v2) -- node[cost, above] {2} (v3);

			% Arcos saindo de X
			\draw[arc] (v1) to[bend right=30] node[cost, left, pos=0.3] {2} (u1);

			\node[font=\small, gray!70!black] at (2, -2) {Pesos originais};
		\end{scope}

		% ===== D_0 INICIAL (centro) =====
		\begin{scope}[xshift=6cm]
			\node[font=\bfseries, blue!80!black] at (2, 4.2) {$D_0$ inicial (linha 5)};

			% Vértices apenas, sem arcos
			\node[vtxRoot] (r0i) at (2, 3) {$r_0$};
			\node[vtx] (u1i) at (0, 1.5) {$u_1$};
			\node[vtx] (u2i) at (2, 1.5) {$u_2$};
			\node[vtx] (u3i) at (4, 1.5) {$u_3$};
			\node[vtxX] (v1i) at (0.5, -0.5) {$v_1$};
			\node[vtxX] (v2i) at (2, -0.5) {$v_2$};
			\node[vtxX] (v3i) at (3.5, -0.5) {$v_3$};

			\node[font=\small, gray!70!black] at (2, -2) {Sem arcos (vazio)};
		\end{scope}

		% ===== D_0 FINAL (direita) =====
		\begin{scope}[xshift=12cm]
			\node[font=\bfseries, blue!80!black] at (2, 4.2) {$D_0$ final (após loop)};

			% Vértices
			\node[vtxRoot] (r0f) at (2, 3) {$r_0$};
			\node[vtx] (u1f) at (0, 1.5) {$u_1$};
			\node[vtx] (u2f) at (2, 1.5) {$u_2$};
			\node[vtx] (u3f) at (4, 1.5) {$u_3$};
			\node[vtxX] (v1f) at (0.5, -0.5) {$v_1$};
			\node[vtxX] (v2f) at (2, -0.5) {$v_2$};
			\node[vtxX] (v3f) at (3.5, -0.5) {$v_3$};

			% Arcos justos (peso 0)
			\draw[arcTight] (r0f) -- node[costTight, left, pos=0.4] {0} (u1f);
			\draw[arcTight] (r0f) -- node[costTight, right, pos=0.4] {0} (u3f);
			\draw[arcTight] (u1f) to[bend left=15] node[costTight, above] {0} (u2f);
			\draw[arcTight] (u1f) -- node[costTight, left] {0} (v1f);
			\draw[arcTight] (u2f) -- node[costTight, right] {0} (v2f);
			\draw[arcTight] (v2f) -- node[costTight, above] {0} (v3f);

			\node[font=\small, blue!70!black] at (2, -2) {Arcos justos em $A_0$};
		\end{scope}

		% Setas indicando progressão
		\draw[->, ultra thick, gray!50] (4.5, 1) -- node[above, font=\small] {elevação} (5.5, 1);
		\draw[->, ultra thick, gray!50] (10.5, 1) -- node[above, font=\small] {iterações} (11.5, 1);
	\end{tikzpicture}
	\caption{Execução da função \texttt{phase1} em \(D_{32}\). À esquerda, o dígrafo original \(D\) com pesos dos arcos. Ao centro, \(D_0\) inicial após linha 5 (\texttt{build\_D\_zero}), contendo apenas vértices sem arcos. À direita, \(D_0\) final após o loop de elevação de potenciais, contendo apenas os arcos \textcolor{blue!70!black}{justos} (custo reduzido zero) que formam uma r-arborescência. Durante as iterações (linhas 7-22), os potenciais são elevados para cada componente sem arcos justos entrando, até que todos os vértices sejam alcançáveis a partir de \(r_0\) através de arcos em \(D_0\).}
\end{figure}

A seguir ilustramos a execução da função \texttt{phase2} em \(D_{32}\), mostrando como a r-arborescência é construída incrementalmente a partir do conjunto \(A_0\) de arcos justos obtidos da Fase~1. A figura apresenta quatro estados: o conjunto inicial \(A_0\) com 6 arcos justos, e três estados intermediários da arborescência \texttt{Arb} sendo construída, destacando em verde os arcos adicionados em cada iteração.

\begin{figure}[H]
	\centering
	\begin{tikzpicture}[>=Stealth, scale=0.72, every node/.style={scale=0.72}]
		% Estilos
		\tikzset{
			vtx/.style={circle, draw, fill=blue!8, thick, inner sep=1.2pt, minimum size=6.5mm},
			vtxRoot/.style={circle, draw, fill=red!15, thick, inner sep=1.2pt, minimum size=6.5mm},
			vtxIn/.style={circle, draw, fill=green!15, thick, inner sep=1.2pt, minimum size=6.5mm},
			vtxOut/.style={circle, draw, fill=gray!10, thick, inner sep=1.2pt, minimum size=6.5mm},
			arc/.style={->, thick, blue!70!black},
			arcNew/.style={->, ultra thick, green!70!black},
			cost/.style={font=\scriptsize, fill=white, inner sep=1pt}
		}

		% ===== A_0 (esquerda superior) =====
		\begin{scope}
			\node[font=\bfseries, blue!80!black] at (2, 4.5) {$A_0$ (arcos justos)};

			\node[vtxRoot] (r0) at (2, 3.2) {$r_0$};
			\node[vtx] (u1) at (0, 1.7) {$u_1$};
			\node[vtx] (u2) at (2, 1.7) {$u_2$};
			\node[vtx] (u3) at (4, 1.7) {$u_3$};
			\node[vtx] (v1) at (0.5, 0) {$v_1$};
			\node[vtx] (v2) at (2, 0) {$v_2$};
			\node[vtx] (v3) at (3.5, 0) {$v_3$};

			\draw[arc] (r0) -- node[cost, left, pos=0.3] {0} (u1);
			\draw[arc] (r0) -- node[cost, right, pos=0.3] {0} (u3);
			\draw[arc] (u1) to[bend left=12] node[cost, above, pos=0.4] {0} (u2);
			\draw[arc] (u1) -- node[cost, left] {0} (v1);
			\draw[arc] (u2) -- node[cost, right] {0} (v2);
			\draw[arc] (v2) -- node[cost, above] {0} (v3);

			\node[font=\small, gray!70!black] at (2, -1) {6 arcos com custo 0};
		\end{scope}

		% ===== Iteração 1 (direita superior) =====
		\begin{scope}[xshift=6.5cm]
			\node[font=\bfseries, blue!80!black] at (2, 4.5) {Iteração 1: $|$Arb$| = 1$};

			\node[vtxRoot] (r01) at (2, 3.2) {$r_0$};
			\node[vtxIn] (u11) at (0, 1.7) {$u_1$};
			\node[vtxOut] (u21) at (2, 1.7) {$u_2$};
			\node[vtxOut] (u31) at (4, 1.7) {$u_3$};
			\node[vtxOut] (v11) at (0.5, 0) {$v_1$};
			\node[vtxOut] (v21) at (2, 0) {$v_2$};
			\node[vtxOut] (v31) at (3.5, 0) {$v_3$};

			\draw[arcNew] (r01) -- node[cost, left, pos=0.3, fill=green!10] {1} (u11);

			\node[font=\small, green!70!black] at (2, -1) {Adiciona $(r_0, u_1)$};
		\end{scope}

		% ===== Iteração 2 (esquerda inferior) =====
		\begin{scope}[yshift=-6.2cm]
			\node[font=\bfseries, blue!80!black] at (2, 4.5) {Iteração 2: $|$Arb$| = 2$};

			\node[vtxRoot] (r02) at (2, 3.2) {$r_0$};
			\node[vtxIn] (u12) at (0, 1.7) {$u_1$};
			\node[vtxOut] (u22) at (2, 1.7) {$u_2$};
			\node[vtxIn] (u32) at (4, 1.7) {$u_3$};
			\node[vtxOut] (v12) at (0.5, 0) {$v_1$};
			\node[vtxOut] (v22) at (2, 0) {$v_2$};
			\node[vtxOut] (v32) at (3.5, 0) {$v_3$};

			\draw[arc] (r02) -- node[cost, left, pos=0.3] {1} (u12);
			\draw[arcNew] (r02) -- node[cost, right, pos=0.3, fill=green!10] {1} (u32);

			\node[font=\small, green!70!black] at (2, -1) {Adiciona $(r_0, u_3)$};
		\end{scope}

		% ===== Iteração 4 (direita inferior) =====
		\begin{scope}[xshift=6.5cm, yshift=-6.2cm]
			\node[font=\bfseries, blue!80!black] at (2, 4.5) {Iteração 4: $|$Arb$| = 4$};

			\node[vtxRoot] (r04) at (2, 3.2) {$r_0$};
			\node[vtxIn] (u14) at (0, 1.7) {$u_1$};
			\node[vtxIn] (u24) at (2, 1.7) {$u_2$};
			\node[vtxIn] (u34) at (4, 1.7) {$u_3$};
			\node[vtxIn] (v14) at (0.5, 0) {$v_1$};
			\node[vtxOut] (v24) at (2, 0) {$v_2$};
			\node[vtxOut] (v34) at (3.5, 0) {$v_3$};

			\draw[arc] (r04) -- node[cost, left, pos=0.3] {1} (u14);
			\draw[arc] (r04) -- node[cost, right, pos=0.3] {1} (u34);
			\draw[arc] (u14) to[bend left=12] node[cost, above, pos=0.4] {1} (u24);
			\draw[arcNew] (u14) -- node[cost, left, fill=green!10] {3} (v14);

			\node[font=\small, green!70!black] at (2, -1) {Adiciona $(u_1, v_1)$};
		\end{scope}

		% Setas de progressão
		\draw[->, ultra thick, gray!50] (4.8, 2) -- node[above, font=\small] {linha 6-10} (5.7, 2);
		\draw[->, ultra thick, gray!50] (2, -1.5) -- node[left, font=\small] {linha 6-10} (2, -2.4);
		\draw[->, ultra thick, gray!50] (4.8, -4.2) -- node[above, font=\small] {linha 6-10} (5.7, -4.2);
	\end{tikzpicture}
	\caption{Execução da função \texttt{phase2} em \(D_{32}\). Superior esquerdo: conjunto \(A_0\) com 6 arcos justos (custo reduzido zero) obtidos da Fase~1. Superior direito: Iteração 1 — adiciona arco $(r_0, u_1)$ pois $r_0 \in$ Arb e $u_1 \notin$ Arb. Inferior esquerdo: Iteração 2 — adiciona $(r_0, u_3)$. Inferior direito: Iteração 4 — após adicionar $(u_1, u_2)$ na iteração 3, adiciona $(u_1, v_1)$. Vértices \textcolor{green!70!black}{verdes} foram recém-adicionados, vértices \textcolor{gray!70!black}{cinzas} ainda não pertencem a Arb. O processo continua até que todos os 6 arcos de \(A_0\) sejam incluídos, formando uma r-arborescência com pesos originais de \(D\).}
\end{figure}

As funções auxiliares implementadas nesta seção correspondem diretamente aos passos da Fase~1 do algoritmo de András Frank da seguinte forma:

\begin{tcolorbox}[
		enhanced, breakable,
		colframe=purple!60!black, colback=purple!5,
		colbacktitle=purple!15, coltitle=black,
		title={Correspondência entre Teoria e Implementação — Fase 1},
		boxed title style={sharp corners, boxrule=0.6pt},
		sharp corners, boxrule=0.6pt
	]
	\textbf{Passo 1 — Inicialização:}
	\begin{itemize}
		\item \textbf{Descrição teórica:} Defina \(y(v) := 0\) para todo \(v \in V\).
		\item \textbf{Implementação:} A função \texttt{build\_D\_zero(D)} inicializa o dígrafo \(D_0\) vazio, que será populado apenas com arcos justos. Implicitamente, os potenciais iniciam em zero, pois os pesos no dígrafo \(D\) representam os custos reduzidos \(c_y(u,v) = c(u,v) - y(v)\). Com \(y(v) = 0\), temos \(c_y = c\) no início.
	\end{itemize}

	\vspace{2mm}
	\textbf{Passo 2 — Iteração de elevação de potenciais:}
	\begin{itemize}
		\item \textbf{Descrição teórica:} Enquanto existir conjunto \(X \subseteq V \setminus \{r\}\) sem arco justo entrando:
		      \begin{itemize}
			      \item Calcule \(\Delta(X) := \min\{c(u,v) - y(v) : u \notin X, v \in X\}\).
			      \item Para cada \(v \in X\), atualize \(y(v) := y(v) + \Delta(X)\).
		      \end{itemize}
		\item \textbf{Implementação:} Esse processo de iteração é realizado pela composição sequencial de três funções auxiliares:
		      \begin{enumerate}
			      \item \texttt{get\_arcs\_entering\_X(D, X)}: Identifica o conjunto \(\{(u,v) : u \notin X, v \in X\}\), isto é, todos os arcos que cruzam a fronteira de \(X\). Essa função corresponde diretamente à definição do conjunto sobre o qual o mínimo é calculado na fórmula \(\Delta(X)\).

			      \item \texttt{get\_minimum\_weight\_cut(arcs)}: Calcula \(\min\{\text{data}["w"] : (u,v,\text{data}) \in \text{arcs}\}\), que é exatamente \(\Delta(X) = \min\{c_y(u,v) : u \notin X, v \in X\}\). Como os pesos no dígrafo já representam custos reduzidos (são atualizados a cada iteração), essa função devolve precisamente o valor teórico de \(\Delta(X)\).

			      \item \texttt{update\_weights\_in\_X(D, arcs, min\_weight, A\_zero, D\_zero)}: Implementa a atualização dos potenciais. Para cada arco \((u,v)\) entrando em \(X\), subtrai \texttt{min\_weight} de \texttt{D[u][v]["w"]}, efetivamente calculando o novo custo reduzido:
			            \[c_y'(u,v) = c_y(u,v) - \Delta(X) = \]
			            \[c(u,v) - y(v) - \Delta(X) = \]
			            \[c(u,v) - \bigl(y(v) + \Delta(X)\bigr) = c(u,v) - y'(v), \]
			            onde \(y'(v) = y(v) + \Delta(X)\) é o novo potencial. Arcos cujo custo reduzido atinge zero (\texttt{D[u][v]["w"] == 0}) são adicionados a \(A_0\) e \(D_0\), tornando-se \textbf{justos}.
		      \end{enumerate}
	\end{itemize}

	\vspace{2mm}
	\textbf{Passo 3 — Construção de \(A_0\):}
	\begin{itemize}
		\item \textbf{Descrição teórica:} Defina \(A_0 := \{a \in A : c_y(a) = 0\}\), o conjunto de arcos justos.
		\item \textbf{Implementação:} A construção de \(A_0\) ocorre de forma incremental durante as iterações do Passo~2. Cada chamada a \texttt{update\_weights\_in\_X} verifica quais arcos atingiram custo reduzido zero e os adiciona tanto à lista \texttt{A\_zero} quanto ao dígrafo \texttt{D\_zero}. Esse processo continua até que a função principal da Fase~1 (que será apresentada adiante) determine que cada componente fortemente conexa em \(D_0\) (exceto a raiz) possui ao menos um arco justo entrando, garantindo que \(A_0\) é suficiente para formar a base de uma \(r\)-arborescência.
		\item O resultado final é o conjunto completo \(A_0 = \{a \in A : c_y(a) = 0\}\), usado na Fase~2 para construir a arborescência ótima através de uma seleção gulosa de arcos justos.
	\end{itemize}
\end{tcolorbox}

\subsection{Fase 2: Construção da arborescência}
Esta é a função principal da Fase~2, responsável por construir a r-arborescência de custo mínimo a partir do conjunto \(A_0\) de arcos justos. A construção é incremental: inicia-se com a raiz e adiciona-se iterativamente arcos de \(A_0\) que conectam vértices já incluídos a novos vértices, garantindo que cada vértice não-raiz receba exatamente um arco de entrada.

Recebe como entrada um dígrafo \texttt{D\_original}, a raiz \texttt{r0}, e a lista \texttt{A\_zero} de arcos justos. A implementação cria um novo dígrafo vazio \texttt{Arb} (linha 2) e adiciona a raiz (linha 3).

O loop principal (linhas 5-12) itera \(n-1\) vezes, onde \(n = |V|\), pois uma r-arborescência tem exatamente \(|V|-1\) arcos. Em cada iteração:
\begin{enumerate}\setlength{\itemsep}{2pt}
	\item Percorre os arcos \((u,v)\) de \texttt{A\_zero} (linha 6).
	\item Verifica se \(u\) já está em \texttt{Arb} e \(v\) ainda não (linha 7).
	\item Se sim, obtém os dados do arco do dígrafo original (linha 8) e adiciona \((u,v)\) a \texttt{Arb} (linha 9).
	\item Interrompe o loop interno para reiniciar a busca, garantindo descoberta em largura (linha 10).
\end{enumerate}

A função devolve o dígrafo \texttt{Arb} representando a r-arborescência de custo mínimo. A complexidade é \(O(nm)\) no pior caso, pois cada uma das \(O(n)\) iterações pode percorrer todos os \(O(m)\) arcos de \texttt{A\_zero}.

\begin{tcolorbox}[
		enhanced, breakable,
		colframe=blue!60!black, colback=blue!2,
		colbacktitle=blue!15, coltitle=black,
		title={Fase 2: Construção da arborescência},
		boxed title style={sharp corners, boxrule=0.6pt},
		sharp corners, boxrule=0.6pt
	]
	\emph{Constrói incrementalmente a r-arborescência a partir de $A_0$, adicionando iterativamente arcos que conectam vértices já incluídos a novos vértices.}
	\tcblower
	\begin{lstlisting}[language=Python]
def phase2(D_original, r0, A_zero):
    Arb = nx.DiGraph()
    Arb.add_node(r0)
    n = len(D_original.nodes())
    for _ in range(n - 1):
        for u, v in A_zero:
            if u in Arb.nodes() and v not in Arb.nodes():
                edge_data = D_original.get_edge_data(u, v)
                Arb.add_edge(u, v, **edge_data)
                break
    return Arb
\end{lstlisting}
\end{tcolorbox}

Apresentamos também uma versão alternativa da Fase~2 que utiliza busca em largura (BFS) para construir a r-arborescência de forma mais eficiente. Diferentemente da versão anterior que itera \(n-1\) vezes sobre todos os arcos, esta implementação usa uma fila de prioridade para explorar os arcos em ordem, evitando buscas lineares repetidas.

Recebe como entrada um dígrafo \texttt{D\_original}, a raiz \texttt{r0}, e a lista \texttt{A\_zero} de arcos justos. A implementação começa criando um dígrafo auxiliar \texttt{Arb} (linha 2) onde cada arco de \texttt{A\_zero} recebe um peso igual ao seu índice na lista (linhas 3-4), estabelecendo uma ordem de exploração. Inicializa-se o conjunto \texttt{V} de vértices visitados contendo apenas a raiz (linha 5) e uma fila de prioridade vazia \texttt{q} (linha 6).

Todos os arcos que saem da raiz em \texttt{Arb} são adicionados à fila de prioridade (linhas 7-8), usando o peso (índice) como critério de ordenação. Cria-se então o dígrafo \texttt{A} que conterá a arborescência resultante (linha 9).

O loop principal (linhas 10-17) extrai arcos da fila de prioridade em ordem crescente de índice. Para cada arco \((u,v)\) extraído (linha 11), verifica-se se o vértice destino \(v\) já foi visitado (linha 12); em caso positivo, o arco é ignorado via \texttt{continue} (linha 13). Caso contrário, adiciona-se o arco \((u,v)\) à arborescência \texttt{A} com o peso original de \texttt{D\_original} (linha 14), marca-se \(v\) como visitado (linha 15), e todos os arcos que saem de \(v\) em \texttt{Arb} são adicionados à fila de prioridade para exploração futura (linhas 16-17).

A função devolve o dígrafo \texttt{A} representando a r-arborescência de custo mínimo. A complexidade é \(O(m \log m)\), onde \(m = |A_0|\), devido às operações de inserção e remoção na fila de prioridade. Esta versão é mais eficiente que a anterior quando \(|A_0|\) é grande, pois evita percorrer todos os arcos em cada iteração.

\begin{tcolorbox}[
		enhanced, breakable,
		colframe=blue!60!black, colback=blue!2,
		colbacktitle=blue!15, coltitle=black,
		title={Fase 2 (versão BFS): Construção da arborescência com fila de prioridade},
		boxed title style={sharp corners, boxrule=0.6pt},
		sharp corners, boxrule=0.6pt
	]
	\emph{Constrói a r-arborescência usando busca em largura guiada por fila de prioridade, explorando arcos de $A_0$ em ordem e evitando buscas lineares repetidas. Complexidade $O(m \log m)$.}
	\tcblower
	\begin{lstlisting}[language=Python]
def phase2_v2(D_original, r0, A_zero):
    Arb = nx.DiGraph()
    for i, (u, v) in enumerate(A_zero):
        Arb.add_edge(u, v, w=i)
    V = {r0}
    q = []
    for u, v, data in Arb.out_edges(r0, data=True):
        heapq.heappush(q, (data["w"], u, v))
    A = nx.DiGraph()
    while q:
        _, u, v = heapq.heappop(q)
        if v in V:
            continue
        A.add_edge(u, v, w=D_original[u][v]["w"])
        V.add(v)
        for x, y, data in Arb.out_edges(v, data=True):
            heapq.heappush(q, (data["w"], x, y))
    return A
\end{lstlisting}
\end{tcolorbox}

As duas versões da Fase~2 implementadas acima correspondem diretamente ao Passo~4 da descrição teórica do algoritmo de András Frank:

\begin{tcolorbox}[
		enhanced, breakable,
		colframe=purple!60!black, colback=purple!5,
		colbacktitle=purple!15, coltitle=black,
		title={Correspondência entre Teoria e Implementação — Fase 2},
		boxed title style={sharp corners, boxrule=0.6pt},
		sharp corners, boxrule=0.6pt
	]
	\textbf{Passo 4 — Construção da arborescência (caso acíclico):}
	\begin{itemize}
		\item \textbf{Descrição teórica:} Se \((V,A_0)\) forma uma r-arborescência, devolva \(A_0\). Por otimalidade dos potenciais duais, trata-se de uma r-arborescência de custo mínimo.
		\item \textbf{Implementação:} Ambas as versões de \texttt{phase2} constroem uma r-arborescência a partir do conjunto \(A_0\) de arcos justos obtido na Fase~1. A corretude baseia-se no fato de que todos os arcos em \(A_0\) têm custo reduzido zero, e a Fase~1 garante que existe uma r-arborescência formada exclusivamente por arcos justos.
		      \begin{itemize}
			      \item \textbf{Versão 1 (\texttt{phase2}):} Construção incremental por exploração exaustiva. Em cada uma das \(n-1\) iterações, percorre todos os arcos de \(A_0\) procurando um arco \((u,v)\) tal que \(u\) já pertence à arborescência parcial e \(v\) ainda não. Essa abordagem simples corresponde diretamente à ideia teórica de construir a arborescência adicionando um vértice por vez, conectando-o à estrutura existente através de um arco justo. Complexidade: \(O(nm)\).

			      \item \textbf{Versão 2 (\texttt{phase2\_v2}):} Construção por busca em largura guiada por fila de prioridade. Cria um dígrafo auxiliar onde arcos são indexados, usa a fila de prioridade para explorar arcos sistematicamente a partir da raiz, evitando buscas lineares repetidas. Essa versão otimizada mantém a mesma correção teórica — construir uma r-arborescência usando apenas arcos de \(A_0\) — mas melhora a eficiência prática. Complexidade: \(O(m \log m)\).
		      \end{itemize}
	\end{itemize}

	\vspace{2mm}
	\textbf{Nota sobre Passos 5-7 (contração/recursão/expansão):}
	\begin{itemize}
		\item A descrição teórica do algoritmo de András Frank inclui os Passos~5-7 para tratar o caso onde \(A_0\) contém ciclos dirigidos, exigindo contração, resolução recursiva e reexpansão, de forma análoga ao algoritmo de Chu--Liu--Edmonds.
		\item Na implementação apresentada, optamos por uma abordagem não-recursiva baseada em componentes fortemente conexas. A Fase~1 já garante que \(A_0\) formará uma r-arborescência ao término das iterações de elevação de potenciais, eliminando a necessidade de tratar ciclos explicitamente na Fase~2. Essa simplificação é possível porque a elevação de potenciais progressivamente "quebra" todos os ciclos ao criar novos arcos justos que conectam diferentes componentes, até que reste apenas uma única componente fortemente conexa contendo todos os vértices.
		\item Portanto, quando a Fase~2 é executada, o conjunto \(A_0\) já está livre de ciclos e forma uma r-arborescência, correspondendo diretamente ao caso tratado pelo Passo~4 da descrição teórica. A verificação prévia \texttt{has\_arborescence(D, r0)} (realizada pela função principal) confirma essa propriedade antes de invocar a Fase~2.
	\end{itemize}
\end{tcolorbox}

\subsection{Verificação de otimalidade dual}

Esta função verifica se a condição de otimalidade dual é satisfeita para a r-arborescência construída. Segundo a teoria de programação linear dual aplicada ao problema de arborescência de custo mínimo, uma solução é ótima se e somente se cada conjunto \(X \subseteq V \setminus \{r\}\) que teve seu potencial elevado durante a Fase~1 possui exatamente um arco entrando na arborescência final.

Recebe como entrada a arborescência \texttt{Arb} e a lista \texttt{Dual\_list} contendo pares \((X, \Delta(X))\) onde \(X\) é um conjunto de vértices cujos potenciais foram elevados e \(\Delta(X) > 0\) é o valor da elevação. A implementação itera sobre cada par \((X, z)\) na lista dual (linha 2), e para cada conjunto \(X\), percorre todos os arcos \((u,v)\) da arborescência (linha 3). Inicializa um contador \texttt{count} em zero (linha 4) e verifica se o arco cruza a fronteira de \(X\), isto é, se \(u \notin X\) e \(v \in X\) (linha 5). Quando essa condição é satisfeita, incrementa o contador (linha 6) e imediatamente verifica se já há mais de um arco entrando em \(X\) (linha 7). Caso positivo, a condição de otimalidade dual é violada e a função devolve \texttt{False} (linha 8).

A função devolve \texttt{True} se todos os conjuntos em \texttt{Dual\_list} possuem exatamente um arco entrando na arborescência, confirmando que a solução satisfaz as condições de folga complementar da programação linear dual. A complexidade é \(O(km)\), onde \(k = |\texttt{Dual\_list}|\) e \(m = |A|\), pois para cada conjunto dual verifica-se todos os arcos da arborescência.

Esta verificação é fundamental para garantir a correção do algoritmo: a Fase~1 constrói uma solução dual viável (potenciais \(y(v)\)), a Fase~2 constrói uma solução primal viável (arborescência), e esta função confirma que ambas satisfazem as condições de folga complementar, implicando otimalidade pelo teorema da dualidade forte.

\begin{tcolorbox}[
		enhanced, breakable,
		colframe=blue!60!black, colback=blue!2,
		colbacktitle=blue!15, coltitle=black,
		title={Verificação de otimalidade dual},
		boxed title style={sharp corners, boxrule=0.6pt},
		sharp corners, boxrule=0.6pt
	]
	\emph{Verifica se a condição de otimalidade dual é satisfeita, confirmando que cada conjunto dual possui exatamente um arco entrando na arborescência.}
	\tcblower
	\begin{lstlisting}[language=Python]
def check_dual_optimality_condition(Arb, Dual_list):
    for X, z in Dual_list:
        count = 0
        for u, v in Arb.edges():
            if u not in X and v in X:
                count += 1
                if count > 1:
                    return False
    return True
\end{lstlisting}
\end{tcolorbox}

\subsection{O algoritmo completo de András Frank}

Finalmente, apresentamos a função principal que implementa o algoritmo de András Frank para encontrar uma r-arborescência de custo mínimo em um dígrafo com pesos. A função integra as fases de construção dos potenciais duais, obtenção dos arcos justos, construção da arborescência e verificação de otimalidade dual.

\begin{tcolorbox}[
		enhanced, breakable,
		colframe=blue!60!black, colback=blue!2,
		colbacktitle=blue!15, coltitle=black,
		title={Verificação de otimalidade dual},
		boxed title style={sharp corners, boxrule=0.6pt},
		sharp corners, boxrule=0.6pt
	]
	\emph{Implementa o algoritmo completo de András Frank, integrando as fases de construção dos potenciais duais, obtenção dos arcos justos, construção da arborescência e verificação de otimalidade dual.}
	\tcblower
	\begin{lstlisting}[language=Python]
def andras_frank_algorithm(D):
    A_zero, Dual_list = phase1(D,"r0")
    arborescence_frank = phase2(D, "r0", A_zero)
    arborescence_frank_v2 = phase2_v2(D, "r0", A_zero)
    dual_frank = check_dual_optimality_condition(
        arborescence_frank, Dual_list)
    dual_frank_v2 = check_dual_optimality_condition(
        arborescence_frank_v2, Dual_list)
    return arborescence_frank, arborescence_frank_v2, dual_frank, dual_frank_v2
\end{lstlisting}
\end{tcolorbox}

\subsection*{Exemplo de execução do algoritmo}

Aqui ilustraremos cada fase do algoritmo de András Frank: inicialização dos potenciais, iterações de elevação, construção de \(A_0\), e formação da arborescência final. Utilizaremos o dígrafo \(D_{32}\) estendido com a raiz \(r_0\), mostrado na Figura~\ref{fig:frank-exemplo-inicial}.

\begin{figure}[H]
	\centering
	\begin{tikzpicture}[>=Stealth, scale=0.9, every node/.style={scale=0.9}]
		\tikzset{
			vtx/.style={circle, draw, fill=blue!8, thick, inner sep=1.2pt, minimum size=6.5mm},
			vtxRoot/.style={circle, draw, fill=red!15, thick, inner sep=1.2pt, minimum size=6.5mm},
			arc/.style={->, thick, gray!60},
			cost/.style={font=\scriptsize, fill=white, inner sep=1pt, rounded corners=1pt}
		}

		\node[font=\bfseries, blue!80!black] at (3, 4.5) {Dígrafo inicial $D$ com raiz $r_0$};

		% Raiz
		\node[vtxRoot] (r0) at (3, 3) {$r_0$};

		% Vértices camada 1
		\node[vtx] (u1) at (0, 1.5) {$u_1$};
		\node[vtx] (u2) at (3, 1.5) {$u_2$};
		\node[vtx] (u3) at (6, 1.5) {$u_3$};

		% Vértices camada 2
		\node[vtx] (v1) at (1, 0) {$v_1$};
		\node[vtx] (v2) at (3, 0) {$v_2$};
		\node[vtx] (v3) at (5, 0) {$v_3$};

		% Arcos da raiz
		\draw[arc] (r0) -- node[cost, left, pos=0.4] {1} (u1);
		\draw[arc] (r0) -- node[cost, right] {2} (u2);
		\draw[arc] (r0) -- node[cost, right, pos=0.4] {1} (u3);

		% Arcos camada 1
		\draw[arc] (u1) to[bend left=15] node[cost, above] {1} (u2);
		\draw[arc] (u2) to[bend left=15] node[cost, above] {3} (u3);

		% Arcos entrando camada 2
		\draw[arc] (u1) -- node[cost, left] {3} (v1);
		\draw[arc] (u2) -- node[cost, right] {2} (v2);
		\draw[arc] (u3) -- node[cost, right] {4} (v3);
		\draw[arc] (u1) to[bend right=20] node[cost, below, pos=0.3] {5} (v2);

		% Arcos internos camada 2
		\draw[arc] (v1) -- node[cost, above] {1} (v2);
		\draw[arc] (v2) -- node[cost, above] {2} (v3);

		% Arco retorno
		\draw[arc] (v1) to[bend right=30] node[cost, left, pos=0.3] {2} (u1);

		\node[font=\small, gray!70!black] at (3, -1.2) {Pesos originais $c(u,v)$};
	\end{tikzpicture}
	\caption{Dígrafo inicial \(D\) com raiz \(r_0\) e 6 vértices adicionais. O dígrafo contém múltiplos arcos com pesos variados. A Fase~1 do algoritmo iniciará com potenciais \(y(v) = 0\) para todos os vértices, correspondendo aos custos reduzidos iniciais \(c_y(u,v) = c(u,v)\).}
	\label{fig:frank-exemplo-antigo-inicial}
\end{figure}

\paragraph*{Fase 1 — Iteração 1:} O algoritmo inicia com todos os potenciais \(y(v) = 0\) e \(D_0\) vazio (sem arcos justos). Calcula-se as componentes fortemente conexas de \(D_0\): cada vértice forma sua própria componente. As fontes são todos os vértices exceto \(r_0\). Para o conjunto \(X = \{u_1, u_2, u_3\}\), identifica-se os arcos entrando: \((r_0, u_1)\) com peso 1, \((r_0, u_2)\) com peso 2, \((r_0, u_3)\) com peso 1. O mínimo é \(\Delta(X) = 1\). Subtraindo esse valor, os arcos \((r_0, u_1)\) e \((r_0, u_3)\) tornam-se justos (peso 0) e são adicionados a \(A_0\).

\begin{figure}[H]
	\centering
	\begin{tikzpicture}[>=Stealth, scale=0.85, every node/.style={scale=0.85}]
		\tikzset{
			vtx/.style={circle, draw, fill=blue!8, thick, inner sep=1.2pt, minimum size=6.5mm},
			vtxRoot/.style={circle, draw, fill=red!15, thick, inner sep=1.2pt, minimum size=6.5mm},
			vtxX/.style={circle, draw, fill=orange!20, thick, inner sep=1.2pt, minimum size=6.5mm},
			arc/.style={->, thick, gray!60},
			arcTight/.style={->, ultra thick, blue!70!black},
			cost/.style={font=\scriptsize, fill=white, inner sep=1pt},
			costTight/.style={font=\scriptsize\bfseries, fill=blue!10, inner sep=2pt, draw=blue!70!black, rounded corners=1pt}
		}

		% Antes
		\begin{scope}
			\node[font=\bfseries, blue!80!black] at (2, 4.5) {Antes: $\Delta(X_1) = 1$};

			\node[vtxRoot] (r0) at (2, 3) {$r_0$};
			\node[vtxX] (u1) at (0, 1.5) {$u_1$};
			\node[vtxX] (u2) at (2, 1.5) {$u_2$};
			\node[vtxX] (u3) at (4, 1.5) {$u_3$};

			\draw[arc] (r0) -- node[cost, left, pos=0.4] {1} (u1);
			\draw[arc] (r0) -- node[cost, right] {2} (u2);
			\draw[arc] (r0) -- node[cost, right, pos=0.4] {1} (u3);

			\node[font=\small, orange!80!black] at (2, 0.5) {$X_1 = \{u_1, u_2, u_3\}$};
		\end{scope}

		% Depois
		\begin{scope}[xshift=7cm]
			\node[font=\bfseries, blue!80!black] at (2, 4.5) {Depois: arcos justos};

			\node[vtxRoot] (r0b) at (2, 3) {$r_0$};
			\node[vtx] (u1b) at (0, 1.5) {$u_1$};
			\node[vtx] (u2b) at (2, 1.5) {$u_2$};
			\node[vtx] (u3b) at (4, 1.5) {$u_3$};

			\draw[arcTight] (r0b) -- node[costTight, left, pos=0.4] {0} (u1b);
			\draw[arc] (r0b) -- node[cost, right] {1} (u2b);
			\draw[arcTight] (r0b) -- node[costTight, right, pos=0.4] {0} (u3b);

			\node[font=\small, blue!70!black] at (2, 0.5) {2 arcos adicionados a $A\_0$};
		\end{scope}
	\end{tikzpicture}
	\caption{Fase~1, Iteração 1: Elevação de potenciais para \(X\_1 = \{u\_1, u\_2, u\_3\}\). À esquerda, o conjunto \(X\_1\) (em laranja) sem arcos justos entrando. Calcula-se \(\Delta(X\_1) = \min\{1, 2, 1\} = 1\). À direita, após subtrair \(\Delta(X_1)\), os arcos \((r\_0, u\_1)\) e \((r\_0, u\_3)\) tornam-se \textcolor{blue!70!black}{justos} (custo reduzido 0) e são adicionados a \(A\_0\).}
	\label{fig:frank-exemplo-iter1}
\end{figure}

\paragraph*{Fase 1 — Iteração 2:} Com \(A\_0 = \{(r\_0, u\_1), (r\_0, u\_3)\}\), as componentes fortemente conexas são: \(\{r\_0, u\_1, u\_3\}\) e \(\{u\_2\}\), \(\{v\_1\}\), \(\{v\_2\}\), \(\{v\_3\}\). A fonte (excluindo a raiz) é \(\{u\_2\}\). Para \(X = \{u\_2\}\), o único arco entrando é \((r\_0, u\_2)\) com peso atual 1 (após iteração anterior). Portanto \(\Delta(X) = 1\), e após subtração, \((r\_0, u\_2)\) torna-se justo. Também na mesma iteração, para \(X = \{v\_1, v\_2, v\_3\}\), calcula-se \(\Delta(X) = \min\{3, 2, 4, 5\} = 2\), e os arcos são atualizados conforme ilustrado.

\begin{figure}[H]
	\centering
	\begin{tikzpicture}[>=Stealth, scale=0.75, every node/.style={scale=0.75}]
		\tikzset{
			vtx/.style={circle, draw, fill=blue!8, thick, inner sep=1.2pt, minimum size=6mm},
			vtxRoot/.style={circle, draw, fill=red!15, thick, inner sep=1.2pt, minimum size=6mm},
			vtxX/.style={circle, draw, fill=orange!20, thick, inner sep=1.2pt, minimum size=6mm},
			arc/.style={->, thick, gray!60},
			arcTight/.style={->, ultra thick, blue!70!black},
			cost/.style={font=\scriptsize, fill=white, inner sep=1pt},
			costTight/.style={font=\scriptsize\bfseries, fill=blue!10, inner sep=2pt, draw=blue!70!black, rounded corners=1pt}
		}

		\node[font=\bfseries, blue!80!black] at (3, 5.5) {Iteração 2: $\Delta(\{v_1, v_2, v_3\}) = 2$};

		\node[vtxRoot] (r0) at (3, 4) {$r_0$};
		\node[vtx] (u1) at (0.5, 2.5) {$u_1$};
		\node[vtx] (u2) at (3, 2.5) {$u_2$};
		\node[vtx] (u3) at (5.5, 2.5) {$u_3$};
		\node[vtxX] (v1) at (1.5, 0.5) {$v_1$};
		\node[vtxX] (v2) at (3, 0.5) {$v_2$};
		\node[vtxX] (v3) at (4.5, 0.5) {$v_3$};

		% Arcos já justos
		\draw[arcTight] (r0) -- node[costTight, left, pos=0.3] {0} (u1);
		\draw[arcTight] (r0) -- node[costTight, right, pos=0.3] {0} (u3);
		\draw[arcTight] (u1) to[bend left=12] node[costTight, above] {0} (u2);

		% Arcos entrando em X (antes de ficarem justos)
		\draw[arc] (u1) -- node[cost, left, fill=orange!10] {3→1} (v1);
		\draw[arc] (u2) -- node[cost, right, fill=orange!10] {2→0} (v2);
		\draw[arc] (u3) -- node[cost, right] {4→2} (v3);
		\draw[arc] (u1) to[bend right=15] node[cost, below, pos=0.35] {5→3} (v2);

		\node[font=\small, orange!80!black] at (3, -0.5) {Após subtração: $(u_2, v_2)$ torna-se justo};
	\end{tikzpicture}
	\caption{Fase~1, Iteração 2: Para o conjunto \(X = \{v_1, v_2, v_3\}\) (em laranja), calcula-se \(\Delta(X) = \min\{3, 2, 4, 5\} = 2\). Após subtrair esse valor dos arcos entrando em \(X\), o arco \((u_2, v_2)\) atinge custo reduzido 0 e é adicionado a \(A_0\). Note que \((u_1, u_2)\) também se tornou justo na mesma iteração ao processar \(X = \{u_2\}\).}
	\label{fig:frank-exemplo-iter2}
\end{figure}

\paragraph*{Fase 1 — Estado final:} Após mais iterações elevando potenciais para os conjuntos restantes, o dígrafo \(D_0\) de arcos justos fica completo, contendo uma r-arborescência. A Figura~\ref{fig:frank-exemplo-A0-final} mostra o conjunto final \(A_0\) com 6 arcos de custo reduzido zero.

\begin{figure}[H]
	\centering
	\begin{tikzpicture}[>=Stealth, scale=0.85, every node/.style={scale=0.85}]
		\tikzset{
			vtx/.style={circle, draw, fill=blue!8, thick, inner sep=1.2pt, minimum size=6.5mm},
			vtxRoot/.style={circle, draw, fill=red!15, thick, inner sep=1.2pt, minimum size=6.5mm},
			arcTight/.style={->, ultra thick, blue!70!black},
			costTight/.style={font=\scriptsize\bfseries, fill=blue!10, inner sep=2pt, draw=blue!70!black, rounded corners=1pt}
		}

		\node[font=\bfseries, blue!80!black] at (3, 4.5) {$A_0$ final: arcos justos após Fase~1};

		\node[vtxRoot] (r0) at (3, 3) {$r_0$};
		\node[vtx] (u1) at (0.5, 1.5) {$u_1$};
		\node[vtx] (u2) at (3, 1.5) {$u_2$};
		\node[vtx] (u3) at (5.5, 1.5) {$u_3$};
		\node[vtx] (v1) at (1.5, 0) {$v_1$};
		\node[vtx] (v2) at (3, 0) {$v_2$};
		\node[vtx] (v3) at (4.5, 0) {$v_3$};

		\draw[arcTight] (r0) -- node[costTight, left, pos=0.3] {0} (u1);
		\draw[arcTight] (r0) -- node[costTight, right, pos=0.3] {0} (u3);
		\draw[arcTight] (u1) to[bend left=12] node[costTight, above] {0} (u2);
		\draw[arcTight] (u1) -- node[costTight, left] {0} (v1);
		\draw[arcTight] (u2) -- node[costTight, right] {0} (v2);
		\draw[arcTight] (v2) -- node[costTight, above] {0} (v3);

		\node[font=\small, blue!70!black] at (3, -1.2) {$|A_0| = 6$ arcos com custo reduzido $c_y = 0$};
	\end{tikzpicture}
	\caption{Conjunto final \(A_0\) de arcos justos após conclusão da Fase~1. Todos os 6 arcos \textcolor{blue!70!black}{destacados} possuem custo reduzido zero: \((r_0, u_1)\), \((r_0, u_3)\), \((u_1, u_2)\), \((u_1, v_1)\), \((u_2, v_2)\), \((v_2, v_3)\). O dígrafo formado por esses arcos é acíclico e alcança todos os vértices a partir de \(r_0\), satisfazendo as condições para prosseguir à Fase~2.}
	\label{fig:frank-exemplo-A0-final}
\end{figure}

\paragraph*{Fase 2 — Construção da arborescência:} Com \(A_0\) completo e acíclico, a Fase~2 constrói incrementalmente a arborescência final. Inicia-se com \(\texttt{Arb} = \{r_0\}\) e em cada iteração adiciona-se um arco \((u,v) \in A_0\) tal que \(u \in \texttt{Arb}\) e \(v \notin \texttt{Arb}\). A Figura~\ref{fig:frank-exemplo-arborescencia-final} mostra a arborescência resultante.

\begin{figure}[H]
	\centering
	\begin{tikzpicture}[>=Stealth, scale=0.85, every node/.style={scale=0.85}]
		\tikzset{
			vtx/.style={circle, draw, fill=green!15, thick, inner sep=1.2pt, minimum size=6.5mm},
			vtxRoot/.style={circle, draw, fill=red!15, thick, inner sep=1.2pt, minimum size=6.5mm},
			arcArb/.style={->, ultra thick, green!70!black},
			costArb/.style={font=\scriptsize\bfseries, fill=green!10, inner sep=2pt, draw=green!70!black, rounded corners=1pt}
		}

		\node[font=\bfseries, blue!80!black] at (3, 4.5) {Arborescência final (Fase~2)};

		\node[vtxRoot] (r0) at (3, 3) {$r_0$};
		\node[vtx] (u1) at (0.5, 1.5) {$u_1$};
		\node[vtx] (u2) at (3, 1.5) {$u_2$};
		\node[vtx] (u3) at (5.5, 1.5) {$u_3$};
		\node[vtx] (v1) at (1.5, 0) {$v_1$};
		\node[vtx] (v2) at (3, 0) {$v_2$};
		\node[vtx] (v3) at (4.5, 0) {$v_3$};

		\draw[arcArb] (r0) -- node[costArb, left, pos=0.3] {1} (u1);
		\draw[arcArb] (r0) -- node[costArb, right, pos=0.3] {1} (u3);
		\draw[arcArb] (u1) to[bend left=12] node[costArb, above] {1} (u2);
		\draw[arcArb] (u1) -- node[costArb, left] {3} (v1);
		\draw[arcArb] (u2) -- node[costArb, right] {2} (v2);
		\draw[arcArb] (v2) -- node[costArb, above] {2} (v3);

		\node[font=\small, green!70!black] at (3, -1.2) {Custo total: $1+1+1+3+2+2 = 10$};
	\end{tikzpicture}
	\caption{Arborescência de custo mínimo final obtida pela Fase~2. Os pesos mostrados são os \emph{originais} de \(D\), restaurados após a construção. Cada vértice não-raiz possui exatamente um arco de entrada, não há ciclos, e todos os vértices são alcançáveis a partir de \(r_0\). A verificação de otimalidade dual confirma que cada conjunto \(X\) que teve potenciais elevados possui exatamente um arco da arborescência cruzando sua fronteira, garantindo que a solução é ótima.}
	\label{fig:frank-exemplo-arborescencia-final}
\end{figure}

\paragraph*{Verificação de otimalidade dual:} A função \texttt{check\_dual\_optimality\_condition} confirma que para cada par \((X, \Delta(X))\) em \texttt{Dual\_list} (conjuntos cujos potenciais foram elevados com \(\Delta(X) > 0\)), existe exatamente um arco da arborescência final cruzando a fronteira de \(X\). Essa condição, juntamente com os arcos justos, garante que as condições de folga complementar da programação linear dual são satisfeitas, implicando que a arborescência encontrada é de custo mínimo global.

\subsection{Correspondência entre teoria e implementação}

A implementação em Python do algoritmo de András Frank segue fielmente a descrição teórica primal-dual apresentada anteriormente. A tabela abaixo estabelece o paralelo direto entre os passos teóricos e sua realização no código:

\begin{table}[H]
	\centering
	\scriptsize
	\renewcommand{\arraystretch}{1.3}
	\begin{tabular}{>{\raggedright\arraybackslash}p{0.44\textwidth}|>{\raggedright\arraybackslash}p{0.48\textwidth}}
		\toprule
		\textbf{\normalsize Descrição Teórica} & \textbf{\normalsize Implementação Python} \\
		\midrule
		\rowcolor{blue!5}
		\textbf{Passo 1:} Inicialização

		Defina \(y(v) := 0\) para todo \(v \in V\).

		Inicialize \(A_0 := \emptyset\).

		Construa dígrafo vazio \(D_0\) (arcos justos).
		                                       &
		\textbf{Função \texttt{phase1} — Linhas 2--5:}

		\texttt{D\_copy = D\_original.copy()}

		\texttt{A\_zero = []}

		\texttt{D\_zero = build\_D\_zero(D\_copy)}

		\vspace{1mm}
		Potenciais \(y(v) = 0\) implícitos, custos \(c_y = c\).
		\\
		\midrule
		\rowcolor{green!5}
		\textbf{Passo 2:} Elevação de potenciais

		Enquanto \(\exists X \subseteq V \setminus \{r\}\) sem arco justo:

		\quad Calcule \(\Delta(X) := \min\{c_y(u,v) : u \notin X, v \in X\}\)

		\quad Atualize \(y(v) := y(v) + \Delta(X)\), \(\forall v \in X\)

		\quad Adicione arcos com \(c_y = 0\) a \(A_0\)
		                                       &
		\textbf{Loop principal — Linhas 7--22:}

		\texttt{C = nx.condensation(D\_zero)}

		\texttt{sources = [x for x in C.nodes()]}

		\texttt{\quad if C.in\_degree(x) == 0]}

		Para fonte \texttt{u} (exceto raiz):

		\texttt{\quad X = C.nodes[u]["members"]}

		\texttt{\quad arcs = get\_arcs\_entering\_X(D, X)}

		\texttt{\quad min\_w = get\_minimum\_weight\_cut(arcs)}

		\texttt{\quad update\_weights\_in\_X(D, arcs, min\_w,}

		\texttt{\quad\quad A\_zero, D\_zero)}
		\\
		\midrule
		\rowcolor{orange!5}
		\textbf{Passo 2(a):} Identificar arcos entrando

		Determine \(\{(u,v) \in A : u \notin X, v \in X\}\)
		                                       &
		\textbf{Função \texttt{get\_arcs\_entering\_X}:}

		\texttt{return [(u, v, data)}

		\texttt{\quad for u, v, data in D.edges(data=True)}

		\texttt{\quad if u not in X and v in X]}
		\\
		\midrule
		\rowcolor{purple!5}
		\textbf{Passo 2(b):} Calcular \(\Delta(X)\)

		\(\Delta(X) := \min\{c_y(u,v) : u \notin X, v \in X\}\)
		                                       &
		\textbf{Função \texttt{get\_minimum\_weight\_cut}:}

		\texttt{return min(data["w"]}

		\texttt{\quad for \_, \_, data in arcs)}
		\\
		\midrule
		\rowcolor{yellow!5}
		\textbf{Passo 2(c):} Atualizar pesos

		Para \((u,v)\) entrando em \(X\):

		\quad \(c_y(u,v) := c_y(u,v) - \Delta(X)\)

		\quad Se \(c_y(u,v) = 0\), adicione a \(A_0\)
		                                       &
		\textbf{Função \texttt{update\_weights\_in\_X}:}

		\texttt{for u, v, \_ in arcs:}

		\texttt{\quad D[u][v]["w"] -= min\_weight}

		\texttt{\quad if D[u][v]["w"] == 0:}

		\texttt{\quad\quad A\_zero.append((u, v))}

		\texttt{\quad\quad D\_zero.add\_edge(u, v)}
		\\
		\midrule
		\rowcolor{cyan!5}
		\textbf{Passo 3:} Verificar término

		Se \(D_0\) contém r-arborescência, encerre.
		                                       &
		\textbf{Condição — Linhas 11--12:}

		\texttt{if len(sources) == 1: break}

		\vspace{1mm}
		Uma fonte \(\Rightarrow\) r-arborescência acíclica.
		\\
		\midrule
		\rowcolor{red!5}
		\textbf{Passo 4:} Construir arborescência

		Construa \(F\) a partir de \(A_0\), conectando vértices incrementalmente.
		                                       &
		\textbf{Função \texttt{phase2} (incremental):}

		\texttt{Arb = nx.DiGraph(); Arb.add\_node(r0)}

		\texttt{for \_ in range(n - 1):}

		\texttt{\quad for u, v in A\_zero:}

		\texttt{\quad\quad if u in Arb and v not in Arb:}

		\texttt{\quad\quad\quad Arb.add\_edge(u, v, **data)}

		\texttt{\quad\quad\quad break}

		\vspace{1mm}
		Complexidade: \(O(nm)\).
		\\
		\midrule
		\rowcolor{red!5}
		\textbf{Passo 4:} Versão otimizada

		Mesma ideia, com fila de prioridade.
		                                       &
		\textbf{Função \texttt{phase2\_v2} (BFS):}

		\texttt{Arb = nx.DiGraph()}

		\texttt{for i, (u, v) in enumerate(A\_zero):}

		\texttt{\quad Arb.add\_edge(u, v, w=i)}

		\texttt{q = [] \# fila de prioridade}

		\texttt{while q:}

		\texttt{\quad \_, u, v = heapq.heappop(q)}

		\texttt{\quad if v in V: continue}

		\texttt{\quad A.add\_edge(u, v, w=D[u][v]["w"])}

		\vspace{1mm}
		Complexidade: \(O(m \log m)\).
		\\
		\midrule
		\rowcolor{pink!5}
		\textbf{Otimalidade dual}

		Para cada \(X\) elevado (\(\Delta(X) > 0\)), exatamente um arco de \(F\) cruza \(\delta^-(X)\).
		                                       &
		\textbf{Função \texttt{check\_dual\_optimality}:}

		\texttt{for X, z in Dual\_list:}

		\texttt{\quad count = 0}

		\texttt{\quad for u, v in Arb.edges():}

		\texttt{\quad\quad if u not in X and v in X:}

		\texttt{\quad\quad\quad count += 1}

		\texttt{\quad\quad\quad if count > 1: return False}

		\texttt{return True}
		\\
		\bottomrule
	\end{tabular}
	\caption{Correspondência entre a descrição teórica do algoritmo de András Frank e sua implementação em Python. Cores: inicialização (azul), elevação de potenciais (verde/laranja/roxo/amarelo), verificação (ciano), construção (vermelho) e validação dual (rosa).}
	\label{tab:frank-teoria-implementacao}
\end{table}

Esta correspondência demonstra que a implementação traduz fielmente a abordagem primal-dual em código executável. As funções auxiliares (\texttt{get\_arcs\_entering\_X}, \texttt{get\_minimum\_weight\_cut}, \texttt{update\_weights\_in\_X}, \texttt{phase1}, \texttt{phase2}, \texttt{phase2\_v2},
\texttt{check\_dual\_}-
\texttt{optimality\_condition} encapsulam exatamente as operações descritas na teoria, preservando as propriedades de correção e as garantias de otimalidade do algoritmo original. A utilização de componentes fortemente conexas (\texttt{nx.condensation}) para identificar conjuntos sem arcos justos entrando é uma implementação eficiente da verificação teórica, evitando enumeração explícita de todos os subconjuntos de vértices.
