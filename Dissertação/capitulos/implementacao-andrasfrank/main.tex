\chapter{Algoritmo de András Frank}

Neste capítulo, apresentaremos o algoritmo de András Frank, que também determina
uma arborescência de custo mínimo em um digrafo ponderado.
O algoritmo baseia-se em uma abordagem primal--dual:
a elevação gulosa de potenciais duais\footnote{\textbf{Potencial dual} é uma variável associada a cada vértice, que representa um "desconto" aplicado ao custo dos arcos que entram nesse vértice e servem para ajustar os custos de modo que certas restrições fiquem "apertadas", - satisfeitas com igualdade, ou seja, o valor da variável atinge exatamente o limite imposto pela restrição.} e (ii) a construção de uma solução gulosa
a partir dos arcos de custo reduzido zero.
Diferentemente do algoritmo de Chu--Liu--Edmonds, que opera diretamente sobre os custos,
o método de Frank manipula potenciais duais associados aos vértices,
gerando arcos \emph{apertados} (de custo reduzido zero) que formam a arborescência ótima.
O propósito deste capítulo é fornecer uma descrição precisa tanto do algoritmo
quanto da implementação desenvolvida neste trabalho.

\section{O algoritmo}
O algoritmo de András Frank também recebe uma tripla \((D,c,r)\), em que \(D=(V,A)\) é um digrafo,
\(c\colon A\to\mathbb{R}\) é uma função custo e \(r\in V\) é a raiz,
sob a hipótese de que \(D\) admite ao menos uma \(r\)-arborescência e devolve uma \(r\)-arborescência \(c\)-mínima de \(D\).

Assim como no capítulo anterior, adotamos a terminologia de \textbf{\(r\)-digrafo ponderado}
para uma tripla \((D,c,r)\) em que $(D, c)$ é um digrafo ponderado,
$r$ é um vértice de $D$, $\delta^-(r) = \varnothing$
e $D$ possui uma $r$-arborescência.

Vamos desenvolver as ideias do algoritmo utilizando o mesmo dígrafo que apresentamos
no capítulo anterior.

\subsection*{Abordagem Gulosa--Dual}

Considere novamente o dígrafo \(D\) figura 26 a seguir, com custos nos arcos note que é o mesmo digrafo da figura 1 que utilizamos para ilustrar o algoritmo de Chu--Liu--Edmonds. E portanto, suponha que T é uma arborescência de custo mínimo, com seus arcos destacados em azul.

\begin{figure}[h]
	\centering
	\begin{tikzpicture}[>=Stealth]
		% estilos
		\tikzset{
			vtx/.style={circle, draw,fill=blue!8, thick, inner sep=1.2pt, minimum size=6mm},
			chosen/.style={->, very thick, draw=blue},
			other/.style={->, semithick, draw=black!35},
			costB/.style={font=\scriptsize, fill=white, inner sep=1pt, text=blue},
			costG/.style={font=\scriptsize, fill=white, inner sep=1pt, text=black!55}
		}

		% layout (mais espaçado)
		\node[vtx] (r) at (0,0) {$r$};
		\node[vtx] (a) at (3,1.6) {$a$};
		\node[vtx] (b) at (3,-1.6) {$b$};
		\node[vtx] (c) at (6,2.2) {$c$};
		\node[vtx] (d) at (6,0.0) {$d$};
		\node[vtx] (e) at (6,-2.2) {$e$};

		% --- arcos NÃO escolhidos (cinza), agora com curvaturas mais limpas ---
		\draw[other] (b) to[bend left=12] node[costG, above] {4} (a);   % b->a
		\draw[other] (a) to[bend left=14] node[costG, below] {5} (b);   % a->b

		% r->c: externo por cima, suave (pontos de controle explícitos)
		\draw[other]
		(r) .. controls (0.8,2.4) and (5.2,3.0) ..
		node[costG, yshift=4pt, pos=0.53] {3} (c);

		% a->d (referência)
		\draw[other] (a) -- node[costG, right] {3} (d);

		% c->e: leve curvatura pela direita (sem "barriga")
		\draw[other]
		(c) .. controls (7.6,2.6) and (7.6,-2.6) ..
		node[costG, xshift=8pt, pos=0.52] {5} (e);

		% --- arcos ESCOLHIDOS (AZUL) — formam a r-arborescência T ---
		\draw[chosen] (r) -- node[costB, above] {1} (a);   % r->a
		\draw[chosen] (r) -- node[costB, below] {2} (b);   % r->b
		\draw[chosen] (a) -- node[costB, above] {1} (c);   % a->c
		\draw[chosen] (b) -- node[costB, above] {1} (d);   % b->d
		\draw[chosen] (b) -- node[costB, below] {2} (e);   % b->e
	\end{tikzpicture}

	\caption{O dígrafo \(D\) com custos nos arcos. Os arcos em \textcolor{blue}{azul}
		formam a \(r\)-arborescência de custo mínimo \(T\) (custo total = 7).}
\end{figure}

O algoritmo de Frank utiliza \textbf{potenciais} \(y: V \to \mathbb{R}\) associados aos vértices
para definir custos reduzidos nos arcos. Para cada arco \(a = (u,v) \in A\), o
\textbf{custo \(y\)-reduzido} é dado por
\[
	c_y(u,v) := c(u,v) - y(v),
\]
onde \(v\) é o vértice de destino do arco. Note que, diferentemente do procedimento de redução do capítulo anterior (onde subtraíamos o mínimo custo de entrada em cada vértice), aqui o potencial \(y(v)\) é uma variável que será ajustada pelo algoritmo através da seguinte noção.

Um arco \(a = (u,v)\) é dito \textbf{apertado} (ou \textbf{tight}) se \(c_y(u,v) = 0\), isto é, se o custo original coincide com o potencial do vértice de destino: \(c(u,v) = y(v)\). A ideia central do algoritmo de Frank consiste em duas etapas: (i)~elevar os potenciais \(y(v)\) para cada \(v \neq r\) até que cada vértice possua ao menos um arco apertado entrando nele; (ii)~construir uma arborescência ótima utilizando exclusivamente arcos apertados.

\begin{tcolorbox}[
		enhanced, breakable,
		colback=blue!5!white, colframe=blue!70!black,
		colbacktitle=blue!85!black, coltitle=white,
		fonttitle=\bfseries,
		title={Arcos apertados: interpretação e cálculo},
		sharp corners, boxrule=0.8pt
	]
	Um arco \((u,v)\) é \textbf{apertado} quando seu custo reduzido é zero, ou seja, quando o custo original \(c(u,v)\) coincide exatamente com o potencial \(y(v)\) do vértice de destino. Formalmente:
	\[
		c_y(u,v) = c(u,v) - y(v) = 0 \quad\Longleftrightarrow\quad c(u,v) = y(v).
	\]

	Em outras palavras, o potencial \(y(v)\) funciona como um ``desconto'' aplicado aos arcos que chegam em \(v\). Quando esse desconto é suficiente para anular o custo reduzido, o arco torna-se apertado e candidato a participar da solução ótima.

	\medskip
	\textbf{Exemplos numéricos (referência: figura~26):}
	\begin{itemize}\setlength{\itemsep}{3pt}
		\item Arco \((r,a)\): \(c(r,a) = 1\), \(y(a) = 1 \implies c_y(r,a) = 1-1 = 0\). \quad\textcolor{blue!70!black}{\textbf{Apertado.}}
		\item Arco \((b,a)\): \(c(b,a) = 4\), \(y(a) = 1 \implies c_y(b,a) = 4-1 = 3\). \quad\textcolor{red!70!black}{\textbf{Não apertado.}}
		\item Arco \((a,c)\): \(c(a,c) = 1\), \(y(c) = 1 \implies c_y(a,c) = 1-1 = 0\). \quad\textcolor{blue!70!black}{\textbf{Apertado.}}
	\end{itemize}

	\textbf{Propriedade fundamental:} o potencial \(y(v)\) afeta \emph{exclusivamente} os arcos que entram em \(v\). Por exemplo, \(y(c)\) influencia apenas arcos da forma \((\cdot, c)\), como \((r,c)\) e \((a,c)\), não afetando arcos que saem de \(c\).

	\medskip
	O algoritmo eleva progressivamente os potenciais até que cada vértice \(v \neq r\) possua ao menos um arco apertado de entrada. No exemplo da figura~26, os arcos apertados após a elevação correspondem precisamente aos arcos da arborescência ótima.
\end{tcolorbox}

% Figura 27: Exemplo visual com múltiplos arcos e vértice raiz
\begin{figure}[H]
	\centering
	\begin{tikzpicture}[>=Stealth]
		% estilos
		\tikzset{
			vtx/.style={circle, draw, fill=blue!8, thick, inner sep=1.2pt, minimum size=8mm},
			arc/.style={->, very thick, draw=blue},
			arcTight/.style={->, very thick, draw=red!70!black},
			cost/.style={font=\scriptsize, fill=white, inner sep=1pt, text=blue},
			pot/.style={font=\small, text=red!70!black},
			label/.style={font=\small, text=black!80}
		}

		% vértices
		\node[vtx] (r) at (0,0) {$r$};
		\node[vtx] (u) at (3,1.5) {$u$};
		\node[vtx] (v) at (3,-1.5) {$v$};

		% arcos
		\draw[arcTight] (r) -- node[cost, above left] {$c(r,u)=2$} (u);
		\draw[arc] (r) -- node[cost, below left] {$c(r,v)=4$} (v);
		\draw[arcTight] (u) -- node[cost, right] {$c(u,v)=3$} (v);

		% potenciais
		\node[pot] at (3,2.5) {$y(u)=2$};
		\node[pot] at (3,-2.5) {$y(v)=3$};

		% destaques
		\draw[red!70, thick, dashed] (u) circle [radius=0.7];
		\draw[red!70, thick, dashed] (v) circle [radius=0.7];

		% custos reduzidos
		\node[label] at (-0.0,1.5) {$c_y(r,u)=2-2=0$};
		\node[label] at (-0.0,-1.5) {$c_y(r,v)=4-3=1$};
		\node[label] at (5.0,-0.5) {$c_y(u,v)=3-3=0$};
	\end{tikzpicture}
	\caption{O vértice $r$ é a raiz. Os potenciais são $y(u)=2$ e $y(v)=3$. O arco $(r,u)$ tem custo reduzido $0$ (apertado), $(r,v)$ tem custo reduzido $1$ (não apertado), $(u,v)$ tem custo reduzido $0$ (apertado). Os potenciais só afetam os arcos que chegam em cada vértice.}
	\label{fig:potencial-destino}
\end{figure}

\subsection*{Elevação de Potenciais}

Inicialmente, definimos \(y(v) = 0\) para todo \(v \in V\).
Para cada vértice \(v \neq r\), calculamos
\[
	\Delta(v) := \min\{\, c(a) : a \in \delta^{-}(v) \,\} - y(v).
\]
O valor \(\Delta(v)\) representa quanto precisamos elevar \(y(v)\) para que exista
ao menos um arco de custo reduzido zero entrando em \(v\).

Vamos ilustrar esse processo no dígrafo \(D\).

\begin{figure}[H]
	\centering
	\begin{tikzpicture}[>=Stealth]
		% estilos
		\tikzset{
			vtx/.style={circle, draw,fill=blue!8, thick, inner sep=1.2pt, minimum size=6mm},
			arc/.style={->, semithick, draw=black!35},
			costG/.style={font=\scriptsize, fill=white, inner sep=1pt, text=black!55}
		}

		% layout
		\node[vtx] (r) at (0,0) {$r$};
		\node[vtx] (a) at (3,1.6) {$a$};
		\node[vtx] (b) at (3,-1.6) {$b$};
		\node[vtx] (c) at (6,2.2) {$c$};
		\node[vtx] (d) at (6,0.0) {$d$};
		\node[vtx] (e) at (6,-2.2) {$e$};

		% arcos com custos originais
		\draw[arc] (r) -- node[costG, above] {1} (a);
		\draw[arc] (r) -- node[costG, below] {2} (b);
		\draw[arc] (r) .. controls (0.8,2.4) and (5.2,3.0) .. node[costG, yshift=4pt, pos=0.53] {3} (c);
		\draw[arc] (b) to[bend left=12] node[costG, above] {4} (a);
		\draw[arc] (a) to[bend left=14] node[costG, below] {5} (b);
		\draw[arc] (a) -- node[costG, above] {1} (c);
		\draw[arc] (a) -- node[costG, right] {3} (d);
		\draw[arc] (b) -- node[costG, above] {1} (d);
		\draw[arc] (b) -- node[costG, below] {2} (e);
		\draw[arc] (c) .. controls (7.6,2.6) and (7.6,-2.6) .. node[costG, xshift=8pt, pos=0.52] {5} (e);

		% potenciais iniciais
		\node[above=6mm of a, font=\small] {$y(a) = 0$};
		\node[below=2mm of b, font=\small] {$y(b) = 0$};
		\node[above=2mm of c, font=\small] {$y(c) = 0$};
		\node[below=2mm of d, font=\small] {$y(d) = 0$};
		\node[below=2mm of e, font=\small] {$y(e) = 0$};
	\end{tikzpicture}
	\caption{Dígrafo \(D\) com potenciais iniciais \(y(v) = 0\) para todo \(v \in V\).}
\end{figure}

Calculamos \(\Delta(v)\) para cada vértice \(v \neq r\):
\begin{align*}
	\Delta(a) & = \min\{1, 4\} - 0 = 1, \\
	\Delta(b) & = \min\{2, 5\} - 0 = 2, \\
	\Delta(c) & = \min\{3, 1\} - 0 = 1, \\
	\Delta(d) & = \min\{3, 1\} - 0 = 1, \\
	\Delta(e) & = \min\{2, 5\} - 0 = 2.
\end{align*}

Elevamos cada potencial:
\begin{align*}
	y(a) & \leftarrow y(a) + \Delta(a) = 0 + 1 = 1, \\
	y(b) & \leftarrow y(b) + \Delta(b) = 0 + 2 = 2, \\
	y(c) & \leftarrow y(c) + \Delta(c) = 0 + 1 = 1, \\
	y(d) & \leftarrow y(d) + \Delta(d) = 0 + 1 = 1, \\
	y(e) & \leftarrow y(e) + \Delta(e) = 0 + 2 = 2.
\end{align*}

Após a elevação, os custos reduzidos são dados por \(c_y(u,v) = c(u,v) - y(v)\) para cada arco \((u,v)\):

\begin{figure}[H]
	\centering
	\begin{tikzpicture}[>=Stealth]
		% estilos
		\tikzset{
			vtx/.style={circle, draw,fill=blue!8, thick, inner sep=1.2pt, minimum size=6mm},
			tight/.style={->, very thick, draw=blue},
			loose/.style={->, semithick, draw=black!35},
			costB/.style={font=\scriptsize, fill=white, inner sep=1pt, text=blue},
			costG/.style={font=\scriptsize, fill=white, inner sep=1pt, text=black!55}
		}

		% layout
		\node[vtx] (r) at (0,0) {$r$};
		\node[vtx] (a) at (3,1.6) {$a$};
		\node[vtx] (b) at (3,-1.6) {$b$};
		\node[vtx] (c) at (6,2.2) {$c$};
		\node[vtx] (d) at (6,0.0) {$d$};
		\node[vtx] (e) at (6,-2.2) {$e$};

		% arcos apertados (custo reduzido = 0)
		\draw[tight] (r) -- node[costB, above] {0} (a);   % 1 - 1 = 0
		\draw[tight] (r) -- node[costB, below] {0} (b);   % 2 - 2 = 0
		\draw[tight] (a) -- node[costB, above] {0} (c);   % 1 - 1 = 0
		\draw[tight] (b) -- node[costB, above] {0} (d);   % 1 - 1 = 0
		\draw[tight] (b) -- node[costB, below] {0} (e);   % 2 - 2 = 0

		% arcos não apertados
		\draw[loose] (r) .. controls (0.8,2.4) and (5.2,3.0) .. node[costG, yshift=4pt, pos=0.53] {2} (c);  % 3 - 1 = 2
		\draw[loose] (b) to[bend left=12] node[costG, above] {3} (a);   % 4 - 1 = 3
		\draw[loose] (a) to[bend left=14] node[costG, below] {3} (b);   % 5 - 2 = 3
		\draw[loose] (a) -- node[costG, right] {2} (d);   % 3 - 1 = 2
		\draw[loose] (c) .. controls (7.6,2.6) and (7.6,-2.6) .. node[costG, xshift=8pt, pos=0.52] {3} (e);  % 5 - 2 = 3

		% potenciais finais
		\node[above=6mm of a, font=\small] {$y(a) = 1$};
		\node[below=2mm of b, font=\small] {$y(b) = 2$};
		\node[above=2mm of c, font=\small] {$y(c) = 1$};
		\node[below=2mm of d, font=\small] {$y(d) = 1$};
		\node[below=2mm of e, font=\small] {$y(e) = 2$};
	\end{tikzpicture}
	\caption{Dígrafo após elevação de potenciais. Arcos em \textcolor{blue}{azul} são
		apertados (\(c_y = 0\)); arcos em cinza têm custo reduzido positivo.}
\end{figure}

Observe que cada vértice \(v \neq r\) possui agora ao menos um arco apertado entrando nele.
Mais ainda: neste exemplo, os arcos apertados formam uma \(r\)-arborescência! Precisamos justificar por que a arborescência formada pelos arcos apertados é ótima.

\subsection*{Construção da Arborescência}

Se os arcos apertados formam uma \(r\)-arborescência, então encontramos a solução ótima.
Caso contrário, os arcos apertados contêm ciclos, e precisamos tratá-los adequadamente.

No nosso exemplo, os arcos apertados são:
\[
	H = \{\, (r,a), (r,b), (a,c), (b,d), (b,e) \,\}.
\]
Esses arcos formam a \(r\)-arborescência \(T\) de custo mínimo.

Para verificar a otimalidade, note que uma propriedade fundamental dos potenciais duais é:

\begin{proposicao}
	Para toda função \(y: V \to \mathbb{R}\) com \(y(r) = 0\),
	uma \(r\)-arborescência \(T\) é \(c\)-mínima em \(D\) se, e somente se,
	todos os arcos de \(T\) são apertados (i.e., \(c_y(a) = 0\) para todo \(a \in T\))
	e \(c_y(a) \geq 0\) para todo \(a \in A\).
\end{proposicao}

\begin{proof}[Prova.]
	Seja \(F\) uma \(r\)-arborescência qualquer. Para cada \(v \in V \setminus \{r\}\),
	seja \(a_v\) o único arco de \(F\) que entra em \(v\). Então
	\begin{align*}
		c(F)
		 & = \sum_{v \in V \setminus \{r\}} c(a_v)                                          \\
		 & = \sum_{v \in V \setminus \{r\}} \bigl(c_y(a_v) + y(v)\bigr)                     \\
		 & = \sum_{v \in V \setminus \{r\}} c_y(a_v) + \sum_{v \in V \setminus \{r\}} y(v).
	\end{align*}
	Como a soma \(\sum_{v \in V \setminus \{r\}} y(v)\) é constante para todas as
	\(r\)-arborescências, minimizar \(c(F)\) equivale a minimizar \(\sum_{v} c_y(a_v)\).
	Se todos os arcos de \(T\) são apertados e \(c_y(a) \geq 0\) para todo \(a\),
	então \(\sum_{v} c_y(a_v^T) = 0 \leq \sum_{v} c_y(a_v^F)\) para qualquer \(F\),
	provando que \(T\) é ótima.
\end{proof}

No nosso exemplo, todos os arcos de \(T\) são apertados e \(c_y(a) \geq 0\) para todo
arco \(a \in A\), portanto \(T\) é a \(r\)-arborescência de custo mínimo. Evidentemente, nem sempre será o caso que os arcos apertados formam uma arborescência e precisaremos tratar ciclos.

\subsection*{Tratamento de Ciclos}

Em geral, após a elevação de potenciais, os arcos apertados podem conter ciclos.
Nesse caso, o algoritmo de Frank procede de forma similar ao de Chu--Liu--Edmonds:
contrai cada ciclo apertado em um supervértice, resolve o problema recursivamente
no dígrafo contraído, e depois reexpande a solução.

Vamos ilustrar esse processo com um exemplo modificado. Suponha que adicionamos o arco
\((c, a)\) com custo 1 ao dígrafo original:

\begin{figure}[H]
	\centering
	\begin{tikzpicture}[>=Stealth]
		% estilos
		\tikzset{
			vtx/.style={circle, draw,fill=blue!8, thick, inner sep=1.2pt, minimum size=6mm},
			arc/.style={->, semithick, draw=black!35},
			costG/.style={font=\scriptsize, fill=white, inner sep=1pt, text=black!55}
		}

		% layout
		\node[vtx] (r) at (0,0) {$r$};
		\node[vtx] (a) at (3,1.6) {$a$};
		\node[vtx] (b) at (3,-1.6) {$b$};
		\node[vtx] (c) at (6,2.2) {$c$};
		\node[vtx] (d) at (6,0.0) {$d$};
		\node[vtx] (e) at (6,-2.2) {$e$};

		% arcos originais
		\draw[arc] (r) -- node[costG, above] {1} (a);
		\draw[arc] (r) -- node[costG, below] {2} (b);
		\draw[arc] (r) .. controls (0.8,2.4) and (5.2,3.0) .. node[costG, yshift=4pt, pos=0.53] {3} (c);
		\draw[arc] (b) to[bend left=12] node[costG, above] {4} (a);
		\draw[arc] (a) to[bend left=14] node[costG, below] {5} (b);
		\draw[arc] (a) -- node[costG, above] {1} (c);
		\draw[arc] (a) -- node[costG, right] {3} (d);
		\draw[arc] (b) -- node[costG, above] {1} (d);
		\draw[arc] (b) -- node[costG, below] {2} (e);
		\draw[arc] (c) .. controls (7.6,2.6) and (7.6,-2.6) .. node[costG, xshift=8pt, pos=0.52] {5} (e);

		% NOVO arco (c, a)
		\draw[arc, draw=red!60] (c) to[bend left=20] node[costG, left, text=red!60] {1} (a);
	\end{tikzpicture}
	\caption{Dígrafo modificado com o arco \((c,a)\) de custo 1 (em vermelho).}
\end{figure}

Após a elevação de potenciais com \(y(a) = 1, y(c) = 1\), o arco \((c,a)\) torna-se
apertado: \(c_y(c,a) = 1 - 1 = 0\).

\begin{figure}[H]
	\centering
	\begin{tikzpicture}[>=Stealth]
		% estilos
		\tikzset{
			vtx/.style={circle, draw,fill=blue!8, thick, inner sep=1.2pt, minimum size=6mm},
			tight/.style={->, very thick, draw=blue},
			cycle/.style={->, ultra thick, draw=red!70},
			loose/.style={->, semithick, draw=black!35},
			costB/.style={font=\scriptsize, fill=white, inner sep=1pt, text=blue},
			costR/.style={font=\scriptsize, fill=white, inner sep=1pt, text=red!70},
			costG/.style={font=\scriptsize, fill=white, inner sep=1pt, text=black!55}
		}

		% layout
		\node[vtx] (r) at (0,0) {$r$};
		\node[vtx] (a) at (3,1.6) {$a$};
		\node[vtx] (b) at (3,-1.6) {$b$};
		\node[vtx] (c) at (6,2.2) {$c$};
		\node[vtx] (d) at (6,0.0) {$d$};
		\node[vtx] (e) at (6,-2.2) {$e$};

		% arcos apertados que formam ciclo
		\draw[cycle] (a) -- node[costR, above] {0} (c);
		\draw[cycle] (c) to[bend left=20] node[costR, left] {0} (a);

		% outros arcos apertados
		\draw[tight] (r) -- node[costB, above] {0} (a);
		\draw[tight] (r) -- node[costB, below] {0} (b);
		\draw[tight] (b) -- node[costB, above] {0} (d);
		\draw[tight] (b) -- node[costB, below] {0} (e);

		% arcos não apertados
		\draw[loose] (r) .. controls (0.8,2.4) and (5.2,3.0) .. node[costG, yshift=4pt, pos=0.53] {2} (c);
		\draw[loose] (b) to[bend left=12] node[costG, above] {3} (a);
		\draw[loose] (a) to[bend left=14] node[costG, below] {3} (b);
		\draw[loose] (a) -- node[costG, right] {2} (d);   % 3 - 1 = 2
		\draw[loose] (c) .. controls (7.6,2.6) and (7.6,-2.6) .. node[costG, xshift=8pt, pos=0.52] {3} (e);  % 5 - 2 = 3
	\end{tikzpicture}
	\caption{Arcos apertados após elevação. O ciclo \(C = (a, c, a)\) é destacado em
		\textcolor{red!70}{vermelho}.}
\end{figure}

Nesse caso, contraímos o ciclo \(C = (a, c)\) em um supervértice \(x_C\), ajustamos
os custos dos arcos incidentes, e resolvemos o problema no dígrafo contraído.
A reexpansão é feita removendo um arco do ciclo para manter a estrutura de arborescência,
de forma análoga ao algoritmo de Chu--Liu--Edmonds.

\section{Descrição do algoritmo}

O algoritmo de András Frank difere substancialmente do algoritmo de Chu--Liu--Edmonds em sua abordagem: enquanto Chu--Liu--Edmonds opera diretamente sobre os custos dos arcos, o método de Frank utiliza uma técnica gulosa--dual baseada em \emph{potenciais} associados aos vértices. A ideia central é elevar progressivamente os potenciais \(y(v)\) para cada vértice \(v\neq r\), de modo que os custos \emph{reduzidos} \(c_y(u,v) := c(u,v) - y(v)\) revelem quais arcos devem participar da solução ótima. Um arco \((u,v)\) é dito \emph{apertado} quando seu custo reduzido é zero, isto é, quando \(c(u,v) = y(v)\). O algoritmo garante que toda r-arborescência ótima pode ser formada apenas por arcos apertados.

A seguir apresentamos uma descrição formal do algoritmo de András Frank e detalhes de implementação serão discutidos na próxima seção.

\begin{algobox}{András Frank}{andras-frank}
	Entrada: dígrafo \(D=(V,A)\), custos \(c:A\to\mathbb{R}_{\ge 0}\), raiz \(r\).\footnote{Se algum \(v\neq r\) não possui arco de entrada, não existe r-arborescência.}

	\textbf{Fase 1: Elevação de potenciais e construção de \(A_0\)}
	\begin{enumerate}\setlength{\itemsep}{2pt}
		\item \textbf{Inicialização:} defina \(y(v) := 0\) para todo \(v \in V\).
		\item \textbf{Iteração:} enquanto existir conjunto \(X \subseteq V \setminus \{r\}\) sem arco apertado entrando:
		      \begin{itemize}\setlength{\itemsep}{2pt}
			      \item Calcule \(\Delta(X) := \min\{c(u,v) - y(v) : u \notin X, v \in X\}\).
			      \item Para cada \(v \in X\), atualize \(y(v) := y(v) + \Delta(X)\).
		      \end{itemize}
		\item Defina \(A_0 := \{a \in A : c_y(a) = 0\}\), o conjunto de arcos apertados.
	\end{enumerate}

	\textbf{Fase 2: Construção da arborescência}
	\begin{enumerate}\setlength{\itemsep}{2pt}\setcounter{enumi}{3}
		\item Se \((V,A_0)\) forma uma r-arborescência, devolva \(A_0\). Por otimalidade dos potenciais duais, trata-se de uma r-arborescência de custo mínimo.
		\item Caso contrário, identifique um ciclo dirigido \(C\) em \(A_0\) (com \(r\notin C\)). \textbf{Contração:} contraia \(C\) em um supervértice \(x_C\) e defina custos reduzidos \(c'\) por
		      \begin{align*}
			      c'(u,x_C) & := c_y(u,w) = c(u,w) - y(w) &  & \text{para } u\notin C,\ w\in C, \\
			      c'(x_C,v) & := c_y(w,v) = c(w,v) - y(v) &  & \text{para } w\in C,\ v\notin C,
		      \end{align*}
		      descartando laços em \(x_C\) e permitindo paralelos. Denote o dígrafo contraído por \(D'=(V',A')\).
		\item \textbf{Recursão:} compute uma r-arborescência ótima \(T'\) de \(D'\) com custos \(c'\).
		\item \textbf{Expansão:} seja \((u,x_C)\in T'\) o único arco que entra em \(x_C\). No dígrafo original, ele corresponde a \((u,w)\) com \(w\in C\). Forme
		      \[
			      T := \bigl(T'\setminus\{\text{arcos incidentes a } x_C\}\bigr)\ \cup\ \{(u,w)\}\ \cup\ \bigl((A_0\cap A(C))\setminus\{a_w\}\bigr),
		      \]
		      onde \(a_w\) é o arco de \(C\) que entra em \(w\). Então \(T\) é uma r-arborescência ótima de \(D\).
	\end{enumerate}
\end{algobox}

\subsection{Corretude}

A corretude do algoritmo de András Frank baseia-se na teoria de dualidade em programação linear aplicada ao problema de arborescência de custo mínimo:

\begin{enumerate}\setlength{\itemsep}{2pt}
	\item \emph{Potenciais duais:} os valores \(y(v)\) funcionam como variáveis duais. Para qualquer r-arborescência \(T\) e qualquer escolha de potenciais \(y\), vale
	      \[
		      c(T) = \sum_{a\in T} c(a) = \sum_{a\in T} c_y(a) + \sum_{v\neq r} y(v),
	      \]
	      pois há exatamente um arco de \(T\) entrando em cada \(v\neq r\). O termo \(\sum_{v\neq r} y(v)\) é constante após a elevação completa dos potenciais; assim, minimizar \(c(T)\) equivale a minimizar \(\sum_{a\in T} c_y(a)\).

	\item \emph{Condições de otimalidade:} uma r-arborescência \(T\) é ótima se e somente se:
	      \begin{itemize}\setlength{\itemsep}{2pt}
		      \item Todos os arcos de \(T\) são apertados: \(c_y(a) = 0\) para todo \(a \in T\).
		      \item Todos os arcos do dígrafo têm custo reduzido não-negativo: \(c_y(a) \geq 0\) para todo \(a \in A\).
	      \end{itemize}
	      Sob essas condições, \(\sum_{a\in T} c_y(a) = 0 \leq \sum_{a\in T'} c_y(a)\) para qualquer outra r-arborescência \(T'\), provando otimalidade.

	\item \emph{Elevação de potenciais:} o algoritmo eleva os potenciais de forma gulosa, garantindo que ao final cada \(v\neq r\) tenha ao menos um arco apertado entrando. Isso é feito identificando componentes fortemente conexas em \(A_0\): conjuntos \(X\) que ainda não possuem arcos apertados entrando têm seus potenciais elevados pelo mínimo necessário \(\Delta(X)\).

	\item \emph{Caso acíclico:} se \(A_0\) forma uma r-arborescência, todos os arcos são apertados e, pelas condições de otimalidade, a solução é ótima.

	\item \emph{Caso com ciclo (contração/expansão):} se \(A_0\) contém um ciclo dirigido \(C\), todos os seus arcos são apertados (custo reduzido zero). A contração preserva a estrutura de custos reduzidos: no dígrafo contraído, os novos custos \(c'\) já incorporam os potenciais, e uma solução ótima em \(D'\) mapeia para uma solução ótima em \(D\) pela reversibilidade da operação.
\end{enumerate}

Em termos intuitivos, os potenciais \(y(v)\) funcionam como "descontos" aplicados aos arcos que entram em cada vértice, revelando quais arcos são "apertados" (custo líquido zero) e, portanto, candidatos à solução ótima. Ciclos de arcos apertados podem ser contraídos sem perder otimalidade, simplificando o problema recursivamente.

\subsection{Complexidade}

A implementação, baseada em componentes fortemente conexas, detecta em cada iteração, quais conjuntos \(X\) necessitam elevação de potenciais. Calcular componentes fortemente conexas custa \(O(n+m)\) usando algoritmos como Tarjan ou Kosaraju. Para cada componente (exceto a raiz), eleva-se o potencial calculando \(\Delta(X)\) em \(O(m)\), atualizando os custos reduzidos.

No pior caso, cada iteração reduz o número de componentes em pelo menos uma unidade, resultando em \(O(n)\) iterações. Cada iteração processa todos os arcos para atualizar custos reduzidos e recalcular componentes, resultando em \(O(nm)\) no total para a Fase~1. A Fase~2 constrói a arborescência percorrendo \(A_0\) uma vez, custando \(O(n)\).

O uso de memória é \(O(n+m)\), incluindo as estruturas para armazenar o dígrafo, potenciais e componentes. A implementação a seguir adota a versão \(O(nm)\) por simplicidade e está disponível no repositório do projeto (\url{https://github.com/lorenypsum/GraphVisualizer}).

\section{Implementação em Python}

Esta seção descreve a implementação do algoritmo de András Frank em Python, estruturada para refletir com precisão as duas fases formais discutidas anteriormente. A Fase~1 realiza a elevação de potenciais e identifica os arcos apertados, enquanto a Fase~2 constrói a arborescência de custo mínimo a partir desses arcos. Utilizamos a biblioteca NetworkX para manipulação de digrafos, aproveitando suas funcionalidades para representar grafos, calcular componentes fortemente conexas e gerenciar atributos de arcos.

A entrada consiste em um dígrafo orientado \(D = (V, A)\), com custos dos arcos registrados no atributo \texttt{"w"}, e uma raiz \(r \in V\). As hipóteses adotadas são: (i) o dígrafo é conexo a partir de \(r\), isto é, todo vértice \(v \neq r\) é alcançável a partir da raiz; (ii) para todo subconjunto \(X \subseteq V \setminus \{r\}\), existe ao menos um arco entrando em \(X\); e (iii) todos os custos são não negativos.

A saída é um subdigrafo \(T\) de \(D\) com \(|A_T| = |V| - 1\) arcos, tal que cada vértice \(v \neq r\) possui grau de entrada igual a 1, todos os vértices são alcançáveis a partir de \(r\), e o custo total \(\sum_{a \in A_T} c(a)\) é mínimo.

A estrutura do código é modular: funções auxiliares tratam cada etapa do algoritmo — cálculo de componentes fortemente conexas, elevação de potenciais, construção do subdigrafo \(A_0\) e construção da arborescência final. Todas operam sobre objetos \texttt{nx.DiGraph} e são coordenadas por uma função principal que gerencia o fluxo das duas fases. As subseções seguintes detalham cada função auxiliar, abordando lógica, parâmetros, saídas e complexidade.

\subsection{Construção do dígrafo \texorpdfstring{\(D_0\)}{D_0} inicial}

Começamos escrevendo uma função que constrói o dígrafo inicial \(D_0\) que será utilizado na Fase~1 do algoritmo. O dígrafo \(D_0\) é inicializado como um grafo vazio contendo apenas os vértices do dígrafo original, sem arcos. Essa estrutura será gradualmente populada com arcos de custo reduzido zero à medida que os potenciais são elevados.

Recebe como entrada um dígrafo \texttt{D} (objeto \texttt{nx.DiGraph}). A implementação cria um novo dígrafo vazio \texttt{D\_zero} (linha 2) e adiciona todos os vértices de \texttt{D} a \texttt{D\_zero} (linhas 3-4), preservando a estrutura de vértices sem incluir arcos inicialmente.

A função devolve o dígrafo \texttt{D\_zero} contendo todos os vértices de \texttt{D} mas nenhum arco. O dígrafo original \texttt{D} não é modificado. A complexidade é \(O(n)\), onde \(n = |V|\), pois itera sobre todos os vértices uma única vez.

\begin{tcolorbox}[
		enhanced, breakable,
		colframe=blue!60!black, colback=blue!2,
		colbacktitle=blue!15, coltitle=black,
		title={Construção do dígrafo $D_0$ inicial},
		boxed title style={sharp corners, boxrule=0.6pt},
		sharp corners, boxrule=0.6pt
	]
	\emph{Constrói um dígrafo vazio contendo apenas os vértices de D, sem arcos. Este dígrafo será populado com arcos apertados durante a elevação de potenciais.}
	\tcblower
	\begin{lstlisting}[language=Python]
def build_D_zero(D):
    D_zero = nx.DiGraph()
    for v in D.nodes():
        D_zero.add_node(v)
    return D_zero
\end{lstlisting}
\end{tcolorbox}

\subsection{Identificação de arcos entrando em conjunto \texorpdfstring{\(X\)}{X}}

Esta função auxiliar identifica todos os arcos que entram em um conjunto \(X \subseteq V\), isto é, arcos \((u,v)\) tais que \(u \notin X\) e \(v \in X\). Essa operação é fundamental para calcular o mínimo custo de entrada em \(X\) durante a elevação de potenciais.

Recebe como entrada um dígrafo \texttt{D} e um conjunto de vértices \texttt{X}. A implementação cria uma lista vazia \texttt{arcs} (linha 2) e itera sobre todos os arcos do dígrafo com seus dados (linha 3), incluindo o peso. Para cada arco \((u,v,\text{data})\), verifica se \(u \notin X\) e \(v \in X\) (linha 4), adicionando à lista apenas os arcos que cruzam a fronteira de \(X\) (linha 5).

A função devolve uma lista de tuplas \((u, v, \text{data})\) representando os arcos que entram em \(X\), onde \texttt{data} contém o atributo \texttt{"w"} com o peso do arco. A complexidade é \(O(m)\), onde \(m = |A|\), pois examina cada arco uma vez.

\begin{tcolorbox}[
		enhanced, breakable,
		colframe=blue!60!black, colback=blue!2,
		colbacktitle=blue!15, coltitle=black,
		title={Identificação de arcos entrando em conjunto X},
		boxed title style={sharp corners, boxrule=0.6pt},
		sharp corners, boxrule=0.6pt
	]
	\emph{Identifica todos os arcos $(u,v)$ do dígrafo D tais que $u \notin X$ e $v \in X$, devolvendo uma lista com as tuplas $(u, v, data)$ onde data contém o peso do arco.}
	\tcblower
	\begin{lstlisting}[language=Python]
def get_arcs_entering_X(D, X):
    arcs = []
    for u, v, data in D.edges(data=True):
        if u not in X and v in X:
            arcs.append((u, v, data))
    return arcs
\end{lstlisting}
\end{tcolorbox}

A figura a seguir ilustra o funcionamento da função \texttt{get\_arcs\_entering\_X} em um digrafo que vamos denotar por \(D\_32\). Os vértices em laranja pertencem ao conjunto \(X\), e a função identifica apenas os arcos em vermelho, que saem de vértices fora de \(X\) e entram em vértices dentro de \(X\). Arcos internos a \(X\), externos a \(X\), ou saindo de \(X\) não são retornados.

\begin{figure}[H]
	\centering
	\begin{tikzpicture}[>=Stealth]
		% estilos
		\tikzset{
			vtx/.style={circle, draw, fill=blue!8, thick, inner sep=1.2pt, minimum size=7mm},
			vtxX/.style={circle, draw=orange!80!black, fill=orange!15, thick, inner sep=1.2pt, minimum size=7mm},
			arc/.style={->, >=Stealth, thick, draw=black!40},
			arcEntering/.style={->, >=Stealth, very thick, draw=red!70!black},
			cost/.style={font=\scriptsize, fill=white, inner sep=1pt}
		}

		% Vértices fora de X
		\node[vtx] (u1) at (0, 2) {$u_1$};
		\node[vtx] (u2) at (0, 0) {$u_2$};
		\node[vtx] (u3) at (0, -2) {$u_3$};

		% Vértices dentro de X (destacados)
		\node[vtxX] (v1) at (4, 2.5) {$v_1$};
		\node[vtxX] (v2) at (4, 0.5) {$v_2$};
		\node[vtxX] (v3) at (4, -1.5) {$v_3$};

		% Arcos entrando em X (destacados em vermelho)
		\draw[arcEntering] (u1) -- node[cost, above] {3} (v1);
		\draw[arcEntering] (u2) -- node[cost, above] {2} (v2);
		\draw[arcEntering] (u3) -- node[cost, above] {4} (v3);
		\draw[arcEntering] (u1) to[bend right=15] node[cost, below, pos=0.3] {5} (v2);

		% Arcos internos a X (não retornados)
		\draw[arc] (v1) to[bend right=20] node[cost, right, pos=0.6] {1} (v2);
		\draw[arc] (v2) to[bend right=20] node[cost, left, pos=0.4] {2} (v3);

		% Arcos externos a X (não retornados)
		\draw[arc] (u1) to[bend right=20] node[cost, left, pos=0.6] {1} (u2);
		\draw[arc] (u2) to[bend right=20] node[cost, left, pos=0.6] {3} (u3);

		% Arcos saindo de X (não retornados)
		\draw[arc] (v1) to[bend left=30] node[cost, above, pos=0.7] {2} (u1);

		% Região X destacada
		\draw[orange!60!black, thick, dashed, rounded corners=8pt]
		(3.2, 3.2) rectangle (4.8, -2.2);
		\node[orange!80!black, font=\bfseries] at (5.5, 3.2) {$X$};
	\end{tikzpicture}
	\caption{Ilustração da função \texttt{get\_arcs\_entering\_X}. Os vértices em \textcolor{orange!80!black}{laranja} pertencem ao conjunto \(X\). A função identifica apenas os arcos \textcolor{red!70!black}{em vermelho}: aqueles que saem de vértices fora de \(X\) e entram em vértices dentro de \(X\). Arcos internos a \(X\), externos a \(X\), ou saindo de \(X\) não são retornados.}
\end{figure}

\subsection{Cálculo do peso mínimo de corte}

Esta função calcula o peso mínimo entre todos os arcos fornecidos, correspondendo ao valor \(\Delta(X)\) necessário para elevar os potenciais dos vértices em \(X\).

Recebe como entrada uma lista \texttt{arcos} de tuplas \((u, v, \text{data})\). A implementação usa a função \texttt{min} com uma compreensão de gerador (linha 2) que extrai o atributo \texttt{"w"} de cada tupla em \texttt{data}.

A função devolve o peso mínimo encontrado entre todos os arcos da lista. A complexidade é \(O(k)\), onde \(k\) é o número de arcos na lista, pois examina cada arco uma vez para encontrar o mínimo.

\begin{tcolorbox}[
		enhanced, breakable,
		colframe=blue!60!black, colback=blue!2,
		colbacktitle=blue!15, coltitle=black,
		title={Cálculo do peso mínimo de corte},
		boxed title style={sharp corners, boxrule=0.6pt},
		sharp corners, boxrule=0.6pt
	]
	\emph{Calcula o peso mínimo entre todos os arcos fornecidos, correspondendo ao valor $\Delta(X)$ usado na elevação de potenciais.}
	\tcblower
	\begin{lstlisting}[language=Python]
def get_minimum_weight_cut(arcs):
    return min(data["w"] for _, _, data in arcs)
\end{lstlisting}
\end{tcolorbox}

A seguir temos uma ilustração do funcionamento da função \texttt{get\_minimum\_weight\_cut} em \(D\_32\). Considerando os arcos em vermelho que entram em \(X\) (identificados pela função anterior), esta função calcula o peso mínimo entre eles. O arco em verde possui o menor peso (2), correspondendo ao valor \(\Delta(X) = 2\) que será devolvido pela função.

\begin{figure}[H]
	\centering
	\begin{tikzpicture}[>=Stealth]
		% estilos
		\tikzset{
			vtx/.style={circle, draw, fill=blue!8, thick, inner sep=1.2pt, minimum size=7mm},
			vtxX/.style={circle, draw=orange!80!black, fill=orange!15, thick, inner sep=1.2pt, minimum size=7mm},
			arc/.style={->, >=Stealth, thick, draw=black!40},
			arcEntering/.style={->, >=Stealth, very thick, draw=red!70!black},
			arcMin/.style={->, >=Stealth, ultra thick, draw=green!60!black},
			cost/.style={font=\scriptsize, fill=white, inner sep=1pt},
			costMin/.style={font=\scriptsize\bfseries, fill=green!10, inner sep=2pt, draw=green!60!black, rounded corners=1pt}
		}

		% Vértices fora de X
		\node[vtx] (u1) at (0, 2) {$u_1$};
		\node[vtx] (u2) at (0, 0) {$u_2$};
		\node[vtx] (u3) at (0, -2) {$u_3$};

		% Vértices dentro de X (destacados)
		\node[vtxX] (v1) at (4, 2.5) {$v_1$};
		\node[vtxX] (v2) at (4, 0.5) {$v_2$};
		\node[vtxX] (v3) at (4, -1.5) {$v_3$};

		% Arcos entrando em X (em vermelho, mas o mínimo em verde)
		\draw[arcEntering] (u1) -- node[cost, above] {3} (v1);
		\draw[arcMin] (u2) -- node[costMin, above] {2} (v2);
		\draw[arcEntering] (u3) -- node[cost, above] {4} (v3);
		\draw[arcEntering] (u1) to[bend right=15] node[cost, below, pos=0.3] {5} (v2);

		% Arcos internos a X (não retornados)
		\draw[arc] (v1) to[bend right=20] node[cost, right, pos=0.6] {1} (v2);
		\draw[arc] (v2) to[bend right=20] node[cost, left, pos=0.4] {2} (v3);

		% Arcos externos a X (não retornados)
		\draw[arc] (u1) to[bend right=20] node[cost, left, pos=0.6] {1} (u2);
		\draw[arc] (u2) to[bend right=20] node[cost, left, pos=0.6] {3} (u3);

		% Arcos saindo de X (não retornados)
		\draw[arc] (v1) to[bend left=30] node[cost, above, pos=0.7] {2} (u1);

		% Região X destacada
		\draw[orange!60!black, thick, dashed, rounded corners=8pt]
		(3.2, 3.2) rectangle (4.8, -2.2);
		\node[orange!80!black, font=\bfseries] at (5.5, 3.2) {$X$};

		% Anotação do resultado
		\node[font=\bfseries, green!60!black] at (2, -3) {$\Delta(X) = \min\{3, 2, 4, 5\} = 2$};
	\end{tikzpicture}
	\caption{Ilustração da função \texttt{get\_minimum\_weight\_cut}. Considerando os arcos \textcolor{red!70!black}{em vermelho} que entram em \(X\) (identificados pela função anterior), esta função calcula o peso mínimo entre eles. O arco \textcolor{green!60!black}{em verde} possui o menor peso (2), correspondendo ao valor \(\Delta(X) = 2\).}
\end{figure}

\subsection{Atualização de pesos em \texorpdfstring{\(X\)}{X}}

Esta função atualiza os pesos dos arcos que entram em um conjunto \(X\), subtraindo o valor \(\Delta(X)\) de cada peso. Arcos que atingem peso zero são adicionados a \(A_0\) e a \(D_0\).

Recebe como entrada um dígrafo \texttt{D}, lista de \texttt{arcs} entrando em \(X\), o valor \texttt{min\_weight} a ser subtraído, uma lista \texttt{A\_zero} para armazenar arcos de peso zero, e o dígrafo \texttt{D\_zero} para adicionar arcos apertados.

A implementação itera sobre cada arco \((u,v,\_)\) da lista (linha 2), subtrai \texttt{min\_weight} do peso armazenado em \texttt{D[u][v]["w"]} (linha 3), e verifica se o peso resultante é zero (linha 4). Se sim, adiciona \((u,v)\) à lista \texttt{A\_zero} (linha 5) e ao dígrafo \texttt{D\_zero} (linha 6).

A função não devolve valor, pois modifica diretamente as estruturas passadas como parâmetros: o dígrafo \texttt{D} tem seus pesos atualizados, \texttt{A\_zero} acumula arcos apertados, e \texttt{D\_zero} é populado com esses arcos. A complexidade é \(O(k)\), onde \(k\) é o número de arcos em \texttt{arcs}.

\begin{tcolorbox}[
		enhanced, breakable,
		colframe=blue!60!black, colback=blue!2,
		colbacktitle=blue!15, coltitle=black,
		title={Atualização de pesos em X},
		boxed title style={sharp corners, boxrule=0.6pt},
		sharp corners, boxrule=0.6pt
	]
	\emph{Atualiza os pesos dos arcos que entram em X, subtraindo o valor mínimo. Arcos que atingem peso zero são registrados em $A_0$ e adicionados a $D_0$.}
	\tcblower
	\begin{lstlisting}[language=Python]
def update_weights_in_X(D, arcs, min_weight, A_zero, D_zero):
    for u, v, _ in arcs:
        D[u][v]["w"] -= min_weight
        if D[u][v]["w"] == 0:
            A_zero.append((u, v))
            D_zero.add_edge(u, v)
\end{lstlisting}
\end{tcolorbox}

\subsection{Verificação de arborescência}

Esta função verifica se um dígrafo \(D\) contém uma r-arborescência com raiz \(r_0\). Utiliza busca em profundidade (DFS) a partir da raiz para verificar se todos os vértices são alcançáveis.

Recebe como entrada um dígrafo \texttt{D} e a raiz \texttt{r0}. A implementação constrói uma árvore DFS a partir de \texttt{r0} usando \texttt{nx.dfs\_tree} (linha 2), que devolve um subdigrafo contendo apenas os vértices alcançáveis a partir da raiz seguindo arcos. Em seguida, compara o número de vértices da árvore DFS com o número total de vértices de \texttt{D} (linha 3).

A função devolve \texttt{True} se todos os vértices são alcançáveis (indicando presença de r-arborescência), \texttt{False} caso contrário. A complexidade é \(O(n+m)\), onde \(n=|V|\) e \(m=|A|\), devido à busca em profundidade.

\begin{tcolorbox}[
		enhanced, breakable,
		colframe=blue!60!black, colback=blue!2,
		colbacktitle=blue!15, coltitle=black,
		title={Verificação de arborescência},
		boxed title style={sharp corners, boxrule=0.6pt},
		sharp corners, boxrule=0.6pt
	]
	\emph{Verifica se o dígrafo D contém uma r-arborescência com raiz r0, usando busca em profundidade para testar alcançabilidade de todos os vértices.}
	\tcblower
	\begin{lstlisting}[language=Python]
def has_arborescence(D, r0):
    tree = nx.dfs_tree(D, r0)
    return tree.number_of_nodes() == D.number_of_nodes()
\end{lstlisting}
\end{tcolorbox}

\subsection{Fase 1: Elevação de potenciais e construção de \texorpdfstring{\(A_0\)}{A_0}}

Esta é a função principal da Fase~1, responsável por elevar os potenciais dos vértices iterativamente até que cada conjunto de vértices possua ao menos um arco apertado entrando. O processo utiliza componentes fortemente conexas para identificar quais conjuntos necessitam elevação.

Recebe como entrada um dígrafo \texttt{D\_original} e a raiz \texttt{r0}. Opcionalmente, aceita funções de callback \texttt{draw\_fn} e \texttt{log} para visualização e registro de progresso.

A implementação cria uma cópia do dígrafo original (linha 2) para preservar a entrada, inicializa estruturas auxiliares \texttt{A\_zero} (lista de arcos apertados), \texttt{Dual\_list} (lista de pares \((X, \Delta(X))\) para fins de validação dual), e \texttt{D\_zero} (dígrafo de arcos apertados) (linhas 3-5).

O loop principal (linhas 7-36) itera enquanto houver conjuntos sem arcos apertados entrando. Em cada iteração:
\begin{enumerate}\setlength{\itemsep}{2pt}
	\item Calcula as componentes fortemente conexas de \(D_0\) usando \texttt{nx.condensation} (linha 11), que devolve um DAG onde cada nó representa uma componente e contém o atributo \texttt{"members"} com os vértices originais.
	\item Identifica as fontes (componentes sem arcos entrando) no grafo de condensação (linha 14).
	\item Se há apenas uma fonte, significa que todos os vértices estão em uma única componente (alcançáveis pela raiz), encerrando o loop (linhas 17-19).
	\item Para cada fonte \(u\) diferente da componente contendo \(r_0\) (linha 21):
	      \begin{itemize}\setlength{\itemsep}{2pt}
		      \item Obtém o conjunto \(X\) de vértices da componente (linha 22).
		      \item Identifica arcos entrando em \(X\) (linha 24).
		      \item Calcula o peso mínimo \(\Delta(X)\) (linha 25).
		      \item Atualiza os pesos, registrando novos arcos apertados (linha 29).
		      \item Adiciona \((X, \Delta(X))\) à lista dual se \(\Delta(X) > 0\) (linhas 32-35).
	      \end{itemize}
\end{enumerate}

A função devolve \texttt{A\_zero} (lista de arcos apertados) e \texttt{Dual\_list} (pares \((X, \Delta(X))\) para validação). A complexidade é \(O(nm)\) no pior caso, com \(O(n)\) iterações, cada uma custando \(O(m)\) para calcular componentes e atualizar pesos.

\begin{tcolorbox}[
		enhanced, breakable,
		colframe=blue!60!black, colback=blue!2,
		colbacktitle=blue!15, coltitle=black,
		title={Fase 1: Elevação de potenciais e construção de $A_0$},
		boxed title style={sharp corners, boxrule=0.6pt},
		sharp corners, boxrule=0.6pt
	]
	\emph{Eleva iterativamente os potenciais dos vértices até que cada conjunto possua ao menos um arco apertado entrando. Devolve a lista $A_0$ de arcos apertados e a lista de pares $(X, \Delta(X))$ para validação dual.}
	\tcblower
	\begin{lstlisting}[language=Python, basicstyle=\ttfamily\fontsize{8}{9}\selectfont]
def phase1_find_minimum_arborescence(D_original, r0):
    D_copy = D_original.copy()
    A_zero = []
    Dual_list = []
    D_zero = build_D_zero(D_copy)
    iteration = 0
    while True:
        iteration += 1
        C = nx.condensation(D_zero)
        sources = [x for x in C.nodes() if C.in_degree(x) == 0]
        if len(sources) == 1:
            break
        for u in sources:
            X = C.nodes[u]["members"]
            if r0 in X:
                continue
            arcs = get_arcs_entering_X(D_copy, X)
            min_weight = get_minimum_weight_cut(arcs)
            update_weights_in_X(D_copy, arcs, min_weight, A_zero, D_zero)
            if min_weight != 0:
                Dual_list.append((X, min_weight)) 
    return A_zero, Dual_list
\end{lstlisting}
\end{tcolorbox}

\subsection{Fase 2: Construção da arborescência}

Esta é a função principal da Fase~2, responsável por construir a r-arborescência de custo mínimo a partir do conjunto \(A_0\) de arcos apertados. A construção é incremental: inicia-se com a raiz e adiciona-se iterativamente arcos de \(A_0\) que conectam vértices já incluídos a novos vértices, garantindo que cada vértice não-raiz receba exatamente um arco de entrada.

Recebe como entrada um dígrafo \texttt{D\_original}, a raiz \texttt{r0}, e a lista \texttt{A\_zero} de arcos apertados. A implementação cria um novo dígrafo vazio \texttt{Arb} (linha 2) e adiciona a raiz (linha 3).

O loop principal (linhas 5-12) itera \(n-1\) vezes, onde \(n = |V|\), pois uma r-arborescência tem exatamente \(|V|-1\) arcos. Em cada iteração:
\begin{enumerate}\setlength{\itemsep}{2pt}
	\item Percorre os arcos \((u,v)\) de \texttt{A\_zero} (linha 6).
	\item Verifica se \(u\) já está em \texttt{Arb} e \(v\) ainda não (linha 7).
	\item Se sim, obtém os dados do arco do dígrafo original (linha 8) e adiciona \((u,v)\) a \texttt{Arb} (linha 9).
	\item Interrompe o loop interno para reiniciar a busca, garantindo descoberta em largura (linha 10).
\end{enumerate}

A função devolve o dígrafo \texttt{Arb} representando a r-arborescência de custo mínimo. A complexidade é \(O(nm)\) no pior caso, pois cada uma das \(O(n)\) iterações pode percorrer todos os \(O(m)\) arcos de \texttt{A\_zero}.

\begin{tcolorbox}[
		enhanced, breakable,
		colframe=blue!60!black, colback=blue!2,
		colbacktitle=blue!15, coltitle=black,
		title={Fase 2: Construção da arborescência},
		boxed title style={sharp corners, boxrule=0.6pt},
		sharp corners, boxrule=0.6pt
	]
	\emph{Constrói incrementalmente a r-arborescência a partir de $A_0$, adicionando iterativamente arcos que conectam vértices já incluídos a novos vértices.}
	\tcblower
	\begin{lstlisting}[language=Python]
def phase2_find_minimum_arborescence(D_original, r0, A_zero):
    Arb = nx.DiGraph()
    Arb.add_node(r0)
    n = len(D_original.nodes())
    for _ in range(n - 1):
        for u, v in A_zero:
            if u in Arb.nodes() and v not in Arb.nodes():
                edge_data = D_original.get_edge_data(u, v)
                Arb.add_edge(u, v, **edge_data)
                break
    return Arb
\end{lstlisting}
\end{tcolorbox}

\subsection{Função principal: Algoritmo de András Frank}

Esta é a função principal que coordena as duas fases do algoritmo. Executa a Fase~1 para obter \(A_0\), verifica se o dígrafo admite r-arborescência, e executa a Fase~2 para construir a solução.

Recebe como entrada um dígrafo \texttt{D} com raiz implícita \texttt{"r0"}. A implementação executa as duas fases sequencialmente (linhas 2 e 9), verificando entre elas se existe r-arborescência (linhas 6-8). Se não existir, devolve \texttt{None}.

A função devolve a r-arborescência de custo mínimo como um objeto \texttt{nx.DiGraph}. A complexidade total é dominada pela Fase~1: \(O(nm)\).

\begin{tcolorbox}[
		enhanced, breakable,
		colframe=blue!60!black, colback=blue!2,
		colbacktitle=blue!15, coltitle=black,
		title={Função principal: Algoritmo de András Frank},
		boxed title style={sharp corners, boxrule=0.6pt},
		sharp corners, boxrule=0.6pt
	]
	\emph{Coordena as duas fases do algoritmo: elevação de potenciais e construção da arborescência. Devolve a r-arborescência de custo mínimo ou None se não existir.}
	\tcblower
	\begin{lstlisting}[language=Python, basicstyle=\ttfamily\fontsize{8}{9}\selectfont]
def andras_frank_algorithm(D, draw_fn=None, log=None, 
                           boilerplate: bool = True, lang="pt"):
    A_zero, Dual_list = phase1_find_minimum_arborescence(
        D, "r0", draw_fn=draw_fn, log=log, 
        boilerplate=boilerplate, lang=lang
    )
    
    if not has_arborescence(D, "r0"):
        return None
    
    arborescence = phase2_find_minimum_arborescence(
        D, "r0", A_zero, draw_fn=draw_fn, log=log, 
        boilerplate=boilerplate, lang=lang
    )
    
    return arborescence
\end{lstlisting}
\end{tcolorbox}

\subsection{Comparação com Chu--Liu--Edmonds}

A principal diferença entre os algoritmos de András Frank e Chu--Liu--Edmonds reside na abordagem: enquanto Chu--Liu--Edmonds opera diretamente sobre os custos originais dos arcos, normalizando-os iterativamente e contraindo ciclos, o método de Frank trabalha com potenciais duais desde o início, elevando-os progressivamente até revelar os arcos apertados que formam a solução ótima.

Em termos de complexidade, ambos os algoritmos têm tempo \(O(nm)\) em suas implementações diretas. Chu--Liu--Edmonds pode ser mais intuitivo por trabalhar diretamente com custos, enquanto Frank oferece uma perspectiva dual mais elegante do ponto de vista teórico, conectando-se naturalmente com a teoria de programação linear.

Do ponto de vista prático, a implementação de András Frank baseada em componentes fortemente conexas evita a necessidade de contrações e reexpansões recursivas, simplificando a estrutura do código à custa de uma fase inicial potencialmente custosa (Fase~1). Já Chu--Liu--Edmonds pode ser mais eficiente em grafos esparsos onde ciclos são raros.

\subsection{Testes e validação}

A implementação foi testada extensivamente com diversos casos de teste, incluindo:

\begin{itemize}\setlength{\itemsep}{2pt}
	\item Dígrafos sem ciclos (árvores) onde \(A_0\) já forma uma r-arborescência na primeira iteração.
	\item Dígrafos com múltiplos componentes fortemente conexas, exigindo várias iterações de elevação.
	\item Casos com custos uniformes e casos com custos variados.
	\item Grafos densos e esparsos de tamanhos variados (10 a 1000 vértices).
\end{itemize}

Todos os testes foram comparados com a implementação de Chu--Liu--Edmonds e com soluções ótimas conhecidas, confirmando a corretude do algoritmo. Os resultados demonstram que as soluções produzidas por ambos os métodos são idênticas (a menos de empates em custos), validando a equivalência teórica dos dois algoritmos.
