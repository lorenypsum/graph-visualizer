\chapter{Algoritmo de András Frank}

Neste capítulo, apresentaremos o algoritmo de András Frank, que também determina
uma arborescência de custo mínimo em um digrafo ponderado.
O algoritmo baseia-se em duas operações fundamentais:
(i) a redução gulosa dos custos dos arcos através da identificação de subconjuntos minimais
e (ii) a contração de ciclos, de modo a resolver recursivamente uma instância menor do
problema e, em seguida, estender a solução para o problema original.
A operação de redução é essencialmente a mesma do algoritmo de Chu--Liu--Edmonds
--- subtrair o menor custo de arco entrando em cada conjunto --- mas enquanto
Chu--Liu--Edmonds opera vértice a vértice, o algoritmo de Frank identifica
\emph{subconjuntos minimais} através de componentes fortemente conexas,
processando todos simultaneamente a cada iteração.
O propósito deste capítulo é fornecer tanto uma descrição teórica do algoritmo quanto detalhes da implementação desenvolvida neste trabalho.

\section{O algoritmo}
\label{sec:algoritmo}
O algoritmo de András Frank também recebe uma tripla \((D,c,r)\), em que \(D=(V,A)\) é um digrafo,
\(c\colon A\to\mathbb{R}\) é uma função custo e \(r\in V\) é a raiz,
sob a hipótese de que \(D\) admite ao menos uma \(r\)-arborescência e devolve uma \(r\)-arborescência \(c\)-mínima de \(D\).

Assim como no capítulo anterior, adotamos a terminologia de \(r\)-digrafo ponderado para uma tripla \((D,c,r)\) em que $(D, c)$ é um digrafo ponderado,
$r$ é um vértice de $D$, $\delta^-(r) = \varnothing$
e $D$ possui uma $r$-arborescência.

O algoritmo de Frank opera em duas fases principais: (i) redução de custos e (ii) construção da arborescência a partir dos arcos que se tornaram justos (custo reduzido zero).

Na primeira fase, identificamos iterativamente os \emph{subconjuntos minimais} um conjunto \(X \subseteq V \setminus \{r\}\) é dito minimal se não há arcos justos entrando em \(X\) (ou seja, nenhum arco \((u,v)\) com \(u \notin X\) e \(v \in X\) possui custo reduzido zero) e para qualquer subconjunto próprio \(Y \subset X\), existe ao menos um arco justo entrando em \(Y\), essa segunda condição garante a propriedade de minimalidade, pois não podemos encontrar um subconjunto menor que também não tenha arcos justos entrando.

Assim, para cada conjunto minimal \(X\), calculamos
\(\delta(X)\), o menor custo entre todos os arcos que entram em \(X\), e subtraímos esse valor de todos
esses arcos, criando ao menos um novo arco justo. Esse processo é repetido até que exista exatamente uma
\emph{fonte} no digrafo atualizado também chamado de digrafo de condensação.

Aqui \emph{fonte} refere-se a um vértice no digrafo de condensação que não tenha arcos justos entrando.

Vamos desenvolver essas ideias utilizando um exemplo: considere o dígrafo \(D\) da Figura~\ref{fig:frank-exemplo-inicial} com seis vértices
\(\{r, a, b, c, d, e\}\) e custos nos arcos para ilustrar
o comportamento completo do algoritmo.

\begin{figure}[H]
	\centering
	\begin{tikzpicture}[>=Stealth, scale=1.1]
		% estilos
		\tikzset{
			vtx/.style={circle, draw,fill=blue!8, thick, inner sep=1.2pt, minimum size=7mm},
			arc/.style={->, semithick, draw=black!50},
			costG/.style={font=\small, fill=white, inner sep=1.5pt, text=black!70}
		}

		% layout
		\node[vtx] (r) at (0,0) {$r$};
		\node[vtx] (a) at (3,2) {$a$};
		\node[vtx] (b) at (3,-2) {$b$};
		\node[vtx] (c) at (6,2) {$c$};
		\node[vtx] (d) at (6,0) {$d$};
		\node[vtx] (e) at (6,-2) {$e$};

		% arcos com custos
		\draw[arc] (r) -- node[costG, above left] {2} (a);
		\draw[arc] (r) -- node[costG, below left] {3} (b);
		\draw[arc] (r) .. controls (2,3.5) and (5,3.5) .. node[costG, above] {7} (c);

		\draw[arc] (a) -- node[costG, above] {5} (c);
		\draw[arc] (a) -- node[costG, right] {4} (d);
		\draw[arc] (b) -- node[costG, below] {2} (e);
		\draw[arc] (b) to[bend right=15] node[costG, left] {5} (a);

		\draw[arc] (c) to[bend left=15] node[costG, right] {1} (d);
		\draw[arc] (d) to[bend left=15] node[costG, left] {1} (c);
		\draw[arc] (d) -- node[costG, right] {3} (e);

		\draw[arc] (c) .. controls (7.5,2.5) and (7.5,-2.5) .. node[costG, right] {6} (e);
	\end{tikzpicture}
	\caption{Dígrafo \(D\) com custos originais. Este exemplo ilustrará todas as etapas
		do algoritmo de András Frank, incluindo formação de ciclos e contração.}
	\label{fig:frank-exemplo-inicial}
\end{figure}

\paragraph*{Fase 1}

Inicialmente, nenhum arco tem custo reduzido zero, cada vértice não-raiz \(v \neq r\) forma
seu próprio subconjunto minimal \(\{v\}\). No dígrafo da Figura~\ref{fig:frank-exemplo-inicial},
os subconjuntos minimais iniciais são portanto \(\{a\}\), \(\{b\}\), \(\{c\}\), \(\{d\}\) e \(\{e\}\).
Para cada um desses conjuntos unitários, encontramos \(\delta(\{v\})\), o menor custo entre todos os arcos
entrando em \(v\), e subtraímos esse valor de todos esses arcos.

Por exemplo, consideremos o vértice \(a\). Os arcos entrando em \(a\) são \((r,a)\) com custo 2
e \((b,a)\) com custo 5. Calculamos \(\delta(\{a\}) = \min\{2, 5\} = 2\) e subtraímos este valor
de ambos os arcos. Assim, \((r,a)\) passa a ter custo \(0\)
e \((b,a)\) passa a ter custo \(3\). A Figura~\ref{fig:frank-reducao-exemplo-a} ilustra
essa operação de redução aplicada ao vértice \(a\).

\begin{figure}[H]
	\centering
	\begin{tikzpicture}[>=Stealth, scale=0.95]
		\tikzset{
			vtx/.style={circle, draw,fill=blue!8, thick, inner sep=1.2pt, minimum size=7mm},
			vtxH/.style={circle, draw=orange!70, fill=orange!15, thick, inner sep=1.2pt, minimum size=8mm},
			arc/.style={->, semithick, draw=black!35},
			arcH/.style={->, ultra thick, draw=orange!70},
			tight/.style={->, very thick, draw=blue!70},
			costG/.style={font=\small, fill=white, inner sep=1.5pt, text=black!50},
			costO/.style={font=\small, fill=white, inner sep=1.5pt, text=orange!70, font=\small\bfseries},
			costB/.style={font=\small, fill=white, inner sep=1.5pt, text=blue!70}
		}

		% Antes da redução (dígrafo completo)
		\begin{scope}
			\node[font=\bfseries, above] at (3, 3.8) {Antes: custos originais};

			\node[vtx] (r1) at (0,0) {$r$};
			\node[vtxH] (a1) at (3,2) {$a$};
			\node[vtx] (b1) at (3,-2) {$b$};
			\node[vtx] (c1) at (6,2) {$c$};
			\node[vtx] (d1) at (6,0) {$d$};
			\node[vtx] (e1) at (6,-2) {$e$};

			% Arcos destacados entrando em 'a'
			\draw[arcH] (r1) -- node[costO, above left] {2} (a1);
			\draw[arcH] (b1) to[bend right=15] node[costO, left] {5} (a1);

			% Demais arcos
			\draw[arc] (r1) -- node[costG, below left] {3} (b1);
			\draw[arc] (r1) .. controls (1,3.5) and (5,3.5) .. node[costG, above] {7} (c1);
			\draw[arc] (a1) -- node[costG, above] {5} (c1);
			\draw[arc] (a1) -- node[costG, right] {4} (d1);
			\draw[arc] (b1) -- node[costG, below] {2} (e1);
			\draw[arc] (c1) to[bend left=15] node[costG, right] {1} (d1);
			\draw[arc] (d1) to[bend left=15] node[costG, left] {1} (c1);
			\draw[arc] (d1) -- node[costG, right] {3} (e1);
			\draw[arc] (c1) .. controls (7.5,2.5) and (7.5,-2.5) .. node[costG, right] {6} (e1);

			\node[orange!70, font=\small] at (3, -3.2) {$\delta(\{a\}) = \min\{2, 5\} = 2$};
		\end{scope}

		% Depois da redução (dígrafo completo)
		\begin{scope}[xshift=9.5cm]
			\node[font=\bfseries, above] at (3, 3.8) {Após redução de $\delta(\{a\})$};

			\node[vtx] (r2) at (0,0) {$r$};
			\node[vtxH] (a2) at (3,2) {$a$};
			\node[vtx] (b2) at (3,-2) {$b$};
			\node[vtx] (c2) at (6,2) {$c$};
			\node[vtx] (d2) at (6,0) {$d$};
			\node[vtx] (e2) at (6,-2) {$e$};

			% Arco justo
			\draw[tight] (r2) -- node[costB, above left] {0} (a2);
			% Arco reduzido
			\draw[arcH] (b2) to[bend right=15] node[costO, left] {3} (a2);

			% Demais arcos (custos inalterados)
			\draw[arc] (r2) -- node[costG, below left] {3} (b2);
			\draw[arc] (r2) .. controls (1,3.5) and (5,3.5) .. node[costG, above] {7} (c2);
			\draw[arc] (a2) -- node[costG, above] {5} (c2);
			\draw[arc] (a2) -- node[costG, right] {4} (d2);
			\draw[arc] (b2) -- node[costG, below] {2} (e2);
			\draw[arc] (c2) to[bend left=15] node[costG, right] {1} (d2);
			\draw[arc] (d2) to[bend left=15] node[costG, left] {1} (c2);
			\draw[arc] (d2) -- node[costG, right] {3} (e2);
			\draw[arc] (c2) .. controls (7.5,2.5) and (7.5,-2.5) .. node[costG, right] {6} (e2);

			\node[blue!70, font=\small] at (3, -3.2) {$(r,a)$ torna-se \textbf{justo} (custo 0)};
		\end{scope}
	\end{tikzpicture}
	\caption{Exemplo de redução de custo para o vértice \(a\) no dígrafo completo. À esquerda,
		os arcos entrando em \(a\) estão destacados em laranja com custos originais 2 e 5.
		Calculamos \(\delta(\{a\}) = 2\) e subtraímos esse valor de ambos os arcos. À direita,
		após a redução: \((r,a)\) tem custo zero (arco justo, em azul) e \((b,a)\) tem custo
		\(5-2=3\) (em laranja). Os demais arcos permanecem inalterados.}
	\label{fig:frank-reducao-exemplo-a}
\end{figure}

Essa operação vai sendo repetida para todos os conjuntos minimais iniciais.
A Figura~\ref{fig:frank-iter1-result} mostra o resultado dessa primeira iteração no exemplo
da Figura~\ref{fig:frank-exemplo-inicial}, onde aplicamos a redução apenas para os vértices isolados.

\begin{figure}[H]
	\centering
	\begin{tikzpicture}[>=Stealth, scale=1.1]
		\tikzset{
			vtx/.style={circle, draw,fill=blue!8, thick, inner sep=1.2pt, minimum size=7mm},
			tight/.style={->, very thick, draw=blue!70},
			loose/.style={->, semithick, draw=black!35},
			costB/.style={font=\small, fill=white, inner sep=1.5pt, text=blue!70},
			costG/.style={font=\small, fill=white, inner sep=1.5pt, text=black!50}
		}

		\node[vtx] (r) at (0,0) {$r$};
		\node[vtx] (a) at (3,2) {$a$};
		\node[vtx] (b) at (3,-2) {$b$};
		\node[vtx] (c) at (6,2) {$c$};
		\node[vtx] (d) at (6,0) {$d$};
		\node[vtx] (e) at (6,-2) {$e$};

		% arcos justos (apenas alguns)
		\draw[tight] (r) -- node[costB, above left] {0} (a);
		\draw[tight] (c) to[bend left=15] node[costB, right] {0} (d);
		\draw[tight] (b) -- node[costB, below] {0} (e);
		\draw[tight] (r) -- node[costB, below left] {0} (b);
		% arcos não justos
		\draw[loose] (r) .. controls (2,3.5) and (5,3.5) .. node[costG, above] {6} (c);  % 7-1-2 = 4
		\draw[loose] (a) -- node[costG, right] {3} (d);  % 4-2 = 2
		\draw[loose] (a) -- node[costG, above] {4} (c);
		% 3-2 = 1 (ainda não é justo!)
		\draw[loose] (b) to[bend right=15] node[costG, left] {3} (a);  % 5-2 = 3
		\draw[tight] (d) to[bend left=15] node[costB, left] {0} (c);  % 1-1 = 0 (forma ciclo!)
		\draw[loose] (d) -- node[costG, right] {1} (e);  % 3-1 = 2
		\draw[loose] (c) .. controls (7.5,2.5) and (7.5,-2.5) .. node[costG, right] {4} (e);  % 6-1-2 = 3
	\end{tikzpicture}
	\caption{Dígrafo após a primeira iteração. Os arcos justos (custo 0) são: \((r,a)\), \((r,b)\),
		\((b,e)\), \((c,d)\) e \((d,c)\). Todos os vértices não-raiz possuem arcos justos
		entrando: \(a\) tem \((r,a)\), \(b\) tem \((r,b)\), \(e\) tem \((b,e)\), e o conjunto
		\(\{c,d\}\) tem \((a,c)\) (além do ciclo interno). Os arcos \((c,d)\) e \((d,c)\)
		formam um ciclo justo.}
	\label{fig:frank-iter1-result}
\end{figure}

Se esses arcos de custo zero formam uma \(r\)-arborescência, o algoritmo termina. Caso contrário, identificamos novamente os subconjuntos minimais sem arcos de custo zero entrando neles.

Antes de prosseguirmos com a iteração seguinte, precisamos salientar que em uma iteração do algoritmo, pode haver múltiplas fontes no grafo de condensação (excluindo a componente que contém a raiz). Qualquer uma dessas fontes pode ser escolhida como conjunto minimal para modificação de custo. A escolha específica não afeta a corretude do algoritmo, apenas a ordem em que os arcos se tornam justos.

Para ilustrar, considere um dígrafo simples com raiz \(r_0\) conectada a três vértices \(a\), \(b\), e \(c\) através de arcos com custos 2, 3, e 2 respectivamente. Após a inicialização, todas as três componentes \(\{a\}\), \(\{b\}\), \(\{c\}\) são fontes (cada uma sem arcos justos entrando). O algoritmo pode escolher qualquer uma delas:
\begin{itemize}\setlength{\itemsep}{2pt}
	\item Se escolhermos \(\{a\}\): elevamos seu potencial por \(\Delta(\{a\}) = 2\), tornando \((r_0, a)\) justo.
	\item Se escolhermos \(\{b\}\): elevamos seu potencial por \(\Delta(\{b\}) = 3\), tornando \((r_0, b)\) justo.
	\item Se escolhermos \(\{c\}\): elevamos seu potencial por \(\Delta(\{c\}) = 2\), tornando \((r_0, c)\) justo.
\end{itemize}

Em cada caso, após a elevação, a componente escolhida deixa de ser uma fonte (pois agora possui um arco justo entrando). O algoritmo continua processando as fontes restantes nas iterações subsequentes. A ordem de processamento não afeta o custo total da arborescência final, pois todas as elevações são necessárias e determinadas univocamente pelos custos dos arcos.

\begin{figure}[H]
	\centering
	\begin{tikzpicture}[>=Stealth, scale=1.0]
		\tikzset{
			vtx/.style={circle, draw, fill=blue!8, thick, inner sep=1.2pt, minimum size=7mm},
			vtxRoot/.style={circle, draw, fill=red!15, thick, inner sep=1.2pt, minimum size=7mm},
			vtxSource/.style={circle, draw=orange!70, fill=orange!15, thick, inner sep=1.2pt, minimum size=7mm},
			arc/.style={->, thick, draw=gray!60},
			cost/.style={font=\scriptsize, fill=white, inner sep=1pt}
		}

		% Dígrafo inicial
		\begin{scope}
			\node[font=\bfseries, above] at (2, 3.2) {Estado inicial: múltiplas fontes};

			\node[vtxRoot] (r0) at (2, 2) {$r_0$};
			\node[vtxSource] (a) at (0, 0) {$a$};
			\node[vtxSource] (b) at (2, 0) {$b$};
			\node[vtxSource] (c) at (4, 0) {$c$};

			\draw[arc] (r0) -- node[cost, left] {2} (a);
			\draw[arc] (r0) -- node[cost, right] {3} (b);
			\draw[arc] (r0) -- node[cost, right] {2} (c);

			\node[orange!70!black, font=\small, align=center] at (2, -1.2) {Três fontes: $\{a\}$, $\{b\}$, $\{c\}$\\Qualquer uma pode ser processada};
		\end{scope}

		% Seta
		\draw[->, ultra thick, gray!60] (5.5, 1) -- node[above, font=\small, align=center] {escolhe\\$\{a\}$} (6.5, 1);

		% Após processar {a}
		\begin{scope}[xshift=7.5cm]
			\node[font=\bfseries, above] at (2, 3.2) {Após processar $\{a\}$};

			\node[vtxRoot] (r0b) at (2, 2) {$r_0$};
			\node[vtx] (ab) at (0, 0) {$a$};
			\node[vtxSource] (bb) at (2, 0) {$b$};
			\node[vtxSource] (cb) at (4, 0) {$c$};

			\draw[arc, blue!70, ultra thick] (r0b) -- node[cost, left, fill=blue!10] {0} (ab);
			\draw[arc] (r0b) -- node[cost, right] {3} (bb);
			\draw[arc] (r0b) -- node[cost, right] {2} (cb);

			\node[blue!70!black, font=\small, align=center] at (2, -1.2) {$(r_0, a)$ justo\\Fontes restantes: $\{b\}$, $\{c\}$};
		\end{scope}
	\end{tikzpicture}
	\caption{Exemplo de múltiplas fontes disponíveis para processamento. À esquerda, o estado
		inicial possui três componentes \(\{a\}\), \(\{b\}\), \(\{c\}\) (em laranja) que são fontes
		no grafo de condensação. Qualquer uma pode ser escolhida. À direita, após escolher e
		processar \(\{a\}\) (elevando seu potencial por \(\Delta(\{a\}) = 2\)), o arco \((r_0, a)\)
		torna-se justo (em azul). Agora \(\{a\}\) deixa de ser fonte e as fontes restantes são
		\(\{b\}\) e \(\{c\}\). A ordem de processamento não afeta a arborescência ótima final.}
	\label{fig:frank-multiplas-fontes}
\end{figure}

No exemplo da Figura~\ref{fig:frank-iter1-result}, após a primeira iteração de redução, temos os vértices \(\{a\}\), \(\{b\}\), \(\{e\}\) que são componentes triviais (cada um forma sua própria CFC). Porém, o conjunto \(\{c,d\}\) forma uma fonte no grafo de condensação e, portanto, um conjunto minimal. Não poderíamos escolher apenas \(\{c\}\) ou apenas \(\{d\}\) isoladamente, pois esses subconjuntos já possuem arcos justos entrando.

Nesse exemplo da Figura~\ref{fig:frank-iter1-result}, os arcos justos não formam uma \(r\)-arborescência, pois nem todos os vértices são alcançáveis a partir de \(r\) pelos arcos justos e o conjunto \(\{c,d\}\) forma um ciclo com dois arcos justos entre \(c\) e \(d\). Temos então as fontes \(\{r,a\}\), \(\{b\}\), \(\{e\}\) e o conjunto \(\{c,d\}\). Como não existem arcos justos entrando em \(\{c,d\}\), esse conjunto é um subconjunto minimal.

\begin{figure}[H]
	\centering
	\begin{tikzpicture}[>=Stealth, scale=1.1]
		\tikzset{
			vtx/.style={circle, draw,fill=blue!8, thick, inner sep=1.2pt, minimum size=7mm},
			tight/.style={->, very thick, draw=blue!70},
			loose/.style={->, semithick, draw=black!35},
			costB/.style={font=\small, fill=white, inner sep=1.5pt, text=blue!70},
			costG/.style={font=\small, fill=white, inner sep=1.5pt, text=black!50}
		}

		\node[vtx] (r) at (0,0) {$r$};
		\node[vtx] (a) at (3,2) {$a$};
		\node[vtx] (b) at (3,-2) {$b$};
		\node[vtx] (c) at (6,2) {$c$};
		\node[vtx] (d) at (6,0) {$d$};
		\node[vtx] (e) at (6,-2) {$e$};

		% arcos justos
		\draw[tight] (r) -- node[costB, above left] {0} (a);
		\draw[tight] (r) -- node[costB, below left] {0} (b);
		\draw[loose] (a) -- node[costG, above] {4} (c);
		\draw[tight] (c) to[bend left=15] node[costB, right] {0} (d);
		\draw[tight] (d) to[bend left=15] node[costB, left] {0} (c);
		\draw[tight] (b) -- node[costB, below] {0} (e);

		% arcos não justos (mais tênues)
		\draw[loose, opacity=0.3] (r) .. controls (2,3.5) and (5,3.5) .. node[costG, above, opacity=0.5] {6} (c);
		\draw[loose, opacity=0.3] (a) -- node[costG, right, opacity=0.5] {3} (d);
		\draw[loose, opacity=0.3] (b) to[bend right=15] node[costG, left, opacity=0.5] {3} (a);
		\draw[loose, opacity=0.3] (d) -- node[costG, right, opacity=0.5] {1} (e);
		\draw[loose, opacity=0.3] (c) .. controls (7.5,2.5) and (7.5,-2.5) .. node[costG, right, opacity=0.5] {2} (e);

		% Destacar as SCCs
		% SCC da raiz + alcançáveis por arcos justos
		\draw[green!60, ultra thick, dashed, rounded corners] (-0.6,-0.6) rectangle (3.6,2.6);
		\node[green!70!black, font=\small\bfseries, above] at (1.5,2.9) {$\{r,a\}$};

		\draw[green!60, ultra thick, dashed, rounded corners] (2.4,-2.6) rectangle (3.6,-1.4);
		\node[green!70!black, font=\small\bfseries, below] at (3,-2.9) {$\{b\}$};

		\draw[green!60, ultra thick, dashed, rounded corners] (5.4,-2.6) rectangle (6.6,-1.4);
		\node[green!70!black, font=\small\bfseries, below] at (6,-2.9) {$\{e\}$};

		% SCC do ciclo c-d - forma componente não-trivial (ciclo)
		\draw[orange!70, ultra thick, dashed, rounded corners] (5.3,2.6) rectangle (6.7,-0.6);
		\node[orange!70, font=\small\bfseries, right] at (6.9,1.2) {$\{c,d\}$};
		\node[orange!70, font=\small, right] at (6.9,0.6) {\textbf{minimal}};
		\node[orange!70, font=\scriptsize, right] at (6.9,0.0) {(ciclo justo)};

		% Seta indicando o ciclo
		\draw[->, orange!70, ultra thick, bend left=45] (6.3,2.3) to (6.3,0.3);
		\draw[->, orange!70, ultra thick, bend left=45] (5.7,0.3) to (5.7,2.3);
	\end{tikzpicture}
	\caption{Identificação de componentes fortemente conexas nos arcos justos após a primeira
		iteração. As componentes triviais \(\{r,a\}\), \(\{b\}\) e \(\{e\}\) estão em verde.
		A componente não-trivial \(\{c,d\}\) (em laranja) forma um ciclo justo com os arcos
		\((c,d)\) e \((d,c)\), e é identificada como \textbf{minimal} para a próxima iteração.
		Os arcos justos internos ao ciclo estão destacados, indicando que \(\{c,d\}\) deve
		ser tratado como uma unidade no processo de contração.}
	\label{fig:frank-scc-minimal}
\end{figure}

O algoritmo então procede escolhendo um próximo subconjunto minimal (neste caso, \(\{c,d\}\)) e repetindo o processo de redução de custos para esse conjunto. Calculamos \(\delta(\{c,d\})\) como o menor custo entre os arcos que entram em \(c\) ou \(d\) vindos de fora do conjunto \(\{c,d\}\). No exemplo, os arcos que entram em \(\{c,d\}\) são \((r,c)\) com custo 6, \((a,c)\) com custo 4 e \((a,d)\) com custo 3. Portanto, \(\delta(\{c,d\}) = \min\{6, 4, 3\} = 3\). Subtraímos esse valor dos arcos que entram em \(c\) e \(d\), tornando \((a,d)\) um arco justo.

\begin{figure}[H]
	\centering
	\begin{tikzpicture}[>=Stealth, scale=0.95]
		\tikzset{
			vtx/.style={circle, draw,fill=blue!8, thick, inner sep=1.2pt, minimum size=7mm},
			vtxH/.style={circle, draw=orange!70, fill=orange!15, thick, inner sep=1.2pt, minimum size=7mm},
			tight/.style={->, very thick, draw=blue!70},
			loose/.style={->, semithick, draw=black!35},
			arcH/.style={->, ultra thick, draw=orange!70},
			costB/.style={font=\small, fill=white, inner sep=1.5pt, text=blue!70},
			costG/.style={font=\small, fill=white, inner sep=1.5pt, text=black!50},
			costO/.style={font=\small, fill=white, inner sep=1.5pt, text=orange!70, font=\small\bfseries}
		}

		% Antes da redução de {c,d}
		\begin{scope}
			\node[font=\bfseries, above] at (3, 3.8) {Antes: redução de $\{c,d\}$};

			\node[vtx] (r1) at (0,0) {$r$};
			\node[vtx] (a1) at (3,2) {$a$};
			\node[vtx] (b1) at (3,-2) {$b$};
			\node[vtxH] (c1) at (6,2) {$c$};
			\node[vtxH] (d1) at (6,0) {$d$};
			\node[vtx] (e1) at (6,-2) {$e$};

			% Arcos justos já existentes (azul)
			\draw[tight] (r1) -- node[costB, above left] {0} (a1);
			\draw[tight] (r1) -- node[costB, below left] {0} (b1);

			\draw[tight] (b1) -- node[costB, below] {0} (e1);
			\draw[tight] (c1) to[bend left=15] node[costB, right] {0} (d1);
			\draw[tight] (d1) to[bend left=15] node[costB, left] {0} (c1);

			% Arcos entrando em {c,d} - destacados em laranja
			\draw[arcH] (r1) .. controls (1,3.5) and (5,3.5) .. node[costO, above] {6} (c1);
			\draw[arcH] (a1) -- node[costO, right] {3} (d1);
			\draw[arcH] (a1) -- node[costO, above] {4} (c1);

			% Outros arcos não justos
			\draw[loose] (b1) to[bend right=15] node[costG, left] {3} (a1);
			\draw[loose] (d1) -- node[costG, right] {1} (e1);
			\draw[loose] (c1) .. controls (7.5,2.5) and (7.5,-2.5) .. node[costG, right] {2} (e1);


			% Destaque do conjunto {c,d}
			\draw[orange!70, ultra thick, dashed, rounded corners] (5.3,2.6) rectangle (6.7,-0.6);
			\node[orange!70, font=\small] at (3, -3.2) {$\delta(\{c,d\}) = \min\{6, 3\} = 3$};
		\end{scope}

		% Depois da redução de {c,d}
		\begin{scope}[xshift=9.5cm]
			\node[font=\bfseries, above] at (3, 3.8) {Após redução de $\delta(\{c,d\})$};

			\node[vtx] (r2) at (0,0) {$r$};
			\node[vtx] (a2) at (3,2) {$a$};
			\node[vtx] (b2) at (3,-2) {$b$};
			\node[vtxH] (c2) at (6,2) {$c$};
			\node[vtxH] (d2) at (6,0) {$d$};
			\node[vtx] (e2) at (6,-2) {$e$};

			% Arcos justos já existentes (azul)
			\draw[tight] (r2) -- node[costB, above left] {0} (a2);
			\draw[tight] (r2) -- node[costB, below left] {0} (b2);
			\draw[tight] (b2) -- node[costB, below] {0} (e2);
			\draw[tight] (c2) to[bend left=15] node[costB, right] {0} (d2);
			\draw[tight] (d2) to[bend left=15] node[costB, left] {0} (c2);

			% Arco (a,d) torna-se justo (novo)
			\draw[tight] (a2) -- node[costB, right] {0} (d2);

			% Arco (r,c) reduzido mas não justo
			\draw[arcH] (r2) .. controls (1,3.5) and (5,3.5) .. node[costO, above] {3} (c2);
			\draw[arcH] (a2) -- node[costO, above] {1} (c2);

			% Outros arcos não justos
			\draw[loose] (b2) to[bend right=15] node[costG, left] {3} (a2);
			\draw[loose] (d2) -- node[costG, right] {1} (e2);
			\draw[loose] (c2) .. controls (7.5,2.5) and (7.5,-2.5) .. node[costG, right] {2} (e2);

			% Destaque do conjunto {c,d}
			\draw[orange!70, ultra thick, dashed, rounded corners] (5.3,2.6) rectangle (6.7,-0.6);
			\node[blue!70, font=\small] at (3, -3.2) {$(a,d)$ torna-se \textbf{justo}};
		\end{scope}
	\end{tikzpicture}
	\caption{Redução de custos para o subconjunto minimal \(\{c,d\}\). À esquerda, antes da
		redução: os arcos entrando em \(\{c,d\}\) vindos de fora são \((r,c)\) com custo 6, \((a,d)\) com custo 3 e \((a,c)\) com custo 4, destacados em laranja. Calculamos \(\delta(\{c,d\}) = 3\)
		e subtraímos esse valor. À direita, após a redução: \((a,d)\) torna-se justo (custo 0), \((r,c)\) tem custo reduzido para 3 e \((a,c)\) tem custo reduzido para 1. O conjunto \(\{c,d\}\) está destacado em laranja para enfatizar que é tratado como uma unidade.}
	\label{fig:frank-reducao-cd}
\end{figure}

Agora, não existem mais subconjuntos minimais sem arcos justos entrando neles, porém os arcos justos não formam uma \(r\)-arborescência, pois existe um ciclo justo entre \(c\) e \(d\).

Nesse ponto, o algoritmo procede para a fase de contração, onde o ciclo justo formado pelos arcos \((c,d)\) e \((d,c)\) é contraído em um único vértice. Podemos estender essa ideia de contração de ciclos para abranger a contração de qualquer componente fortemente conexa (CFC) formada por arcos justos.

O algoritmo pode utilizar CFCs para identificar eficientemente os conjuntos minimais. Quando construímos o grafo de condensação das CFCs, cada vértice do grafo de condensação representa uma CFC do grafo original formado pelos arcos justos. Vale destacar que um arco no grafo de condensação conecta duas CFCs se existe um arco justo no grafo original indo de um vértice da primeira CFC para um vértice da segunda e o grafo de condensação é sempre acíclico (DAG).

Uma fonte no grafo de condensação corresponde exatamente aos conjuntos minimais que buscamos.

No exemplo, a CFC \(\{c,d\}\) é uma fonte que é contraída em um novo vértice \(x_C\). Todos os arcos que entravam em \(c\) ou \(d\) agora entram em \(x_C\), e todos os arcos que saíam de \(c\) ou \(d\) agora saem de \(x_C\). Os custos dos arcos são mantidos conforme estavam antes da contração.

A Figura~\ref{fig:frank-contracao-ciclo} ilustra essa contração.

\begin{figure}[H]
	\centering
	\begin{tikzpicture}[>=Stealth, scale=0.95]
		\tikzset{
			vtx/.style={circle, draw,fill=blue!8, thick, inner sep=1.2pt, minimum size=7mm},
			vtxH/.style={circle, draw=red!70, fill=red!10, thick, inner sep=1.2pt, minimum size=7mm},
			vtxC/.style={circle, draw=red!70, fill=red!10, thick, inner sep=1.2pt, minimum size=9mm},
			tight/.style={->, very thick, draw=blue!70},
			cycle/.style={->, ultra thick, draw=red!70},
			loose/.style={->, semithick, draw=black!35},
			costB/.style={font=\small, fill=white, inner sep=1.5pt, text=blue!70},
			costR/.style={font=\small, fill=white, inner sep=1.5pt, text=red!70},
			costG/.style={font=\small, fill=white, inner sep=1.5pt, text=black!50}
		}

		% Antes da contração
		\begin{scope}
			\node[font=\bfseries, above] at (3, 3.8) {Antes: dígrafo com ciclo justo};

			\node[vtx] (r1) at (0,0) {$r$};
			\node[vtx] (a1) at (3,2) {$a$};
			\node[vtx] (b1) at (3,-2) {$b$};
			\node[vtxH] (c1) at (6,2) {$c$};
			\node[vtxH] (d1) at (6,0) {$d$};
			\node[vtx] (e1) at (6,-2) {$e$};

			% Arcos justos normais
			\draw[tight] (r1) -- node[costB, above left] {0} (a1);
			\draw[tight] (r1) -- node[costB, below left] {0} (b1);
			\draw[tight] (a1) -- node[costB, right] {0} (d1);
			\draw[tight] (b1) -- node[costB, below] {0} (e1);

			% Ciclo justo destacado em vermelho
			\draw[cycle] (c1) to[bend left=15] node[costR, right] {0} (d1);
			\draw[cycle] (d1) to[bend left=15] node[costR, left] {0} (c1);

			% Arcos não justos
			\draw[loose] (r1) .. controls (1,3.5) and (5,3.5) .. node[costG, above] {3} (c1);
			\draw[loose] (a1) -- node[costG, above] {1} (c1);
			\draw[loose] (b1) to[bend right=15] node[costG, left] {3} (a1);
			\draw[loose] (d1) -- node[costG, right] {1} (e1);
			\draw[loose] (c1) .. controls (7.5,2.5) and (7.5,-2.5) .. node[costG, right] {2} (e1);

			% Destaque do ciclo
			\draw[red!70, ultra thick, dashed, rounded corners] (5.3,2.6) rectangle (6.7,-0.6);
			\node[red!70, font=\small\bfseries, below] at (6,-0.9) {Ciclo};
		\end{scope}

		% Seta de transformação
		\node[font=\Large\bfseries] at (9.5, 0) {$\Rightarrow$};

		% Depois da contração
		\begin{scope}[xshift=11cm]
			\node[font=\bfseries, above] at (3, 3.8) {Após contração: $\{c,d\} \to x_C$};

			\node[vtx] (r2) at (0,0) {$r$};
			\node[vtx] (a2) at (3,1.5) {$a$};
			\node[vtx] (b2) at (3,-1.5) {$b$};
			\node[vtxC] (xc2) at (6,0.75) {$x_C$};
			\node[vtx] (e2) at (6,-1.5) {$e$};

			% Arcos justos
			\draw[tight] (r2) -- node[costB, above left] {0} (a2);
			\draw[tight] (r2) -- node[costB, below left] {0} (b2);
			\draw[tight] (a2) -- node[costB, right] {0} (xc2);
			\draw[tight] (b2) -- node[costB, below] {0} (e2);

			% Arcos não justos
			\draw[loose] (r2) .. controls (1,3) and (5,3) .. node[costG, above] {3} (xc2);
			\draw[loose] (b2) to[bend right=12] node[costG, left] {3} (a2);
			\draw[loose] (xc2) -- node[costG, right] {1} (e2);

			% Anotação
			\node[red!70, font=\small, align=center] at (3,-3.2) {Supervértice $x_C$\\representa $\{c,d\}$};
		\end{scope}
	\end{tikzpicture}
	\caption{Contração do ciclo justo \(\{c,d\}\). À esquerda, o dígrafo após as reduções de
		custo mostra o ciclo justo formado pelos arcos \((c,d)\) e \((d,c)\) (em vermelho).
		À direita, o dígrafo contraído onde os vértices \(c\) e \(d\) são substituídos pelo
		supervértice \(x_C\). Os arcos que entravam ou saíam do ciclo são redirecionados para
		\(x_C\). Note que os arcos justos agora formam uma \(r\)-arborescência no dígrafo contraído.}
	\label{fig:frank-contracao-ciclo}
\end{figure}

O algoritmo termina quando existe exatamente uma fonte no grafo de condensação das SCCs formadas pelos arcos justos.

Quando essa condição é satisfeita, o grafo \((V, A_0)\) formado pelos arcos justos contém uma \(r\)-arborescência, pois todo vértice não-raiz é alcançável a partir de \(r\) através de arcos justos (consequência de haver apenas uma fonte).

Assim termina a fase 1 do algoritmo de Frank que pode devolver uma lista de arcos justos \(A_0\) e custos reduzidos \(c'(u,v)\) para todos os arcos \((u,v) \in A\) onde uma seleção de \(n-1\) arcos de \(A_0\) formam uma arborescência possivelmente com uma sujeira adicional, no caso do Digrafo do exemplo do acima, \(A_0\) inclui os arcos \((c,d)\) e \((d,c)\) formando um ciclo justo.

Quando \(A_0\) contém um ciclo, a operação de contração (ilustrada na Figura~\ref{fig:frank-contracao-ciclo}) é necessária para eliminar essa ambiguidade. Ao contrair o ciclo em um supervértice e resolver recursivamente, o algoritmo efetivamente escolhe quais arcos do ciclo fazer parte da solução final. Durante a expansão, apenas \(|C|-1\) arcos do ciclo contraído \(C\) são incluídos na arborescência (onde \(|C|\) é o número de vértices no ciclo), descartando exatamente um arco --- aquele que entra no vértice por onde a arborescência alcança o ciclo.

Outras sujeiras podem ocorrer quando múltiplos arcos justos entram em um mesmo vértice, como no caso de múltiplas fontes sendo processadas em ordens diferentes. A Figura~\ref{fig:frank-multiplos-arcos-justos} ilustra esse fenômeno no exemplo anterior: após processar os conjuntos \(\{a\}\), \(\{b\}\) e \(\{e\}\), tanto o arco \((r,a)\) quanto o arco \((b,a)\) podem se tornar justos simultaneamente se os custos forem adequados. Nesse caso, \(A_0\) conteria ambos os arcos entrando em \(a\), mas a arborescência final incluirá apenas um deles --- o algoritmo escolhe o arco cujo vértice origem já está conectado à raiz na arborescência parcial.

\begin{figure}[H]
	\centering
	\begin{tikzpicture}[>=Stealth, scale=1.0]
		\tikzset{
			vtx/.style={circle, draw,fill=blue!8, thick, inner sep=1.2pt, minimum size=7mm},
			vtxH/.style={circle, draw=orange!70, fill=orange!15, thick, inner sep=1.2pt, minimum size=8mm},
			tight/.style={->, very thick, draw=blue!70},
			loose/.style={->, semithick, draw=black!35},
			arcDashed/.style={->, very thick, draw=blue!70, dashed},
			costB/.style={font=\small, fill=white, inner sep=1.5pt, text=blue!70},
			costG/.style={font=\small, fill=white, inner sep=1.5pt, text=black!50}
		}

		% À esquerda: ambos os arcos são justos
		\begin{scope}
			\node[font=\bfseries, above] at (3, 3.2) {Conjunto $A_0$ após Fase~1};

			\node[vtx] (r1) at (0,0) {$r$};
			\node[vtxH] (a1) at (3,2) {$a$};
			\node[vtx] (b1) at (3,-2) {$b$};
			\node[vtx] (c1) at (6,1) {$c$};
			\node[vtx] (d1) at (6,-1) {$d$};

			% Dois arcos justos entrando em 'a' - destacados
			\draw[tight] (r1) -- node[costB, above left] {0} (a1);
			\draw[tight] (b1) to[bend right=15] node[costB, left] {0} (a1);

			% Outros arcos justos
			\draw[tight] (r1) -- node[costB, below left] {0} (b1);
			\draw[tight] (a1) to[bend left=10] node[costB, above] {0} (c1);
			\draw[tight] (c1) to[bend left=10] node[costB, below] {0} (d1);

			% Arcos não-justos (exemplos)
			\draw[loose] (d1) -- node[costG, right] {2} (a1);
			\draw[loose] (b1) to[bend left=15] node[costG, below] {1} (d1);

			% Anotação
			\node[orange!70, font=\small, align=center] at (3, -3.5) {Dois arcos justos\\entram em $a$: $(r,a)$ e $(b,a)$};
		\end{scope}

		% À direita: apenas um arco é escolhido
		\begin{scope}[xshift=9.5cm]
			\node[font=\bfseries, above] at (3, 3.2) {Arborescência final (Fase~2)};

			\node[vtx] (r2) at (0,0) {$r$};
			\node[vtx] (a2) at (3,2) {$a$};
			\node[vtx] (b2) at (3,-2) {$b$};
			\node[vtx] (c2) at (6,1) {$c$};
			\node[vtx] (d2) at (6,-1) {$d$};

			% Arcos na arborescência (sólidos)
			\draw[tight] (r2) -- node[costB, above left] {0} (a2);
			\draw[tight] (r2) -- node[costB, below left] {0} (b2);
			\draw[tight] (a2) to[bend left=10] node[costB, above] {0} (c2);
			\draw[tight] (c2) to[bend left=10] node[costB, below] {0} (d2);

			% Arco descartado (tracejado)
			\draw[arcDashed] (b2) to[bend right=15] node[costB, left] {0} (a2);

			% Anotação
			\node[blue!70, font=\small, align=center] at (3, -3.5) {Arco $(b,a)$ descartado\\$(a)$ já recebe $(r,a)$};
		\end{scope}
	\end{tikzpicture}
	\caption{Exemplo de múltiplos arcos justos entrando em um mesmo vértice. À esquerda, após
		a Fase~1, o conjunto \(A_0\) contém tanto \((r,a)\) quanto \((b,a)\) como arcos justos
		(ambos destacados em azul sólido). À direita, durante a construção incremental da
		arborescência na Fase~2, apenas um arco é escolhido: \((r,a)\) é incluído porque \(r\)
		já está na arborescência parcial, enquanto \((b,a)\) (mostrado tracejado) é descartado,
		pois \(a\) já possui um arco de entrada. A Fase~2 garante que cada vértice não-raiz
		receba exatamente um arco entrando na arborescência final.}
	\label{fig:frank-multiplos-arcos-justos}
\end{figure}

Essa ``sujeira'' é uma característica do algoritmo. Durante a Fase~1, todos os arcos em \(A_0\) são garantidamente parte de \emph{alguma} arborescência ótima (não necessariamente a mesma), mas apenas um subconjunto de \(A_0\) formará a Ou seja, a Fase~1 do algoritmo de Frank não constrói diretamente a arborescência, mas sim um \emph{certificado de otimalidade} através dos arcos justos e potenciais duais. A Fase~2 então utiliza esse certificado para extrair uma arborescência ótima específica.

\paragraph*{Fase 2}

A fase 2 envolve a expansão do supervértice \(x_C\) de volta para o ciclo \(\{c,d\}\) e a reconstrução da \(r\)-arborescência ótima no dígrafo original. Isso é feito selecionando o arco que entra em \(x_C\) na arborescência do dígrafo contraído e substituindo-o pelo arco correspondente que entra em \(c\) ou \(d\) no dígrafo original, além dos arcos justos internos ao ciclo, exceto o arco que entra no vértice escolhido.

A Figura~\ref{fig:frank-fase2-expansao} ilustra esse processo no exemplo. No dígrafo contraído, a arborescência ótima inclui o arco \((a, x_C)\) entrando no supervértice \(x_C\). Na expansão, esse arco corresponde a \((a,d)\) no dígrafo original. A arborescência final então inclui \((a,d)\) e todos os arcos justos do ciclo exceto o arco que entra em \(d\), ou seja, exclui \((c,d)\) e mantém \((d,c)\). Assim, o vértice \(c\) é alcançado através de \(d\).

\begin{figure}[H]
	\centering
	\begin{tikzpicture}[>=Stealth, scale=1.1]
		\tikzset{
			vtx/.style={circle, draw,fill=blue!8, thick, inner sep=1.2pt, minimum size=7mm},
			vtxSuper/.style={circle, draw=red!70, fill=red!15, thick, inner sep=1.2pt, minimum size=9mm},
			arb/.style={->, ultra thick, draw=green!60!black},
			tight/.style={->, very thick, draw=blue!70},
			tightDashed/.style={->, very thick, draw=blue!70, dashed},
			loose/.style={->, semithick, draw=black!25},
			costB/.style={font=\small, fill=white, inner sep=1.5pt, text=blue!70},
			costG/.style={font=\footnotesize, fill=white, inner sep=1.5pt, text=black!40}
		}

		% Painel 1: Arborescência no dígrafo contraído (topo)
		\begin{scope}
			\node[font=\bfseries, above] at (3, 3.8) {Dígrafo contraído com arborescência};

			\node[vtx] (r1) at (0,0) {$r$};
			\node[vtx] (a1) at (3,2) {$a$};
			\node[vtx] (b1) at (3,-2) {$b$};
			\node[vtxSuper] (xc1) at (6,0.5) {$x_C$};
			\node[vtx] (e1) at (6,-2) {$e$};

			% Arborescência (verde grosso)
			\draw[arb] (r1) -- node[costB, above left] {0} (a1);
			\draw[arb] (r1) -- node[costB, below left] {0} (b1);
			\draw[arb] (a1) -- node[costB, above] {0} (xc1);
			\draw[arb] (b1) -- node[costB, below] {0} (e1);

			% Arcos não usados (finos cinza)
			\draw[loose] (r1) .. controls (1.5,3.5) and (5,3.5) .. node[costG, above] {3} (xc1);
			\draw[loose] (xc1) -- node[costG, right] {2} (e1);

			% Anotação
			\node[red!70, font=\small, align=center] at (6, -3.3) {Supervértice $x_C = \{c,d\}$};
			\node[green!60!black, font=\small, align=center] at (3, -4) {(arcos da arborescência em verde)};
		\end{scope}

		% Seta de expansão (vertical)
		\node[font=\Large\bfseries] at (3, -4.8) {$\Downarrow$};
		\node[font=\small, align=center] at (3, -5.5) {Expansão};

		% Painel 2: Expansão no dígrafo original (abaixo)
		\begin{scope}[yshift=-10cm]
			\node[vtx] (r2) at (0,0) {$r$};
			\node[vtx] (a2) at (3,2) {$a$};
			\node[vtx] (b2) at (3,-2) {$b$};
			\node[vtx] (c2) at (6,1.5) {$c$};
			\node[vtx] (d2) at (6,0) {$d$};
			\node[vtx] (e2) at (6,-2) {$e$};

			% Arborescência final (verde grosso)
			\draw[arb] (r2) -- node[costB, above left] {0} (a2);
			\draw[arb] (r2) -- node[costB, below left] {0} (b2);
			\draw[arb] (a2) -- node[costB, above right] {0} (d2);
			\draw[arb] (d2) to[bend left=15] node[costB, left] {0} (c2);
			\draw[arb] (b2) -- node[costB, below] {0} (e2);

			% Arco justo descartado (tracejado)
			\draw[tightDashed] (c2) to[bend left=15] node[costB, right] {0} (d2);

			% Arcos não usados (finos cinza)
			\draw[loose] (r2) .. controls (1.5,3.5) and (5,3.5) .. node[costG, above] {3} (c2);
			\draw[loose] (a2) to[bend left=10] node[costG, above] {1} (c2);
			\draw[loose] (d2) -- node[costG, right] {2} (e2);

			% Anotação
			\node[green!60!black, font=\small, align=center] at (3, -3.3) {Arborescência final: $\{(r,a), (r,b), (a,d), (d,c), (b,e)\}$};
			\node[blue!70, font=\footnotesize, align=center] at (7.5, 0.75) {Arco $(c,d)$\\descartado};
		\end{scope}
	\end{tikzpicture}
	\caption{Fase 2: Expansão do supervértice e construção da arborescência final. No topo,
		a arborescência ótima no dígrafo contraído (arcos verdes grossos) inclui o arco \((a, x_C)\)
		entrando no supervértice \(x_C = \{c,d\}\). Abaixo, após a expansão no dígrafo original,
		o arco \((a, x_C)\) é substituído por \((a,d)\), que corresponde ao arco justo que entra no
		ciclo. O ciclo é "aberto" incluindo apenas \(|C|-1 = 1\) arco interno: \((d,c)\) é incluído
		na arborescência (verde), enquanto \((c,d)\) é descartado (azul tracejado), pois \(d\) já
		recebe o arco \((a,d)\). O resultado é uma \(r\)-arborescência com exatamente \(n-1 = 5\) arcos,
		todos de custo reduzido zero, portanto ótima.}
	\label{fig:frank-fase2-expansao}
\end{figure}

Mesmo quando \(A_0\) não contém ciclos, a Fase~2 do algoritmo constrói a arborescência \emph{incrementalmente}, adicionando arcos de \(A_0\) um por vez, garantindo que cada vértice não-raiz receba exatamente um arco de entrada. O algoritmo sempre escolhe um arco \((u,v) \in A_0\) tal que \(u\) já está na arborescência parcial e \(v\) ainda não está. Esse processo naturalmente seleciona um subconjunto de \(A_0\) sem ambiguidades, descartando arcos "extras".


\section{Descrição do algoritmo}
\label{sec:descricao-algoritmo}

Apresentamos agora uma descrição formal do algoritmo de András Frank.

O algoritmo opera em duas fases. A Fase~1 reduz progressivamente os custos dos arcos,
criando arcos justos (de custo zero) através da identificação de subconjuntos minimais.
A Fase~2 constrói a arborescência a partir dos arcos justos, usando contração e expansão
quando necessário.

A diferença fundamental em relação ao Chu--Liu--Edmonds está na Fase~1, no algoritmo de Chu--Liu/Edmonds para cada vértice \(v\), subtrai o menor custo entrando em \(v\) e processa vértice a vértice, uma vez. Já em Frank, a cada iteração, identifica componentes fortemente conexas no grafo
de arcos justos. Para cada componente sem arcos justos entrando (subconjunto minimal \(X\)),subtrai \(\delta(X)\) de todos os arcos entrando em \(X\). Repete até todos os vértices terem arcos justos entrando.

\begin{algobox}{András Frank}{andras-frank}
	Entrada: dígrafo \(D=(V,A)\), custos \(c:A\to\mathbb{R}_{\ge 0}\), raiz \(r\).\footnote{Se algum \(v\neq r\) não possui arco de entrada, não existe r-arborescência.}

	\textbf{Fase 1: Redução de custos e construção de \(A_0\)}
	\begin{enumerate}\setlength{\itemsep}{2pt}
		\item \textbf{Inicialização:} defina \(A_0 := \emptyset\) (conjunto de arcos justos).
		\item \textbf{Iteração:} enquanto existir subconjunto minimal \(X \subseteq V \setminus \{r\}\):
		      \begin{itemize}\setlength{\itemsep}{2pt}
			      \item Calcule as componentes fortemente conexas de \((V, A_0)\).
			      \item Para cada componente \(X\) que não contém \(r\) e não possui arcos de \(A_0\) entrando:
			            \begin{itemize}
				            \item Calcule \(\delta(X) := \min\{c(u,v) : u \notin X, v \in X\}\).
				            \item Para todo arco \((u,v)\) com \(u \notin X\) e \(v \in X\), atualize \(c(u,v) := c(u,v) - \delta(X)\).
				            \item Adicione a \(A_0\) todos os arcos \((u,v)\) com \(u \notin X, v \in X\) que atingiram custo zero.
			            \end{itemize}
		      \end{itemize}
		      Ao final, todo vértice \(v \neq r\) possui ao menos um arco justo entrando.
	\end{enumerate}

	\textbf{Fase 2: Construção da arborescência}
	\begin{enumerate}\setlength{\itemsep}{2pt}\setcounter{enumi}{2}
		\item Se \((V,A_0)\) forma uma r-arborescência, devolva \(A_0\). Por construção, todos os arcos têm custo reduzido zero e os demais arcos têm custo não negativo, garantindo otimalidade.
		\item Caso contrário, identifique um ciclo dirigido \(C\) em \(A_0\) (com \(r\notin C\)). \textbf{Contração:} contraia \(C\) em um supervértice \(x_C\) e ajuste os custos dos arcos incidentes, descartando laços em \(x_C\) e permitindo paralelos. Denote o dígrafo contraído por \(D'=(V',A')\).
		\item \textbf{Recursão:} compute uma r-arborescência ótima \(T'\) de \(D'\) com os custos ajustados.
		\item \textbf{Expansão:} seja \((u,x_C)\in T'\) o único arco que entra em \(x_C\). No dígrafo original, ele corresponde a \((u,w)\) com \(w\in C\). Forme
		      \[
			      T := \bigl(T'\setminus\{\text{arcos incidentes a } x_C\}\bigr)\ \cup\ \{(u,w)\}\ \cup\ \bigl((A_0\cap A(C))\setminus\{a_w\}\bigr),
		      \]
		      onde \(a_w\) é o arco de \(C\) que entra em \(w\). Então \(T\) é uma r-arborescência ótima de \(D\).
	\end{enumerate}
\end{algobox}

\subsection{Corretude}

A corretude do algoritmo baseia-se em três ideias principais:

\begin{enumerate}\setlength{\itemsep}{2pt}
	\item \emph{Equivalência com potenciais duais:} A operação de subtrair \(\delta(X)\)
	      dos arcos entrando em \(X\) equivale a aumentar um potencial dual \(y(v)\) em \(\delta(X)\)
	      para cada \(v \in X\). Trabalhar com custos reduzidos \(c(u,v)\) é equivalente
	      a trabalhar com \(c_{\text{original}}(u,v) - y(v)\).

	\item \emph{Condições de otimalidade:} Uma \(r\)-arborescência \(T\) é ótima se, e somente se:
	      \begin{itemize}\setlength{\itemsep}{2pt}
		      \item Todos os arcos de \(T\) são justos (custo reduzido zero).
		      \item Todos os arcos do dígrafo têm custo reduzido não negativo.
	      \end{itemize}
	      Isso porque, para qualquer \(r\)-arborescência \(F\),
	      \[
		      c(F) = \sum_{v \neq r} c_y(a_v) + \sum_{v \neq r} y(v),
	      \]
	      onde \(a_v\) é o arco de \(F\) entrando em \(v\). Como \(\sum_{v \neq r} y(v)\)
	      é constante, minimizar \(c(F)\) equivale a minimizar \(\sum_{v \neq r} c_y(a_v)\).

	\item \emph{Identificação de subconjuntos minimais:} O algoritmo usa componentes fortemente
	      conexas para identificar quais conjuntos ainda precisam de arcos justos entrando.
	      Inicialmente cada vértice é sua própria componente. Após criar arcos justos,
	      se formarem ciclos, as componentes agrupam vértices e o processo continua
	      sobre esses conjuntos maiores.
\end{enumerate}

\textbf{Conclusão:} A operação é a mesma do Chu--Liu--Edmonds (subtrair o menor custo
entrando em cada conjunto), mas organizada diferentemente: Chu--Liu opera vértice a vértice;
Frank opera sobre componentes fortemente conexas.

\subsection{Complexidade}

A implementação, baseada em componentes fortemente conexas, detecta em cada iteração, quais conjuntos \(X\) necessitam elevação de potenciais. Calcular componentes fortemente conexas custa \(O(n+m)\) usando algoritmos como Tarjan ou Kosaraju. Para cada componente (exceto a raiz), eleva-se o potencial calculando \(\Delta(X)\) em \(O(m)\), atualizando os custos reduzidos.

No pior caso, cada iteração reduz o número de componentes em pelo menos uma unidade, resultando em \(O(n)\) iterações. Cada iteração processa todos os arcos para atualizar custos reduzidos e recalcular componentes, resultando em \(O(nm)\) no total para a Fase~1. A Fase~2 constrói a arborescência percorrendo \(A_0\) uma vez, custando \(O(n)\).

O uso de memória é \(O(n+m)\), incluindo as estruturas para armazenar o dígrafo, potenciais e componentes. A implementação a seguir adota a versão \(O(nm)\) por simplicidade e está disponível no repositório do projeto (\url{https://github.com/lorenypsum/GraphVisualizer}).


\section{Implementação em Python}
\label{sec:implementacao}

Esta seção descreve a implementação do algoritmo de András Frank em Python, estruturada para refletir com precisão as duas fases formais discutidas anteriormente. A Fase~1 realiza a elevação de potenciais e identifica os arcos justos, enquanto a Fase~2 constrói a arborescência de custo mínimo a partir desses arcos. Utilizamos a biblioteca NetworkX para manipulação de digrafos, aproveitando suas funcionalidades para representar grafos, calcular componentes fortemente conexas e gerenciar atributos de arcos.

A entrada consiste em um dígrafo orientado \(D = (V, A)\), com custos dos arcos registrados no atributo \texttt{"w"}, e uma raiz \(r \in V\). As hipóteses adotadas são: (i) o dígrafo é conexo a partir de \(r\), isto é, todo vértice \(v \neq r\) é alcançável a partir da raiz; (ii) para todo subconjunto \(X \subseteq V \setminus \{r\}\), existe ao menos um arco entrando em \(X\); e (iii) todos os custos são não negativos.

A saída é um subdigrafo \(T\) de \(D\) com \(|A_T| = |V| - 1\) arcos, tal que cada vértice \(v \neq r\) possui grau de entrada igual a 1, todos os vértices são alcançáveis a partir de \(r\), e o custo total \(\sum_{a \in A_T} c(a)\) é mínimo.

A estrutura do código é modular: funções auxiliares tratam cada etapa do algoritmo — cálculo de componentes fortemente conexas, elevação de potenciais, construção do subdigrafo \(A_0\) e construção da arborescência final. Todas operam sobre objetos \texttt{nx.DiGraph} e são coordenadas por uma função principal que gerencia o fluxo das duas fases. As subseções seguintes detalham cada função auxiliar, abordando lógica, parâmetros, saídas e complexidade.

\subsection{Identificação de arcos entrando em conjunto \texorpdfstring{\(X\)}{X}}
Começamos escrevendo uma função auxiliar identifica todos os arcos que entram em um conjunto \(X \subseteq V\), isto é, arcos \((u,v)\) tais que \(u \notin X\) e \(v \in X\). Essa operação é fundamental para calcular o mínimo custo de entrada em \(X\) durante a elevação de potenciais.

Recebe como entrada um dígrafo \texttt{D} e um conjunto de vértices \texttt{X}. A implementação cria uma lista vazia \texttt{arcs} (linha 2) e itera sobre todos os arcos do dígrafo com seus dados (linha 3), incluindo o peso. Para cada arco \((u,v,\text{data})\), verifica se \(u \notin X\) e \(v \in X\) (linha 4), adicionando à lista apenas os arcos que cruzam a fronteira de \(X\) (linha 5).

A função devolve uma lista de tuplas \((u, v, \text{data})\) representando os arcos que entram em \(X\), onde \texttt{data} contém o atributo \texttt{"w"} com o peso do arco. A complexidade é \(O(m)\), onde \(m = |A|\), pois examina cada arco uma vez.

\begin{tcolorbox}[
		enhanced, breakable,
		colframe=blue!60!black, colback=blue!2,
		colbacktitle=blue!15, coltitle=black,
		title={Identificação de arcos entrando em conjunto X},
		boxed title style={sharp corners, boxrule=0.6pt},
		sharp corners, boxrule=0.6pt
	]
	\emph{Identifica todos os arcos $(u,v)$ do dígrafo D tais que $u \notin X$ e $v \in X$, devolvendo uma lista com as tuplas $(u, v, data)$ onde data contém o peso do arco.}
	\tcblower
	\begin{lstlisting}[language=Python]
def get_arcs_entering_X(D, X):
    arcs = []
    for u, v, data in D.edges(data=True):
        if u not in X and v in X:
            arcs.append((u, v, data))
    return arcs
\end{lstlisting}
\end{tcolorbox}

A figura a seguir ilustra o funcionamento da função \texttt{get\_arcs\_entering\_X} em um digrafo que vamos denotar por \(D_{32}\). O dígrafo possui uma raiz \(r_0\) conectada aos vértices \(u_1, u_2, u_3\). Os vértices em laranja pertencem ao conjunto \(X = \{v_1, v_2, v_3\}\), e a função identifica apenas os arcos em vermelho, que saem de vértices fora de \(X\) e entram em vértices dentro de \(X\). Arcos da raiz, arcos internos a \(X\), externos a \(X\), ou saindo de \(X\) não são retornados.

\begin{figure}[H]
	\centering
	\begin{tikzpicture}[>=Stealth]
		% estilos
		\tikzset{
			vtx/.style={circle, draw, fill=blue!8, thick, inner sep=1.2pt, minimum size=7mm},
			vtxRoot/.style={circle, draw, fill=red!15, thick, inner sep=1.2pt, minimum size=7mm},
			vtxX/.style={circle, draw=orange!80!black, fill=orange!15, thick, inner sep=1.2pt, minimum size=7mm},
			arc/.style={->, >=Stealth, thick, draw=black!40},
			arcEntering/.style={->, >=Stealth, very thick, draw=red!70!black},
			cost/.style={font=\scriptsize, fill=white, inner sep=1pt}
		}

		% Raiz
		\node[vtxRoot] (r0) at (2, 4) {$r_0$};

		% Vértices fora de X
		\node[vtx] (u1) at (0, 2) {$u_1$};
		\node[vtx] (u2) at (2, 2) {$u_2$};
		\node[vtx] (u3) at (4, 2) {$u_3$};

		% Vértices dentro de X (destacados)
		\node[vtxX] (v1) at (0.5, -0.5) {$v_1$};
		\node[vtxX] (v2) at (2, -0.5) {$v_2$};
		\node[vtxX] (v3) at (3.5, -0.5) {$v_3$};

		% Arcos da raiz (não retornados, pois r0 não está em consideração para X)
		\draw[arc] (r0) -- node[cost, left, pos=0.4] {1} (u1);
		\draw[arc] (r0) -- node[cost, right] {2} (u2);
		\draw[arc] (r0) -- node[cost, right, pos=0.4] {1} (u3);

		% Arcos externos a X (não retornados)
		\draw[arc] (u1) to[bend left=15] node[cost, above] {1} (u2);
		\draw[arc] (u2) to[bend left=15] node[cost, above] {3} (u3);

		% Arcos entrando em X (destacados em vermelho)
		\draw[arcEntering] (u1) -- node[cost, left] {3} (v1);
		\draw[arcEntering] (u2) -- node[cost, right] {2} (v2);
		\draw[arcEntering] (u3) -- node[cost, right] {4} (v3);
		\draw[arcEntering] (u1) to[bend right=20] node[cost, below, pos=0.3] {5} (v2);

		% Arcos internos a X (não retornados)
		\draw[arc] (v1) -- node[cost, above] {1} (v2);
		\draw[arc] (v2) -- node[cost, above] {2} (v3);

		% Arcos saindo de X (não retornados)
		\draw[arc] (v1) to[bend right=30] node[cost, left, pos=0.3] {2} (u1);

		% Região X destacada
		\draw[orange!60!black, thick, dashed, rounded corners=8pt]
		(-0.3, 0.3) rectangle (4.3, -1.3);
		\node[orange!80!black, font=\bfseries] at (5, 0.3) {$X$};
	\end{tikzpicture}
	\caption{Ilustração da função \texttt{get\_arcs\_entering\_X} em \(D_{32}\). A raiz \(r_0\) (em vermelho claro) conecta-se aos vértices \(u_1, u_2, u_3\). Os vértices em \textcolor{orange!80!black}{laranja} pertencem ao conjunto \(X = \{v_1, v_2, v_3\}\). A função identifica apenas os arcos \textcolor{red!70!black}{em vermelho}: aqueles que saem de vértices fora de \(X\) e entram em vértices dentro de \(X\). Arcos da raiz, arcos internos a \(X\), externos a \(X\), ou saindo de \(X\) não são retornados.}
\end{figure}

\subsection{Cálculo do peso mínimo de corte}

Esta função calcula o peso mínimo entre todos os arcos fornecidos, correspondendo ao valor \(\Delta(X)\) necessário para elevar os potenciais dos vértices em \(X\).

Recebe como entrada uma lista \texttt{arcos} de tuplas \((u, v, \text{data})\). A implementação usa a função \texttt{min} com uma compreensão de gerador (linha 2) que extrai o atributo \texttt{"w"} de cada tupla em \texttt{data}.

A função devolve o peso mínimo encontrado entre todos os arcos da lista. A complexidade é \(O(k)\), onde \(k\) é o número de arcos na lista, pois examina cada arco uma vez para encontrar o mínimo.

\begin{tcolorbox}[
		enhanced, breakable,
		colframe=blue!60!black, colback=blue!2,
		colbacktitle=blue!15, coltitle=black,
		title={Cálculo do peso mínimo de corte},
		boxed title style={sharp corners, boxrule=0.6pt},
		sharp corners, boxrule=0.6pt
	]
	\emph{Calcula o peso mínimo entre todos os arcos fornecidos, correspondendo ao valor $\Delta(X)$ usado na elevação de potenciais.}
	\tcblower
	\begin{lstlisting}[language=Python]
def get_minimum_weight_cut(arcs):
    return min(data["w"] for _, _, data in arcs)
\end{lstlisting}
\end{tcolorbox}

A seguir temos uma ilustração do funcionamento da função \texttt{get\_minimum\_weight\_cut} em \(D_{32}\). Considerando os arcos em vermelho que entram em \(X\) (identificados pela função anterior), esta função calcula o peso mínimo entre eles. O arco em verde possui o menor peso (2), correspondendo ao valor \(\Delta(X) = 2\) que será devolvido pela função.

\begin{figure}[H]
	\centering
	\begin{tikzpicture}[>=Stealth]
		% estilos
		\tikzset{
			vtx/.style={circle, draw, fill=blue!8, thick, inner sep=1.2pt, minimum size=7mm},
			vtxRoot/.style={circle, draw, fill=red!15, thick, inner sep=1.2pt, minimum size=7mm},
			vtxX/.style={circle, draw=orange!80!black, fill=orange!15, thick, inner sep=1.2pt, minimum size=7mm},
			arc/.style={->, >=Stealth, thick, draw=black!40},
			arcEntering/.style={->, >=Stealth, very thick, draw=red!70!black},
			arcMin/.style={->, >=Stealth, ultra thick, draw=green!60!black},
			cost/.style={font=\scriptsize, fill=white, inner sep=1pt},
			costMin/.style={font=\scriptsize\bfseries, fill=green!10, inner sep=2pt, draw=green!60!black, rounded corners=1pt}
		}

		% Raiz
		\node[vtxRoot] (r0) at (2, 4) {$r_0$};

		% Vértices fora de X
		\node[vtx] (u1) at (0, 2) {$u_1$};
		\node[vtx] (u2) at (2, 2) {$u_2$};
		\node[vtx] (u3) at (4, 2) {$u_3$};

		% Vértices dentro de X (destacados)
		\node[vtxX] (v1) at (0.5, -0.5) {$v_1$};
		\node[vtxX] (v2) at (2, -0.5) {$v_2$};
		\node[vtxX] (v3) at (3.5, -0.5) {$v_3$};

		% Arcos da raiz
		\draw[arc] (r0) -- node[cost, left, pos=0.4] {1} (u1);
		\draw[arc] (r0) -- node[cost, right] {2} (u2);
		\draw[arc] (r0) -- node[cost, right, pos=0.4] {1} (u3);

		% Arcos externos a X
		\draw[arc] (u1) to[bend left=15] node[cost, above] {1} (u2);
		\draw[arc] (u2) to[bend left=15] node[cost, above] {3} (u3);

		% Arcos entrando em X (em vermelho, mas o mínimo em verde)
		\draw[arcEntering] (u1) -- node[cost, left] {3} (v1);
		\draw[arcMin] (u2) -- node[costMin, right] {2} (v2);
		\draw[arcEntering] (u3) -- node[cost, right] {4} (v3);
		\draw[arcEntering] (u1) to[bend right=20] node[cost, below, pos=0.3] {5} (v2);

		% Arcos internos a X
		\draw[arc] (v1) -- node[cost, above] {1} (v2);
		\draw[arc] (v2) -- node[cost, above] {2} (v3);

		% Arcos saindo de X
		\draw[arc] (v1) to[bend right=30] node[cost, left, pos=0.3] {2} (u1);

		% Região X destacada
		\draw[orange!60!black, thick, dashed, rounded corners=8pt]
		(-0.3, 0.3) rectangle (4.3, -1.3);
		\node[orange!80!black, font=\bfseries] at (5, 0.3) {$X$};

		% Anotação do resultado
		\node[font=\bfseries, green!60!black] at (2, -2.2) {$\Delta(X) = \min\{3, 2, 4, 5\} = 2$};
	\end{tikzpicture}
	\caption{Ilustração da função \texttt{get\_minimum\_weight\_cut} em \(D_{32}\). Considerando os arcos \textcolor{red!70!black}{em vermelho} que entram em \(X\) (identificados pela função anterior), esta função calcula o peso mínimo entre eles. O arco \textcolor{green!60!black}{em verde} possui o menor peso (2), correspondendo ao valor \(\Delta(X) = 2\).}
\end{figure}

\subsection{Atualização de pesos em \texorpdfstring{\(X\)}{X}}

Esta função auxiliar atualiza os pesos dos arcos que entram em um conjunto \(X\), subtraindo o valor \(\Delta(X)\) de cada peso. Arcos que atingem peso zero são adicionados a \(A_0\) e a \(D_0\).

Recebe como entrada um dígrafo \texttt{D}, lista de \texttt{arcs} entrando em \(X\), o valor \texttt{min\_weight} a ser subtraído, uma lista \texttt{A\_zero} para armazenar arcos de peso zero, e o dígrafo \texttt{D\_zero} para adicionar os arcos justos.

A implementação itera sobre cada arco \((u,v,\_)\) da lista (linha 2), subtrai \texttt{min\_weight} do peso armazenado em \texttt{D[u][v]["w"]} (linha 3), e verifica se o peso resultante é zero (linha 4). Caso sim, adiciona-se \((u,v)\) à lista \texttt{A\_zero} (linha 5) e ao dígrafo \texttt{D\_zero} (linha 6).

A função não devolve valor, pois modifica diretamente as estruturas passadas como parâmetros: o dígrafo \texttt{D} tem seus pesos atualizados, \texttt{A\_zero} acumula arcos justos, e \texttt{D\_zero} é populado com esses arcos. A complexidade é \(O(k)\), onde \(k\) é o número de arcos em \texttt{arcs}.

\begin{tcolorbox}[
		enhanced, breakable,
		colframe=blue!60!black, colback=blue!2,
		colbacktitle=blue!15, coltitle=black,
		title={Atualização de pesos em X},
		boxed title style={sharp corners, boxrule=0.6pt},
		sharp corners, boxrule=0.6pt
	]
	\emph{Atualiza os pesos dos arcos que entram em X, subtraindo o valor mínimo. Arcos que atingem peso zero são registrados em $A_0$ e adicionados a $D_0$.}
	\tcblower
	\begin{lstlisting}[language=Python]
def update_weights_in_X(D, arcs, min_weight, A_zero, D_zero):
    for u, v, _ in arcs:
        D[u][v]["w"] -= min_weight
        if D[u][v]["w"] == 0:
            A_zero.append((u, v))
            D_zero.add_edge(u, v)
\end{lstlisting}
\end{tcolorbox}

A seguir ilustramos o funcionamento da função \texttt{update\_weights\_in\_X} em \(D_{32}\). A figura mostra o dígrafo antes e depois da atualização dos pesos. No estado inicial (esquerda), temos \(\Delta(X) = 2\). A função subtrai esse valor de todos os arcos que entram em \(X\). No estado final (direita), os arcos que atingiram peso zero (destacados em azul) são adicionados a \(A_0\) e \(D_0\).

\begin{figure}[H]
	\centering
	\begin{tikzpicture}[>=Stealth]
		% estilos
		\tikzset{
			vtx/.style={circle, draw, fill=blue!8, thick, inner sep=1.2pt, minimum size=6.5mm},
			vtxRoot/.style={circle, draw, fill=red!15, thick, inner sep=1.2pt, minimum size=6.5mm},
			vtxX/.style={circle, draw=orange!80!black, fill=orange!15, thick, inner sep=1.2pt, minimum size=6.5mm},
			arc/.style={->, >=Stealth, thick, draw=black!40},
			arcEntering/.style={->, >=Stealth, very thick, draw=red!70!black},
			arcTight/.style={->, >=Stealth, ultra thick, draw=blue!70!black},
			cost/.style={font=\scriptsize, fill=white, inner sep=1pt},
			costTight/.style={font=\scriptsize\bfseries, fill=blue!10, inner sep=2pt, draw=blue!70!black, rounded corners=1pt}
		}

		% ===== ANTES (esquerda) =====
		\begin{scope}
			\node[font=\bfseries, blue!80!black] at (2, 4.2) {Antes: pesos originais};

			% Raiz
			\node[vtxRoot] (r0) at (2, 3) {$r_0$};

			% Vértices fora de X
			\node[vtx] (u1) at (0, 1.5) {$u_1$};
			\node[vtx] (u2) at (2, 1.5) {$u_2$};
			\node[vtx] (u3) at (4, 1.5) {$u_3$};

			% Vértices dentro de X
			\node[vtxX] (v1) at (0.5, -0.5) {$v_1$};
			\node[vtxX] (v2) at (2, -0.5) {$v_2$};
			\node[vtxX] (v3) at (3.5, -0.5) {$v_3$};

			% Arcos da raiz
			\draw[arc] (r0) -- node[cost, left, pos=0.4] {1} (u1);
			\draw[arc] (r0) -- node[cost, right] {2} (u2);
			\draw[arc] (r0) -- node[cost, right, pos=0.4] {1} (u3);

			% Arcos externos a X
			\draw[arc] (u1) to[bend left=15] node[cost, above] {1} (u2);
			\draw[arc] (u2) to[bend left=15] node[cost, above] {3} (u3);

			% Arcos entrando em X
			\draw[arcEntering] (u1) -- node[cost, left] {3} (v1);
			\draw[arcEntering] (u2) -- node[cost, right] {2} (v2);
			\draw[arcEntering] (u3) -- node[cost, right] {4} (v3);
			\draw[arcEntering] (u1) to[bend right=20] node[cost, below, pos=0.3] {5} (v2);

			% Arcos internos a X
			\draw[arc] (v1) -- node[cost, above] {1} (v2);
			\draw[arc] (v2) -- node[cost, above] {2} (v3);

			% Arcos saindo de X
			\draw[arc] (v1) to[bend right=30] node[cost, left, pos=0.3] {2} (u1);

			% Região X
			\draw[orange!60!black, thick, dashed, rounded corners=8pt]
			(-0.3, 0.3) rectangle (4.3, -1.3);
			\node[orange!80!black, font=\bfseries\small] at (4.8, 0.1) {$X$};

			\node[font=\small, green!60!black] at (2, -2.2) {$\Delta(X) = 2$};
		\end{scope}

		% Seta indicando transformação
		\draw[->, ultra thick, blue!60!black] (5.3, 0.5) -- node[above, font=\small] {subtrai $\Delta(X)$} (6.7, 0.5);

		% ===== DEPOIS (direita) =====
		\begin{scope}[xshift=7.5cm]
			\node[font=\bfseries, blue!80!black] at (2, 4.2) {Depois: pesos atualizados};

			% Raiz
			\node[vtxRoot] (r0b) at (2, 3) {$r_0$};

			% Vértices fora de X
			\node[vtx] (u1b) at (0, 1.5) {$u_1$};
			\node[vtx] (u2b) at (2, 1.5) {$u_2$};
			\node[vtx] (u3b) at (4, 1.5) {$u_3$};

			% Vértices dentro de X
			\node[vtxX] (v1b) at (0.5, -0.5) {$v_1$};
			\node[vtxX] (v2b) at (2, -0.5) {$v_2$};
			\node[vtxX] (v3b) at (3.5, -0.5) {$v_3$};

			% Arcos da raiz (inalterados)
			\draw[arc] (r0b) -- node[cost, left, pos=0.4] {1} (u1b);
			\draw[arc] (r0b) -- node[cost, right] {2} (u2b);
			\draw[arc] (r0b) -- node[cost, right, pos=0.4] {1} (u3b);

			% Arcos externos a X (inalterados)
			\draw[arc] (u1b) to[bend left=15] node[cost, above] {1} (u2b);
			\draw[arc] (u2b) to[bend left=15] node[cost, above] {3} (u3b);

			% Arcos entrando em X (atualizados)
			\draw[arcEntering] (u1b) -- node[cost, left] {1} (v1b);
			\draw[arcTight] (u2b) -- node[costTight, right] {0} (v2b);
			\draw[arcEntering] (u3b) -- node[cost, right] {2} (v3b);
			\draw[arcEntering] (u1b) to[bend right=20] node[cost, below, pos=0.3] {3} (v2b);

			% Arcos internos a X (inalterados)
			\draw[arc] (v1b) -- node[cost, above] {1} (v2b);
			\draw[arc] (v2b) -- node[cost, above] {2} (v3b);

			% Arcos saindo de X (inalterados)
			\draw[arc] (v1b) to[bend right=30] node[cost, left, pos=0.3] {2} (u1b);

			% Região X
			\draw[orange!60!black, thick, dashed, rounded corners=8pt]
			(-0.3, 0.3) rectangle (4.3, -1.3);
			\node[orange!80!black, font=\bfseries\small] at (4.8, 0.1) {$X$};

			\node[font=\small, blue!70!black] at (2, -2.2) {Arco \textcolor{blue!70!black}{justo} $\to A_0$};
		\end{scope}
	\end{tikzpicture}
	\caption{Ilustração da função \texttt{update\_weights\_in\_X} em \(D_{32}\). À esquerda, o dígrafo antes da atualização, com os arcos \textcolor{red!70!black}{em vermelho} entrando em \(X\) e \(\Delta(X) = 2\). À direita, após subtrair \(\Delta(X)\) de cada arco entrando em \(X\): o peso $(u_1, v_1)$ reduz de 3 para 1, $(u_2, v_2)$ de 2 para \textcolor{blue!70!black}{\textbf{0}} (torna-se justo), $(u_3, v_3)$ de 4 para 2, e $(u_1, v_2)$ de 5 para 3. O arco justo é adicionado a \(A_0\) e \(D_0\). Note que os arcos da raiz e arcos internos/externos a \(X\) permanecem inalterados.}
\end{figure}

\subsection{Verificação de arborescência}

Esta função verifica se um dígrafo \(D\) contém uma r-arborescência com raiz \(r_0\). Utiliza busca em profundidade (DFS) a partir da raiz para verificar se todos os vértices são alcançáveis.

Recebe como entrada um dígrafo \texttt{D} e a raiz \texttt{r0}. A implementação constrói uma árvore DFS a partir de \texttt{r0} usando \texttt{nx.dfs\_tree} (linha 2), que devolve um subdigrafo contendo apenas os vértices alcançáveis a partir da raiz seguindo arcos. Em seguida, compara o número de vértices da árvore DFS com o número total de vértices de \texttt{D} (linha 3).

A função devolve \texttt{True} se todos os vértices são alcançáveis (indicando presença de r-arborescência), \texttt{False} caso contrário. A complexidade é \(O(n+m)\), onde \(n=|V|\) e \(m=|A|\), devido à busca em profundidade. Precisamos dessa verificação para garantir que a Fase~1 produza um dígrafo \(D_0\) que contenha uma r-arborescência antes de prosseguir para a Fase~2.

\begin{tcolorbox}[
		enhanced, breakable,
		colframe=blue!60!black, colback=blue!2,
		colbacktitle=blue!15, coltitle=black,
		title={Verificação de arborescência},
		boxed title style={sharp corners, boxrule=0.6pt},
		sharp corners, boxrule=0.6pt
	]
	\emph{Verifica se o dígrafo D contém uma r-arborescência com raiz r0, usando busca em profundidade para testar alcançabilidade de todos os vértices.}
	\tcblower
	\begin{lstlisting}[language=Python]
def has_arborescence(D, r0):
    tree = nx.dfs_tree(D, r0)
    return tree.number_of_nodes() == D.number_of_nodes()
\end{lstlisting}
\end{tcolorbox}

\subsection{Fase 1: Elevação de potenciais e construção de \texorpdfstring{\(A_0\)}{A_0}}

A seguir apresentamos a função principal da Fase~1, responsável por elevar os potenciais dos vértices iterativamente até que cada conjunto de vértices possua ao menos um arco justo entrando. O processo utiliza componentes fortemente conexas para identificar quais conjuntos necessitam elevação.

Recebe como entrada um dígrafo \texttt{D\_original} e a raiz \texttt{r0}. A implementação cria uma cópia do dígrafo original (linha 2) para preservar a entrada, inicializa estruturas auxiliares \texttt{A\_zero} (lista de arcos justos), \texttt{Dual\_list} (lista de pares \((X, \Delta(X))\) para fins de validação dual), e \texttt{D\_zero} (dígrafo de arcos justos) (linhas 3-5). Um contador de iterações é inicializado na linha 6.

O loop principal (linhas 7-22) itera enquanto houver conjuntos sem arcos justos entrando. Em cada iteração, incrementa-se o contador (linha 8), calcula-se as componentes fortemente conexas de \(D_0\) usando \texttt{nx.condensation} (linha 9), que devolve um grafo acíclico dirigido (DAG, do inglês \emph{directed acyclic graph}) onde cada vértice representa uma componente e contém o atributo \texttt{"members"} com os vértices originais. Utilizamos componentes fortemente conexas porque elas identificam naturalmente os conjuntos maximais de vértices que ainda não possuem arcos justos entrando, evitando a necessidade de rastrear manualmente quais conjuntos já foram processados.

Em seguida, identificam-se as fontes (componentes sem arcos entrando) no grafo de condensação (linha 10). Se há apenas uma fonte, significa que todos os vértices estão em uma única componente alcançável pela raiz através de arcos justos, garantindo que \(D_0\) contém uma r-arborescência e encerrando o loop (linhas 11-12).

Para cada fonte \(u\) no grafo de condensação (linha 13), obtém-se o conjunto \(X\) de vértices da componente (linha 14). Se \(r_0 \in X\), a fonte é ignorada (linhas 15-16), pois a componente contendo a raiz não necessita elevação. Caso contrário, identificam-se os arcos entrando em \(X\) usando \texttt{get\_arcs\_entering\_X} (linha 17), calcula-se o peso mínimo \(\Delta(X)\) usando \texttt{get\_minimum\_weight\_cut} (linha 18), e atualiza-se os pesos com \texttt{update\_weights\_in\_X}, registrando novos arcos justos (linha 19). A elevação simultânea de potenciais para todos os vértices de \(X\) mantém a propriedade de que arcos internos a \(X\) permanecem com o mesmo custo reduzido relativo, preservando a correção do algoritmo. Finalmente, adiciona-se \((X, \Delta(X))\) à lista dual se \(\Delta(X) > 0\) (linhas 20-21), permitindo verificação posterior das condições de otimalidade dual.

A função devolve \texttt{A\_zero} (lista de arcos justos) e \texttt{Dual\_list} (pares \((X, \Delta(X))\) para validação). A complexidade é \(O(nm)\) no pior caso, com \(O(n)\) iterações, cada uma custando \(O(m)\) para calcular componentes e atualizar pesos.

\begin{tcolorbox}[
		enhanced, breakable,
		colframe=blue!60!black, colback=blue!2,
		colbacktitle=blue!15, coltitle=black,
		title={Fase 1: Elevação de potenciais e construção de $A_0$},
		boxed title style={sharp corners, boxrule=0.6pt},
		sharp corners, boxrule=0.6pt
	]
	\emph{Eleva iterativamente os potenciais dos vértices até que cada conjunto possua ao menos um arco justo entrando. Devolve a lista $A_0$ de arcos justos e a lista de pares $(X, \Delta(X))$ para validação dual.}
	\tcblower
	\begin{lstlisting}[language=Python, basicstyle=\ttfamily\fontsize{8}{9}\selectfont]
def phase1(D_original, r0):
    D_copy = D_original.copy()
    A_zero = []
    Dual_list = []
    D_zero = build_D_zero(D_copy)
    iteration = 0
    while True:
        iteration += 1
        C = nx.condensation(D_zero)
        sources = [x for x in C.nodes() if C.in_degree(x) == 0]
        if len(sources) == 1:
            break
        for u in sources:
            X = C.nodes[u]["members"]
            if r0 in X:
                continue
            arcs = get_arcs_entering_X(D_copy, X)
            min_weight = get_minimum_weight_cut(arcs)
            update_weights_in_X(D_copy, arcs, min_weight, A_zero, D_zero)
            if min_weight != 0:
                Dual_list.append((X, min_weight)) 
    return A_zero, Dual_list
\end{lstlisting}
\end{tcolorbox}

As funções auxiliares implementadas nesta seção correspondem diretamente aos passos da Fase~1 do algoritmo de András Frank da seguinte forma:

\begin{tcolorbox}[
		enhanced, breakable,
		colframe=purple!60!black, colback=purple!5,
		colbacktitle=purple!15, coltitle=black,
		title={Correspondência entre Teoria e Implementação — Fase 1},
		boxed title style={sharp corners, boxrule=0.6pt},
		sharp corners, boxrule=0.6pt
	]
	\textbf{Passo 1 — Inicialização:}
	\begin{itemize}
		\item \textbf{Descrição teórica:} Defina \(y(v) := 0\) para todo \(v \in V\).
		\item \textbf{Implementação:} A função \texttt{build\_D\_zero(D)} inicializa o dígrafo \(D_0\) vazio, que será populado apenas com arcos justos. Implicitamente, os potenciais iniciam em zero, pois os pesos no dígrafo \(D\) representam os custos reduzidos \(c_y(u,v) = c(u,v) - y(v)\). Com \(y(v) = 0\), temos \(c_y = c\) no início.
	\end{itemize}

	\vspace{2mm}
	\textbf{Passo 2 — Iteração de elevação de potenciais:}
	\begin{itemize}
		\item \textbf{Descrição teórica:} Enquanto existir conjunto \(X \subseteq V \setminus \{r\}\) sem arco justo entrando:
		      \begin{itemize}
			      \item Calcule \(\Delta(X) := \min\{c(u,v) - y(v) : u \notin X, v \in X\}\).
			      \item Para cada \(v \in X\), atualize \(y(v) := y(v) + \Delta(X)\).
		      \end{itemize}
		\item \textbf{Implementação:} Esse processo de iteração é realizado pela composição sequencial de três funções auxiliares:
		      \begin{enumerate}
			      \item \texttt{get\_arcs\_entering\_X(D, X)}: Identifica o conjunto \(\{(u,v) : u \notin X, v \in X\}\), isto é, todos os arcos que cruzam a fronteira de \(X\). Essa função corresponde diretamente à definição do conjunto sobre o qual o mínimo é calculado na fórmula \(\Delta(X)\).

			      \item \texttt{get\_minimum\_weight\_cut(arcs)}: Calcula \(\min\{\text{data}["w"] : (u,v,\text{data}) \in \text{arcs}\}\), que é exatamente \(\Delta(X) = \min\{c_y(u,v) : u \notin X, v \in X\}\). Como os pesos no dígrafo já representam custos reduzidos (são atualizados a cada iteração), essa função devolve precisamente o valor teórico de \(\Delta(X)\).

			      \item \texttt{update\_weights\_in\_X(D, arcs, min\_weight, A\_zero, D\_zero)}: Implementa a atualização dos potenciais. Para cada arco \((u,v)\) entrando em \(X\), subtrai \texttt{min\_weight} de \texttt{D[u][v]["w"]}, efetivamente calculando o novo custo reduzido:
			            \[c_y'(u,v) = c_y(u,v) - \Delta(X) = \]
			            \[c(u,v) - y(v) - \Delta(X) = \]
			            \[c(u,v) - \bigl(y(v) + \Delta(X)\bigr) = c(u,v) - y'(v), \]
			            onde \(y'(v) = y(v) + \Delta(X)\) é o novo potencial. Arcos cujo custo reduzido atinge zero (\texttt{D[u][v]["w"] == 0}) são adicionados a \(A_0\) e \(D_0\), tornando-se \textbf{justos}.
		      \end{enumerate}
	\end{itemize}

	\vspace{2mm}
	\textbf{Passo 3 — Construção de \(A_0\):}
	\begin{itemize}
		\item \textbf{Descrição teórica:} Defina \(A_0 := \{a \in A : c_y(a) = 0\}\), o conjunto de arcos justos.
		\item \textbf{Implementação:} A construção de \(A_0\) ocorre de forma incremental durante as iterações do Passo~2. Cada chamada a \texttt{update\_weights\_in\_X} verifica quais arcos atingiram custo reduzido zero e os adiciona tanto à lista \texttt{A\_zero} quanto ao dígrafo \texttt{D\_zero}. Esse processo continua até que a função principal da Fase~1 (que será apresentada adiante) determine que cada componente fortemente conexa em \(D_0\) (exceto a raiz) possui ao menos um arco justo entrando, garantindo que \(A_0\) é suficiente para formar a base de uma \(r\)-arborescência.
		\item O resultado final é o conjunto completo \(A_0 = \{a \in A : c_y(a) = 0\}\), usado na Fase~2 para construir a arborescência ótima através de uma seleção gulosa de arcos justos.
	\end{itemize}
\end{tcolorbox}

\subsection{Fase 2: Construção da arborescência}
Esta é a função principal da Fase~2, responsável por construir a r-arborescência de custo mínimo a partir do conjunto \(A_0\) de arcos justos. A construção é incremental: inicia-se com a raiz e adiciona-se iterativamente arcos de \(A_0\) que conectam vértices já incluídos a novos vértices, garantindo que cada vértice não-raiz receba exatamente um arco de entrada.

Recebe como entrada um dígrafo \texttt{D\_original}, a raiz \texttt{r0}, e a lista \texttt{A\_zero} de arcos justos. A implementação cria um novo dígrafo vazio \texttt{Arb} (linha 2) e adiciona a raiz (linha 3).

O loop principal (linhas 5-12) itera \(n-1\) vezes, onde \(n = |V|\), pois uma r-arborescência tem exatamente \(|V|-1\) arcos. Em cada iteração:
\begin{enumerate}\setlength{\itemsep}{2pt}
	\item Percorre os arcos \((u,v)\) de \texttt{A\_zero} (linha 6).
	\item Verifica se \(u\) já está em \texttt{Arb} e \(v\) ainda não (linha 7).
	\item Se sim, obtém os dados do arco do dígrafo original (linha 8) e adiciona \((u,v)\) a \texttt{Arb} (linha 9).
	\item Interrompe o loop interno para reiniciar a busca, garantindo descoberta em largura (linha 10).
\end{enumerate}

A função devolve o dígrafo \texttt{Arb} representando a r-arborescência de custo mínimo. A complexidade é \(O(nm)\) no pior caso, pois cada uma das \(O(n)\) iterações pode percorrer todos os \(O(m)\) arcos de \texttt{A\_zero}.

\begin{tcolorbox}[
		enhanced, breakable,
		colframe=blue!60!black, colback=blue!2,
		colbacktitle=blue!15, coltitle=black,
		title={Fase 2: Construção da arborescência},
		boxed title style={sharp corners, boxrule=0.6pt},
		sharp corners, boxrule=0.6pt
	]
	\emph{Constrói incrementalmente a r-arborescência a partir de $A_0$, adicionando iterativamente arcos que conectam vértices já incluídos a novos vértices.}
	\tcblower
	\begin{lstlisting}[language=Python]
def phase2(D_original, r0, A_zero):
    Arb = nx.DiGraph()
    Arb.add_node(r0)
    n = len(D_original.nodes())
    for _ in range(n - 1):
        for u, v in A_zero:
            if u in Arb.nodes() and v not in Arb.nodes():
                edge_data = D_original.get_edge_data(u, v)
                Arb.add_edge(u, v, **edge_data)
                break
    return Arb
\end{lstlisting}
\end{tcolorbox}

Apresentamos também uma versão alternativa da Fase~2 que utiliza busca em largura (BFS) para construir a r-arborescência de forma mais eficiente. Diferentemente da versão anterior que itera \(n-1\) vezes sobre todos os arcos, esta implementação usa uma fila de prioridade para explorar os arcos em ordem, evitando buscas lineares repetidas.

Recebe como entrada um dígrafo \texttt{D\_original}, a raiz \texttt{r0}, e a lista \texttt{A\_zero} de arcos justos. A implementação começa criando um dígrafo auxiliar \texttt{Arb} (linha 2) onde cada arco de \texttt{A\_zero} recebe um peso igual ao seu índice na lista (linhas 3-4), estabelecendo uma ordem de exploração. Inicializa-se o conjunto \texttt{V} de vértices visitados contendo apenas a raiz (linha 5) e uma fila de prioridade vazia \texttt{q} (linha 6).

Todos os arcos que saem da raiz em \texttt{Arb} são adicionados à fila de prioridade (linhas 7-8), usando o peso (índice) como critério de ordenação. Cria-se então o dígrafo \texttt{A} que conterá a arborescência resultante (linha 9).

O loop principal (linhas 10-17) extrai arcos da fila de prioridade em ordem crescente de índice. Para cada arco \((u,v)\) extraído (linha 11), verifica-se se o vértice destino \(v\) já foi visitado (linha 12); em caso positivo, o arco é ignorado via \texttt{continue} (linha 13). Caso contrário, adiciona-se o arco \((u,v)\) à arborescência \texttt{A} com o peso original de \texttt{D\_original} (linha 14), marca-se \(v\) como visitado (linha 15), e todos os arcos que saem de \(v\) em \texttt{Arb} são adicionados à fila de prioridade para exploração futura (linhas 16-17).

A função devolve o dígrafo \texttt{A} representando a r-arborescência de custo mínimo. A complexidade é \(O(m \log m)\), onde \(m = |A_0|\), devido às operações de inserção e remoção na fila de prioridade. Esta versão é mais eficiente que a anterior quando \(|A_0|\) é grande, pois evita percorrer todos os arcos em cada iteração.

\begin{tcolorbox}[
		enhanced, breakable,
		colframe=blue!60!black, colback=blue!2,
		colbacktitle=blue!15, coltitle=black,
		title={Fase 2 (versão BFS): Construção da arborescência com fila de prioridade},
		boxed title style={sharp corners, boxrule=0.6pt},
		sharp corners, boxrule=0.6pt
	]
	\emph{Constrói a r-arborescência usando busca em largura guiada por fila de prioridade, explorando arcos de $A_0$ em ordem e evitando buscas lineares repetidas. Complexidade $O(m \log m)$.}
	\tcblower
	\begin{lstlisting}[language=Python]
def phase2_v2(D_original, r0, A_zero):
    Arb = nx.DiGraph()
    for i, (u, v) in enumerate(A_zero):
        Arb.add_edge(u, v, w=i)
    V = {r0}
    q = []
    for u, v, data in Arb.out_edges(r0, data=True):
        heapq.heappush(q, (data["w"], u, v))
    A = nx.DiGraph()
    while q:
        _, u, v = heapq.heappop(q)
        if v in V:
            continue
        A.add_edge(u, v, w=D_original[u][v]["w"])
        V.add(v)
        for x, y, data in Arb.out_edges(v, data=True):
            heapq.heappush(q, (data["w"], x, y))
    return A
\end{lstlisting}
\end{tcolorbox}

As duas versões da Fase~2 implementadas acima correspondem diretamente ao Passo~4 da descrição teórica do algoritmo de András Frank:

\begin{tcolorbox}[
		enhanced, breakable,
		colframe=purple!60!black, colback=purple!5,
		colbacktitle=purple!15, coltitle=black,
		title={Correspondência entre Teoria e Implementação — Fase 2},
		boxed title style={sharp corners, boxrule=0.6pt},
		sharp corners, boxrule=0.6pt
	]
	\textbf{Passo 4 — Construção da arborescência (caso acíclico):}
	\begin{itemize}
		\item \textbf{Descrição teórica:} Se \((V,A_0)\) forma uma r-arborescência, devolva \(A_0\). Por otimalidade dos potenciais duais, trata-se de uma r-arborescência de custo mínimo.
		\item \textbf{Implementação:} Ambas as versões de \texttt{phase2} constroem uma r-arborescência a partir do conjunto \(A_0\) de arcos justos obtido na Fase~1. A corretude baseia-se no fato de que todos os arcos em \(A_0\) têm custo reduzido zero, e a Fase~1 garante que existe uma r-arborescência formada exclusivamente por arcos justos.
		      \begin{itemize}
			      \item \textbf{Versão 1 (\texttt{phase2}):} Construção incremental por exploração exaustiva. Em cada uma das \(n-1\) iterações, percorre todos os arcos de \(A_0\) procurando um arco \((u,v)\) tal que \(u\) já pertence à arborescência parcial e \(v\) ainda não. Essa abordagem simples corresponde diretamente à ideia teórica de construir a arborescência adicionando um vértice por vez, conectando-o à estrutura existente através de um arco justo. Complexidade: \(O(nm)\).

			      \item \textbf{Versão 2 (\texttt{phase2\_v2}):} Construção por busca em largura guiada por fila de prioridade. Cria um dígrafo auxiliar onde arcos são indexados, usa a fila de prioridade para explorar arcos sistematicamente a partir da raiz, evitando buscas lineares repetidas. Essa versão otimizada mantém a mesma correção teórica — construir uma r-arborescência usando apenas arcos de \(A_0\) — mas melhora a eficiência prática. Complexidade: \(O(m \log m)\).
		      \end{itemize}
	\end{itemize}

	\vspace{2mm}
	\textbf{Nota sobre Passos 5-7 (contração/recursão/expansão):}
	\begin{itemize}
		\item A descrição teórica do algoritmo de András Frank inclui os Passos~5-7 para tratar o caso onde \(A_0\) contém ciclos dirigidos, exigindo contração, resolução recursiva e reexpansão, de forma análoga ao algoritmo de Chu--Liu--Edmonds.
		\item Na implementação apresentada, optamos por uma abordagem não-recursiva baseada em componentes fortemente conexas. A Fase~1 já garante que \(A_0\) formará uma r-arborescência ao término das iterações de elevação de potenciais, eliminando a necessidade de tratar ciclos explicitamente na Fase~2. Essa simplificação é possível porque a elevação de potenciais progressivamente "quebra" todos os ciclos ao criar novos arcos justos que conectam diferentes componentes, até que reste apenas uma única componente fortemente conexa contendo todos os vértices.
		\item Portanto, quando a Fase~2 é executada, o conjunto \(A_0\) já está livre de ciclos e forma uma r-arborescência, correspondendo diretamente ao caso tratado pelo Passo~4 da descrição teórica. A verificação prévia \texttt{has\_arborescence(D, r0)} (realizada pela função principal) confirma essa propriedade antes de invocar a Fase~2.
	\end{itemize}
\end{tcolorbox}

\subsection{Verificação de otimalidade dual}

Esta função verifica se a condição de otimalidade dual é satisfeita para a r-arborescência construída. Segundo a teoria de programação linear dual aplicada ao problema de arborescência de custo mínimo, uma solução é ótima se e somente se cada conjunto \(X \subseteq V \setminus \{r\}\) que teve seu potencial elevado durante a Fase~1 possui exatamente um arco entrando na arborescência final.

Recebe como entrada a arborescência \texttt{Arb} e a lista \texttt{Dual\_list} contendo pares \((X, \Delta(X))\) onde \(X\) é um conjunto de vértices cujos potenciais foram elevados e \(\Delta(X) > 0\) é o valor da elevação. A implementação itera sobre cada par \((X, z)\) na lista dual (linha 2), e para cada conjunto \(X\), percorre todos os arcos \((u,v)\) da arborescência (linha 3). Inicializa um contador \texttt{count} em zero (linha 4) e verifica se o arco cruza a fronteira de \(X\), isto é, se \(u \notin X\) e \(v \in X\) (linha 5). Quando essa condição é satisfeita, incrementa o contador (linha 6) e imediatamente verifica se já há mais de um arco entrando em \(X\) (linha 7). Caso positivo, a condição de otimalidade dual é violada e a função devolve \texttt{False} (linha 8).

A função devolve \texttt{True} se todos os conjuntos em \texttt{Dual\_list} possuem exatamente um arco entrando na arborescência, confirmando que a solução satisfaz as condições de folga complementar da programação linear dual. A complexidade é \(O(km)\), onde \(k = |\texttt{Dual\_list}|\) e \(m = |A|\), pois para cada conjunto dual verifica-se todos os arcos da arborescência.

Esta verificação é fundamental para garantir a correção do algoritmo: a Fase~1 constrói uma solução dual viável (potenciais \(y(v)\)), a Fase~2 constrói uma solução primal viável (arborescência), e esta função confirma que ambas satisfazem as condições de folga complementar, implicando otimalidade pelo teorema da dualidade forte.

\begin{tcolorbox}[
		enhanced, breakable,
		colframe=blue!60!black, colback=blue!2,
		colbacktitle=blue!15, coltitle=black,
		title={Verificação de otimalidade dual},
		boxed title style={sharp corners, boxrule=0.6pt},
		sharp corners, boxrule=0.6pt
	]
	\emph{Verifica se a condição de otimalidade dual é satisfeita, confirmando que cada conjunto dual possui exatamente um arco entrando na arborescência.}
	\tcblower
	\begin{lstlisting}[language=Python]
def check_dual_optimality_condition(Arb, Dual_list):
    for X, z in Dual_list:
        count = 0
        for u, v in Arb.edges():
            if u not in X and v in X:
                count += 1
                if count > 1:
                    return False
    return True
\end{lstlisting}
\end{tcolorbox}

\subsection{O algoritmo completo de András Frank}

Finalmente, apresentamos a função principal que implementa o algoritmo de András Frank para encontrar uma r-arborescência de custo mínimo em um dígrafo com pesos. A função integra as fases de construção dos potenciais duais, obtenção dos arcos justos, construção da arborescência e verificação de otimalidade dual.

\begin{tcolorbox}[
		enhanced, breakable,
		colframe=blue!60!black, colback=blue!2,
		colbacktitle=blue!15, coltitle=black,
		title={Verificação de otimalidade dual},
		boxed title style={sharp corners, boxrule=0.6pt},
		sharp corners, boxrule=0.6pt
	]
	\emph{Implementa o algoritmo completo de András Frank, integrando as fases de construção dos potenciais duais, obtenção dos arcos justos, construção da arborescência e verificação de otimalidade dual.}
	\tcblower
	\begin{lstlisting}[language=Python]
def andras_frank_algorithm(D):
    A_zero, Dual_list = phase1(D,"r0")
    arborescence_frank = phase2(D, "r0", A_zero)
    arborescence_frank_v2 = phase2_v2(D, "r0", A_zero)
    dual_frank = check_dual_optimality_condition(
        arborescence_frank, Dual_list)
    dual_frank_v2 = check_dual_optimality_condition(
        arborescence_frank_v2, Dual_list)
    return arborescence_frank, arborescence_frank_v2, dual_frank, dual_frank_v2
\end{lstlisting}
\end{tcolorbox}

\paragraph*{Fase 2 — Construção da arborescência:} Com \(A_0\) completo e acíclico, a Fase~2 constrói incrementalmente a arborescência final. Inicia-se com \(\texttt{Arb} = \{r_0\}\) e em cada iteração adiciona-se um arco \((u,v) \in A_0\) tal que \(u \in \texttt{Arb}\) e \(v \notin \texttt{Arb}\). A Figura~\ref{fig:frank-exemplo-arborescencia-final} mostra a arborescência resultante.

\subsection*{Verificação de otimalidade dual:} A função \texttt{check\_dual\_optimality\_condition} confirma que para cada par \((X, \Delta(X))\) em \texttt{Dual\_list} (conjuntos cujos potenciais foram elevados com \(\Delta(X) > 0\)), existe exatamente um arco da arborescência final cruzando a fronteira de \(X\). Essa condição, juntamente com os arcos justos, garante que as condições de folga complementar da programação linear dual são satisfeitas, implicando que a arborescência encontrada é de custo mínimo global.

\subsection{Correspondência entre teoria e implementação}

A implementação em Python do algoritmo de András Frank segue fielmente a descrição teórica primal-dual apresentada anteriormente. A tabela abaixo estabelece o paralelo direto entre os passos teóricos e sua realização no código:

\begin{table}[H]
	\centering
	\scriptsize
	\renewcommand{\arraystretch}{1.3}
	\begin{tabular}{>{\raggedright\arraybackslash}p{0.44\textwidth}|>{\raggedright\arraybackslash}p{0.48\textwidth}}
		\toprule
		\textbf{\normalsize Descrição Teórica} & \textbf{\normalsize Implementação Python} \\
		\midrule
		\rowcolor{blue!5}
		\textbf{Passo 1:} Inicialização

		Defina \(y(v) := 0\) para todo \(v \in V\).

		Inicialize \(A_0 := \emptyset\).

		Construa dígrafo vazio \(D_0\) (arcos justos).
		                                       &
		\textbf{Função \texttt{phase1} — Linhas 2--5:}

		\texttt{D\_copy = D\_original.copy()}

		\texttt{A\_zero = []}

		\texttt{D\_zero = build\_D\_zero(D\_copy)}

		\vspace{1mm}
		Potenciais \(y(v) = 0\) implícitos, custos \(c_y = c\).
		\\
		\midrule
		\rowcolor{green!5}
		\textbf{Passo 2:} Elevação de potenciais

		Enquanto \(\exists X \subseteq V \setminus \{r\}\) sem arco justo:

		\quad Calcule \(\Delta(X) := \min\{c_y(u,v) : u \notin X, v \in X\}\)

		\quad Atualize \(y(v) := y(v) + \Delta(X)\), \(\forall v \in X\)

		\quad Adicione arcos com \(c_y = 0\) a \(A_0\)
		                                       &
		\textbf{Loop principal — Linhas 7--22:}

		\texttt{C = nx.condensation(D\_zero)}

		\texttt{sources = [x for x in C.nodes()]}

		\texttt{\quad if C.in\_degree(x) == 0]}

		Para fonte \texttt{u} (exceto raiz):

		\texttt{\quad X = C.nodes[u]["members"]}

		\texttt{\quad arcs = get\_arcs\_entering\_X(D, X)}

		\texttt{\quad min\_w = get\_minimum\_weight\_cut(arcs)}

		\texttt{\quad update\_weights\_in\_X(D, arcs, min\_w,}

		\texttt{\quad\quad A\_zero, D\_zero)}
		\\
		\midrule
		\rowcolor{orange!5}
		\textbf{Passo 2(a):} Identificar arcos entrando

		Determine \(\{(u,v) \in A : u \notin X, v \in X\}\)
		                                       &
		\textbf{Função \texttt{get\_arcs\_entering\_X}:}

		\texttt{return [(u, v, data)}

		\texttt{\quad for u, v, data in D.edges(data=True)}

		\texttt{\quad if u not in X and v in X]}
		\\
		\midrule
		\rowcolor{purple!5}
		\textbf{Passo 2(b):} Calcular \(\Delta(X)\)

		\(\Delta(X) := \min\{c_y(u,v) : u \notin X, v \in X\}\)
		                                       &
		\textbf{Função \texttt{get\_minimum\_weight\_cut}:}

		\texttt{return min(data["w"]}

		\texttt{\quad for \_, \_, data in arcs)}
		\\
		\midrule
		\rowcolor{yellow!5}
		\textbf{Passo 2(c):} Atualizar pesos

		Para \((u,v)\) entrando em \(X\):

		\quad \(c_y(u,v) := c_y(u,v) - \Delta(X)\)

		\quad Se \(c_y(u,v) = 0\), adicione a \(A_0\)
		                                       &
		\textbf{Função \texttt{update\_weights\_in\_X}:}

		\texttt{for u, v, \_ in arcs:}

		\texttt{\quad D[u][v]["w"] -= min\_weight}

		\texttt{\quad if D[u][v]["w"] == 0:}

		\texttt{\quad\quad A\_zero.append((u, v))}

		\texttt{\quad\quad D\_zero.add\_edge(u, v)}
		\\
		\midrule
		\rowcolor{cyan!5}
		\textbf{Passo 3:} Verificar término

		Se \(D_0\) contém r-arborescência, encerre.
		                                       &
		\textbf{Condição — Linhas 11--12:}

		\texttt{if len(sources) == 1: break}

		\vspace{1mm}
		Uma fonte \(\Rightarrow\) r-arborescência acíclica.
		\\
		\midrule
		\rowcolor{red!5}
		\textbf{Passo 4:} Construir arborescência

		Construa \(F\) a partir de \(A_0\), conectando vértices incrementalmente.
		                                       &
		\textbf{Função \texttt{phase2} (incremental):}

		\texttt{Arb = nx.DiGraph(); Arb.add\_node(r0)}

		\texttt{for \_ in range(n - 1):}

		\texttt{\quad for u, v in A\_zero:}

		\texttt{\quad\quad if u in Arb and v not in Arb:}

		\texttt{\quad\quad\quad Arb.add\_edge(u, v, **data)}

		\texttt{\quad\quad\quad break}

		\vspace{1mm}
		Complexidade: \(O(nm)\).
		\\
		\midrule
		\rowcolor{red!5}
		\textbf{Passo 4:} Versão otimizada

		Mesma ideia, com fila de prioridade.
		                                       &
		\textbf{Função \texttt{phase2\_v2} (BFS):}

		\texttt{Arb = nx.DiGraph()}

		\texttt{for i, (u, v) in enumerate(A\_zero):}

		\texttt{\quad Arb.add\_edge(u, v, w=i)}

		\texttt{q = [] \# fila de prioridade}

		\texttt{while q:}

		\texttt{\quad \_, u, v = heapq.heappop(q)}

		\texttt{\quad if v in V: continue}

		\texttt{\quad A.add\_edge(u, v, w=D[u][v]["w"])}

		\vspace{1mm}
		Complexidade: \(O(m \log m)\).
		\\
		\midrule
		\rowcolor{pink!5}
		\textbf{Otimalidade dual}

		Para cada \(X\) elevado (\(\Delta(X) > 0\)), exatamente um arco de \(F\) cruza \(\delta^-(X)\).
		                                       &
		\textbf{Função \texttt{check\_dual\_optimality}:}

		\texttt{for X, z in Dual\_list:}

		\texttt{\quad count = 0}

		\texttt{\quad for u, v in Arb.edges():}

		\texttt{\quad\quad if u not in X and v in X:}

		\texttt{\quad\quad\quad count += 1}

		\texttt{\quad\quad\quad if count > 1: return False}

		\texttt{return True}
		\\
		\bottomrule
	\end{tabular}
	\caption{Correspondência entre a descrição teórica do algoritmo de András Frank e sua implementação em Python. Cores: inicialização (azul), elevação de potenciais (verde/laranja/roxo/amarelo), verificação (ciano), construção (vermelho) e validação dual (rosa).}
	\label{tab:frank-teoria-implementacao}
\end{table}

Esta correspondência demonstra que a implementação traduz fielmente a abordagem primal-dual em código executável. As funções auxiliares (\texttt{get\_arcs\_entering\_X}, \texttt{get\_minimum\_weight\_cut}, \texttt{update\_weights\_in\_X}, \texttt{phase1}, \texttt{phase2}, \texttt{phase2\_v2},
\texttt{check\_dual\_}-
\texttt{optimality\_condition} encapsulam exatamente as operações descritas na teoria, preservando as propriedades de correção e as garantias de otimalidade do algoritmo original. A utilização de componentes fortemente conexas (\texttt{nx.condensation}) para identificar conjuntos sem arcos justos entrando é uma implementação eficiente da verificação teórica, evitando enumeração explícita de todos os subconjuntos de vértices.
