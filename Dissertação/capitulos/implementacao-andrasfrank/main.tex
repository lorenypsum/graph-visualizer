\chapter{Algoritmo de András Frank}

Neste capítulo, apresentaremos o algoritmo de András Frank, que também determina
uma arborescência de custo mínimo em um digrafo ponderado.
O algoritmo baseia-se em duas operações fundamentais:
(i) a redução gulosa dos custos dos arcos através da identificação de subconjuntos minimais
e (ii) a contração de ciclos, de modo a resolver recursivamente uma instância menor do
problema e, em seguida, estender a solução para o problema original.
A operação de redução é essencialmente a mesma do algoritmo de Chu--Liu--Edmonds
--- subtrair o menor custo de arco entrando em cada conjunto --- mas enquanto
Chu--Liu--Edmonds opera vértice a vértice, o algoritmo de Frank identifica
\emph{subconjuntos minimais} através de componentes fortemente conexas,
processando todos simultaneamente a cada iteração.
O propósito deste capítulo é fornecer tanto uma descrição teórica do algoritmo quanto detalhes da implementação desenvolvida neste trabalho.

\section{O algoritmo}
\label{sec:algoritmo}
O algoritmo de András Frank também recebe uma tripla \((D,c,r)\), em que \(D=(V,A)\) é um digrafo,
\(c\colon A\to\mathbb{R}\) é uma função custo e \(r\in V\) é a raiz,
sob a hipótese de que \(D\) admite ao menos uma \(r\)-arborescência e devolve uma \(r\)-arborescência \(c\)-mínima de \(D\).

Assim como no capítulo anterior, adotamos a terminologia de \(r\)-digrafo ponderado para uma tripla \((D,c,r)\) em que $(D, c)$ é um digrafo ponderado,
$r$ é um vértice de $D$, $\delta^-(r) = \varnothing$
e $D$ possui uma $r$-arborescência.

Vamos desenvolver as ideias do algoritmo utilizando um exemplo que manifeste todas as
etapas do algoritmo, incluindo a formação de ciclos por arcos justos e a necessidade
de contração de componentes fortemente conexas.

Considere o dígrafo \(D\) da Figura~\ref{fig:frank-exemplo-inicial} com seis vértices
\(\{r, a, b, c, d, e\}\) e custos nos arcos cuidadosamente escolhidos para ilustrar
o comportamento completo do algoritmo.

\begin{figure}[H]
	\centering
	\begin{tikzpicture}[>=Stealth, scale=1.1]
		% estilos
		\tikzset{
			vtx/.style={circle, draw,fill=blue!8, thick, inner sep=1.2pt, minimum size=7mm},
			arc/.style={->, semithick, draw=black!50},
			costG/.style={font=\small, fill=white, inner sep=1.5pt, text=black!70}
		}

		% layout
		\node[vtx] (r) at (0,0) {$r$};
		\node[vtx] (a) at (3,2) {$a$};
		\node[vtx] (b) at (3,-2) {$b$};
		\node[vtx] (c) at (6,2) {$c$};
		\node[vtx] (d) at (6,0) {$d$};
		\node[vtx] (e) at (6,-2) {$e$};

		% arcos com custos
		\draw[arc] (r) -- node[costG, above left] {2} (a);
		\draw[arc] (r) -- node[costG, below left] {3} (b);
		\draw[arc] (r) .. controls (2,3.5) and (5,3.5) .. node[costG, above] {7} (c);

		\draw[arc] (a) -- node[costG, above] {5} (c);
		\draw[arc] (a) -- node[costG, right] {4} (d);
		\draw[arc] (b) -- node[costG, below] {2} (e);
		\draw[arc] (b) to[bend right=15] node[costG, left] {5} (a);

		\draw[arc] (c) to[bend left=15] node[costG, right] {1} (d);
		\draw[arc] (d) to[bend left=15] node[costG, left] {1} (c);
		\draw[arc] (d) -- node[costG, right] {3} (e);

		\draw[arc] (c) .. controls (7.5,2.5) and (7.5,-2.5) .. node[costG, right] {6} (e);
	\end{tikzpicture}
	\caption{Dígrafo \(D\) com custos originais. Este exemplo ilustrará todas as etapas
		do algoritmo de András Frank, incluindo formação de ciclos e contração.}
	\label{fig:frank-exemplo-inicial}
\end{figure}

Vamos agora executar o algoritmo de Frank sobre este dígrafo. O algoritmo opera em duas fases principais:
\textbf{(1) redução de custos} através da identificação de subconjuntos minimais e
\textbf{(2) construção da arborescência} a partir dos arcos que se tornaram justos (custo reduzido zero).

Na \textbf{primeira fase}, identificamos iterativamente os \emph{subconjuntos minimais} --- subconjuntos
\(X \subseteq V \setminus \{r\}\) tais que nenhum arco justo entra em \(X\), mas todo subconjunto próprio
de \(X\) possui ao menos um arco justo entrando. Para cada conjunto minimal \(X\), calculamos
\(\delta(X)\), o menor custo entre todos os arcos que entram em \(X\), e subtraímos esse valor de todos
esses arcos, criando ao menos um novo arco justo. Esse processo é repetido até que exista exatamente uma
\emph{fonte} no grafo de condensação (uma componente fortemente conexa contendo a raiz sem arcos justos entrando).

Inicialmente, como nenhum arco tem custo reduzido zero, cada vértice não-raiz \(v \neq r\) forma
seu próprio subconjunto minimal \(\{v\}\). No dígrafo da Figura~\ref{fig:frank-exemplo-inicial},
os subconjuntos minimais iniciais são portanto \(\{a\}\), \(\{b\}\), \(\{c\}\), \(\{d\}\) e \(\{e\}\).
Para cada um desses conjuntos unitários, encontramos \(\delta(\{v\})\), o menor custo entre todos os arcos
entrando em \(v\), e subtraímos esse valor de todos esses arcos.

Por exemplo, consideremos o vértice \(a\). Os arcos entrando em \(a\) são \((r,a)\) com custo 2
e \((b,a)\) com custo 5. Calculamos \(\delta(\{a\}) = \min\{2, 5\} = 2\) e subtraímos este valor
de ambos os arcos. Assim, \((r,a)\) passa a ter custo \(2-2=0\) (tornando-se um \emph{arco justo})
e \((b,a)\) passa a ter custo \(5-2=3\). A Figura~\ref{fig:frank-reducao-exemplo-a} ilustra
essa operação de redução aplicada ao vértice \(a\).

\begin{figure}[H]
	\centering
	\begin{tikzpicture}[>=Stealth, scale=0.95]
		\tikzset{
			vtx/.style={circle, draw,fill=blue!8, thick, inner sep=1.2pt, minimum size=7mm},
			vtxH/.style={circle, draw=orange!70, fill=orange!15, thick, inner sep=1.2pt, minimum size=8mm},
			arc/.style={->, semithick, draw=black!35},
			arcH/.style={->, ultra thick, draw=orange!70},
			tight/.style={->, very thick, draw=blue!70},
			costG/.style={font=\small, fill=white, inner sep=1.5pt, text=black!50},
			costO/.style={font=\small, fill=white, inner sep=1.5pt, text=orange!70, font=\small\bfseries},
			costB/.style={font=\small, fill=white, inner sep=1.5pt, text=blue!70}
		}

		% Antes da redução (dígrafo completo)
		\begin{scope}
			\node[font=\bfseries, above] at (3, 3.8) {Antes: custos originais};

			\node[vtx] (r1) at (0,0) {$r$};
			\node[vtxH] (a1) at (3,2) {$a$};
			\node[vtx] (b1) at (3,-2) {$b$};
			\node[vtx] (c1) at (6,2) {$c$};
			\node[vtx] (d1) at (6,0) {$d$};
			\node[vtx] (e1) at (6,-2) {$e$};

			% Arcos destacados entrando em 'a'
			\draw[arcH] (r1) -- node[costO, above left] {2} (a1);
			\draw[arcH] (b1) to[bend right=15] node[costO, left] {5} (a1);

			% Demais arcos
			\draw[arc] (r1) -- node[costG, below left] {3} (b1);
			\draw[arc] (r1) .. controls (1,3.5) and (5,3.5) .. node[costG, above] {7} (c1);
			\draw[arc] (a1) -- node[costG, above] {5} (c1);
			\draw[arc] (a1) -- node[costG, right] {4} (d1);
			\draw[arc] (b1) -- node[costG, below] {2} (e1);
			\draw[arc] (c1) to[bend left=15] node[costG, right] {1} (d1);
			\draw[arc] (d1) to[bend left=15] node[costG, left] {1} (c1);
			\draw[arc] (d1) -- node[costG, right] {3} (e1);
			\draw[arc] (c1) .. controls (7.5,2.5) and (7.5,-2.5) .. node[costG, right] {6} (e1);

			\node[orange!70, font=\small] at (3, -3.2) {$\delta(\{a\}) = \min\{2, 5\} = 2$};
		\end{scope}

		% Depois da redução (dígrafo completo)
		\begin{scope}[xshift=9.5cm]
			\node[font=\bfseries, above] at (3, 3.8) {Após redução de $\delta(\{a\})$};

			\node[vtx] (r2) at (0,0) {$r$};
			\node[vtxH] (a2) at (3,2) {$a$};
			\node[vtx] (b2) at (3,-2) {$b$};
			\node[vtx] (c2) at (6,2) {$c$};
			\node[vtx] (d2) at (6,0) {$d$};
			\node[vtx] (e2) at (6,-2) {$e$};

			% Arco justo
			\draw[tight] (r2) -- node[costB, above left] {0} (a2);
			% Arco reduzido
			\draw[arcH] (b2) to[bend right=15] node[costO, left] {3} (a2);

			% Demais arcos (custos inalterados)
			\draw[arc] (r2) -- node[costG, below left] {3} (b2);
			\draw[arc] (r2) .. controls (1,3.5) and (5,3.5) .. node[costG, above] {7} (c2);
			\draw[arc] (a2) -- node[costG, above] {5} (c2);
			\draw[arc] (a2) -- node[costG, right] {4} (d2);
			\draw[arc] (b2) -- node[costG, below] {2} (e2);
			\draw[arc] (c2) to[bend left=15] node[costG, right] {1} (d2);
			\draw[arc] (d2) to[bend left=15] node[costG, left] {1} (c2);
			\draw[arc] (d2) -- node[costG, right] {3} (e2);
			\draw[arc] (c2) .. controls (7.5,2.5) and (7.5,-2.5) .. node[costG, right] {6} (e2);

			\node[blue!70, font=\small] at (3, -3.2) {$(r,a)$ torna-se \textbf{justo} (custo 0)};
		\end{scope}
	\end{tikzpicture}
	\caption{Exemplo de redução de custo para o vértice \(a\) no dígrafo completo. À esquerda,
		os arcos entrando em \(a\) estão destacados em laranja com custos originais 2 e 5.
		Calculamos \(\delta(\{a\}) = 2\) e subtraímos esse valor de ambos os arcos. À direita,
		após a redução: \((r,a)\) tem custo zero (arco justo, em azul) e \((b,a)\) tem custo
		\(5-2=3\) (em laranja). Os demais arcos permanecem inalterados.}
	\label{fig:frank-reducao-exemplo-a}
\end{figure}

Essa operação vai sendo repetida para todos os conjuntos minimais iniciais.
A Figura~\ref{fig:frank-iter1-result} mostra o resultado dessa primeira iteração no exemplo
da Figura~\ref{fig:frank-exemplo-inicial}, onde aplicamos a redução apenas para os vértices isolados.

\begin{figure}[H]
	\centering
	\begin{tikzpicture}[>=Stealth, scale=1.1]
		\tikzset{
			vtx/.style={circle, draw,fill=blue!8, thick, inner sep=1.2pt, minimum size=7mm},
			tight/.style={->, very thick, draw=blue!70},
			loose/.style={->, semithick, draw=black!35},
			costB/.style={font=\small, fill=white, inner sep=1.5pt, text=blue!70},
			costG/.style={font=\small, fill=white, inner sep=1.5pt, text=black!50}
		}

		\node[vtx] (r) at (0,0) {$r$};
		\node[vtx] (a) at (3,2) {$a$};
		\node[vtx] (b) at (3,-2) {$b$};
		\node[vtx] (c) at (6,2) {$c$};
		\node[vtx] (d) at (6,0) {$d$};
		\node[vtx] (e) at (6,-2) {$e$};

		% arcos justos (apenas alguns)
		\draw[tight] (r) -- node[costB, above left] {0} (a);
		\draw[tight] (c) to[bend left=15] node[costB, right] {0} (d);
		\draw[tight] (b) -- node[costB, below] {0} (e);
		\draw[tight] (r) -- node[costB, below left] {0} (b);
		% arcos não justos
		\draw[loose] (r) .. controls (2,3.5) and (5,3.5) .. node[costG, above] {6} (c);  % 7-1-2 = 4
		\draw[loose] (a) -- node[costG, right] {3} (d);  % 4-2 = 2
		\draw[loose] (a) -- node[costG, above] {4} (c);
		% 3-2 = 1 (ainda não é justo!)
		\draw[loose] (b) to[bend right=15] node[costG, left] {3} (a);  % 5-2 = 3
		\draw[tight] (d) to[bend left=15] node[costB, left] {0} (c);  % 1-1 = 0 (forma ciclo!)
		\draw[loose] (d) -- node[costG, right] {1} (e);  % 3-1 = 2
		\draw[loose] (c) .. controls (7.5,2.5) and (7.5,-2.5) .. node[costG, right] {4} (e);  % 6-1-2 = 3
	\end{tikzpicture}
	\caption{Dígrafo após a primeira iteração. Os arcos justos (custo 0) são: \((r,a)\), \((r,b)\),
		\((b,e)\), \((c,d)\) e \((d,c)\). Todos os vértices não-raiz possuem arcos justos
		entrando: \(a\) tem \((r,a)\), \(b\) tem \((r,b)\), \(e\) tem \((b,e)\), e o conjunto
		\(\{c,d\}\) tem \((a,c)\) (além do ciclo interno). Os arcos \((c,d)\) e \((d,c)\)
		formam um ciclo justo.}
	\label{fig:frank-iter1-result}
\end{figure}

Se esses arcos de custo zero formam uma \(r\)-arborescência, o algoritmo termina. Caso contrário, identificamos novamente os subconjuntos minimais sem arcos de custo zero entrando neles.

No exemplo da Figura~\ref{fig:frank-iter1-result}, os arcos justos não formam uma \(r\)-arborescência, pois nem todos os vértices são alcançáveis a partir de \(r\) pelos arcos justos e o conjunto \(\{c,d\}\) forma um ciclo com dois arcos justos entre \(c\) e \(d\). Como não existem arcos justos entrando em \(\{c,d\}\), esse conjunto é um subconjunto minimal. Além disso, nesse caso forma-se uma componente fortemente conexa entre \(c\) e \(d\). Uma componente fortemente conexa (SCC) é um subconjunto maximal de vértices em que cada vértice é alcançável a partir de qualquer outro vértice do mesmo subconjunto.

\begin{figure}[H]
	\centering
	\begin{tikzpicture}[>=Stealth, scale=1.1]
		\tikzset{
			vtx/.style={circle, draw,fill=blue!8, thick, inner sep=1.2pt, minimum size=7mm},
			tight/.style={->, very thick, draw=blue!70},
			loose/.style={->, semithick, draw=black!35},
			costB/.style={font=\small, fill=white, inner sep=1.5pt, text=blue!70},
			costG/.style={font=\small, fill=white, inner sep=1.5pt, text=black!50}
		}

		\node[vtx] (r) at (0,0) {$r$};
		\node[vtx] (a) at (3,2) {$a$};
		\node[vtx] (b) at (3,-2) {$b$};
		\node[vtx] (c) at (6,2) {$c$};
		\node[vtx] (d) at (6,0) {$d$};
		\node[vtx] (e) at (6,-2) {$e$};

		% arcos justos
		\draw[tight] (r) -- node[costB, above left] {0} (a);
		\draw[tight] (r) -- node[costB, below left] {0} (b);
		\draw[loose] (a) -- node[costG, above] {4} (c);
		\draw[tight] (c) to[bend left=15] node[costB, right] {0} (d);
		\draw[tight] (d) to[bend left=15] node[costB, left] {0} (c);
		\draw[tight] (b) -- node[costB, below] {0} (e);

		% arcos não justos (mais tênues)
		\draw[loose, opacity=0.3] (r) .. controls (2,3.5) and (5,3.5) .. node[costG, above, opacity=0.5] {6} (c);
		\draw[loose, opacity=0.3] (a) -- node[costG, right, opacity=0.5] {3} (d);
		\draw[loose, opacity=0.3] (b) to[bend right=15] node[costG, left, opacity=0.5] {3} (a);
		\draw[loose, opacity=0.3] (d) -- node[costG, right, opacity=0.5] {1} (e);
		\draw[loose, opacity=0.3] (c) .. controls (7.5,2.5) and (7.5,-2.5) .. node[costG, right, opacity=0.5] {2} (e);

		% Destacar as SCCs
		% SCC da raiz + alcançáveis por arcos justos
		\draw[green!60, ultra thick, dashed, rounded corners] (-0.6,-0.6) rectangle (3.6,2.6);
		\node[green!70!black, font=\small\bfseries, above] at (1.5,2.9) {$\{r,a\}$};

		\draw[green!60, ultra thick, dashed, rounded corners] (2.4,-2.6) rectangle (3.6,-1.4);
		\node[green!70!black, font=\small\bfseries, below] at (3,-2.9) {$\{b\}$};

		\draw[green!60, ultra thick, dashed, rounded corners] (5.4,-2.6) rectangle (6.6,-1.4);
		\node[green!70!black, font=\small\bfseries, below] at (6,-2.9) {$\{e\}$};

		% SCC do ciclo c-d - forma componente não-trivial (ciclo)
		\draw[orange!70, ultra thick, dashed, rounded corners] (5.3,2.6) rectangle (6.7,-0.6);
		\node[orange!70, font=\small\bfseries, right] at (6.9,1.2) {$\{c,d\}$};
		\node[orange!70, font=\small, right] at (6.9,0.6) {\textbf{minimal}};
		\node[orange!70, font=\scriptsize, right] at (6.9,0.0) {(ciclo justo)};

		% Seta indicando o ciclo
		\draw[->, orange!70, ultra thick, bend left=45] (6.3,2.3) to (6.3,0.3);
		\draw[->, orange!70, ultra thick, bend left=45] (5.7,0.3) to (5.7,2.3);
	\end{tikzpicture}
	\caption{Identificação de componentes fortemente conexas nos arcos justos após a primeira
		iteração. As componentes triviais \(\{r,a\}\), \(\{b\}\) e \(\{e\}\) estão em verde.
		A componente não-trivial \(\{c,d\}\) (em laranja) forma um ciclo justo com os arcos
		\((c,d)\) e \((d,c)\), e é identificada como \textbf{minimal} para a próxima iteração.
		Os arcos justos internos ao ciclo estão destacados, indicando que \(\{c,d\}\) deve
		ser tratado como uma unidade no processo de contração.}
	\label{fig:frank-scc-minimal}
\end{figure}

O algoritmo então procede escolhendo um subconjunto minimal (neste caso, \(\{c,d\}\)) e repetindo o processo de redução de custos para esse conjunto. Calculamos \(\delta(\{c,d\})\) como o menor custo entre os arcos que entram em \(c\) ou \(d\) vindos de fora do conjunto \(\{c,d\}\). No exemplo, os arcos que entram em \(\{c,d\}\) são \((r,c)\) com custo 6, \((a,c)\) com custo 4 e \((a,d)\) com custo 3. Portanto, \(\delta(\{c,d\}) = \min\{6, 4, 3\} = 3\). Subtraímos esse valor dos arcos que entram em \(c\) e \(d\), tornando \((a,d)\) um arco justo.

\begin{figure}[H]
	\centering
	\begin{tikzpicture}[>=Stealth, scale=0.95]
		\tikzset{
			vtx/.style={circle, draw,fill=blue!8, thick, inner sep=1.2pt, minimum size=7mm},
			vtxH/.style={circle, draw=orange!70, fill=orange!15, thick, inner sep=1.2pt, minimum size=7mm},
			tight/.style={->, very thick, draw=blue!70},
			loose/.style={->, semithick, draw=black!35},
			arcH/.style={->, ultra thick, draw=orange!70},
			costB/.style={font=\small, fill=white, inner sep=1.5pt, text=blue!70},
			costG/.style={font=\small, fill=white, inner sep=1.5pt, text=black!50},
			costO/.style={font=\small, fill=white, inner sep=1.5pt, text=orange!70, font=\small\bfseries}
		}

		% Antes da redução de {c,d}
		\begin{scope}
			\node[font=\bfseries, above] at (3, 3.8) {Antes: redução de $\{c,d\}$};

			\node[vtx] (r1) at (0,0) {$r$};
			\node[vtx] (a1) at (3,2) {$a$};
			\node[vtx] (b1) at (3,-2) {$b$};
			\node[vtxH] (c1) at (6,2) {$c$};
			\node[vtxH] (d1) at (6,0) {$d$};
			\node[vtx] (e1) at (6,-2) {$e$};

			% Arcos justos já existentes (azul)
			\draw[tight] (r1) -- node[costB, above left] {0} (a1);
			\draw[tight] (r1) -- node[costB, below left] {0} (b1);

			\draw[tight] (b1) -- node[costB, below] {0} (e1);
			\draw[tight] (c1) to[bend left=15] node[costB, right] {0} (d1);
			\draw[tight] (d1) to[bend left=15] node[costB, left] {0} (c1);

			% Arcos entrando em {c,d} - destacados em laranja
			\draw[arcH] (r1) .. controls (1,3.5) and (5,3.5) .. node[costO, above] {6} (c1);
			\draw[arcH] (a1) -- node[costO, right] {3} (d1);
			\draw[arcH] (a1) -- node[costO, above] {4} (c1);

			% Outros arcos não justos
			\draw[loose] (b1) to[bend right=15] node[costG, left] {3} (a1);
			\draw[loose] (d1) -- node[costG, right] {1} (e1);
			\draw[loose] (c1) .. controls (7.5,2.5) and (7.5,-2.5) .. node[costG, right] {2} (e1);


			% Destaque do conjunto {c,d}
			\draw[orange!70, ultra thick, dashed, rounded corners] (5.3,2.6) rectangle (6.7,-0.6);
			\node[orange!70, font=\small] at (3, -3.2) {$\delta(\{c,d\}) = \min\{6, 3\} = 3$};
		\end{scope}

		% Depois da redução de {c,d}
		\begin{scope}[xshift=9.5cm]
			\node[font=\bfseries, above] at (3, 3.8) {Após redução de $\delta(\{c,d\})$};

			\node[vtx] (r2) at (0,0) {$r$};
			\node[vtx] (a2) at (3,2) {$a$};
			\node[vtx] (b2) at (3,-2) {$b$};
			\node[vtxH] (c2) at (6,2) {$c$};
			\node[vtxH] (d2) at (6,0) {$d$};
			\node[vtx] (e2) at (6,-2) {$e$};

			% Arcos justos já existentes (azul)
			\draw[tight] (r2) -- node[costB, above left] {0} (a2);
			\draw[tight] (r2) -- node[costB, below left] {0} (b2);
			\draw[tight] (b2) -- node[costB, below] {0} (e2);
			\draw[tight] (c2) to[bend left=15] node[costB, right] {0} (d2);
			\draw[tight] (d2) to[bend left=15] node[costB, left] {0} (c2);

			% Arco (a,d) torna-se justo (novo)
			\draw[tight] (a2) -- node[costB, right] {0} (d2);

			% Arco (r,c) reduzido mas não justo
			\draw[arcH] (r2) .. controls (1,3.5) and (5,3.5) .. node[costO, above] {3} (c2);
			\draw[arcH] (a2) -- node[costO, above] {1} (c2);

			% Outros arcos não justos
			\draw[loose] (b2) to[bend right=15] node[costG, left] {3} (a2);
			\draw[loose] (d2) -- node[costG, right] {1} (e2);
			\draw[loose] (c2) .. controls (7.5,2.5) and (7.5,-2.5) .. node[costG, right] {2} (e2);

			% Destaque do conjunto {c,d}
			\draw[orange!70, ultra thick, dashed, rounded corners] (5.3,2.6) rectangle (6.7,-0.6);
			\node[blue!70, font=\small] at (3, -3.2) {$(a,d)$ torna-se \textbf{justo}};
		\end{scope}
	\end{tikzpicture}
	\caption{Redução de custos para o subconjunto minimal \(\{c,d\}\). À esquerda, antes da
		redução: os arcos entrando em \(\{c,d\}\) vindos de fora são \((r,c)\) com custo 6, \((a,d)\) com custo 3 e \((a,c)\) com custo 4, destacados em laranja. Calculamos \(\delta(\{c,d\}) = 3\)
		e subtraímos esse valor. À direita, após a redução: \((a,d)\) torna-se justo (custo 0), \((r,c)\) tem custo reduzido para 3 e \((a,c)\) tem custo reduzido para 1. O conjunto \(\{c,d\}\) está destacado em laranja para enfatizar que é tratado como uma unidade.}
	\label{fig:frank-reducao-cd}
\end{figure}

Agora, não existem mais subconjuntos minimais sem arcos justos entrando neles, porém os arcos justos não formam uma \(r\)-arborescência, pois existe um ciclo justo entre \(c\) e \(d\). Nesse ponto, o algoritmo procede para a fase de contração, onde o ciclo justo formado pelos arcos \((c,d)\) e \((d,c)\) é contraído em um único vértice. Podemos estender essa ideia de contração de ciclos para abranger a contração de qualquer componente fortemente conexa (SCC) formada por arcos justos. No exemplo, a SCC \(\{c,d\}\) é contraída em um novo vértice \(x_C\). Todos os arcos que entravam em \(c\) ou \(d\) agora entram em \(x_C\), e todos os arcos que saíam de \(c\) ou \(d\) agora saem de \(x_C\). Os custos dos arcos são mantidos conforme estavam antes da contração.

A Figura~\ref{fig:frank-contracao-ciclo} ilustra essa contração.

\begin{figure}[H]
	\centering
	\begin{tikzpicture}[>=Stealth, scale=0.95]
		\tikzset{
			vtx/.style={circle, draw,fill=blue!8, thick, inner sep=1.2pt, minimum size=7mm},
			vtxH/.style={circle, draw=red!70, fill=red!10, thick, inner sep=1.2pt, minimum size=7mm},
			vtxC/.style={circle, draw=red!70, fill=red!10, thick, inner sep=1.2pt, minimum size=9mm},
			tight/.style={->, very thick, draw=blue!70},
			cycle/.style={->, ultra thick, draw=red!70},
			loose/.style={->, semithick, draw=black!35},
			costB/.style={font=\small, fill=white, inner sep=1.5pt, text=blue!70},
			costR/.style={font=\small, fill=white, inner sep=1.5pt, text=red!70},
			costG/.style={font=\small, fill=white, inner sep=1.5pt, text=black!50}
		}

		% Antes da contração
		\begin{scope}
			\node[font=\bfseries, above] at (3, 3.8) {Antes: dígrafo com ciclo justo};

			\node[vtx] (r1) at (0,0) {$r$};
			\node[vtx] (a1) at (3,2) {$a$};
			\node[vtx] (b1) at (3,-2) {$b$};
			\node[vtxH] (c1) at (6,2) {$c$};
			\node[vtxH] (d1) at (6,0) {$d$};
			\node[vtx] (e1) at (6,-2) {$e$};

			% Arcos justos normais
			\draw[tight] (r1) -- node[costB, above left] {0} (a1);
			\draw[tight] (r1) -- node[costB, below left] {0} (b1);
			\draw[tight] (a1) -- node[costB, right] {0} (d1);
			\draw[tight] (b1) -- node[costB, below] {0} (e1);

			% Ciclo justo destacado em vermelho
			\draw[cycle] (c1) to[bend left=15] node[costR, right] {0} (d1);
			\draw[cycle] (d1) to[bend left=15] node[costR, left] {0} (c1);

			% Arcos não justos
			\draw[loose] (r1) .. controls (1,3.5) and (5,3.5) .. node[costG, above] {3} (c1);
			\draw[loose] (a1) -- node[costG, above] {1} (c1);
			\draw[loose] (b1) to[bend right=15] node[costG, left] {3} (a1);
			\draw[loose] (d1) -- node[costG, right] {1} (e1);
			\draw[loose] (c1) .. controls (7.5,2.5) and (7.5,-2.5) .. node[costG, right] {2} (e1);

			% Destaque do ciclo
			\draw[red!70, ultra thick, dashed, rounded corners] (5.3,2.6) rectangle (6.7,-0.6);
			\node[red!70, font=\small\bfseries, below] at (6,-0.9) {Ciclo};
		\end{scope}

		% Seta de transformação
		\node[font=\Large\bfseries] at (9.5, 0) {$\Rightarrow$};

		% Depois da contração
		\begin{scope}[xshift=11cm]
			\node[font=\bfseries, above] at (3, 3.8) {Após contração: $\{c,d\} \to x_C$};

			\node[vtx] (r2) at (0,0) {$r$};
			\node[vtx] (a2) at (3,1.5) {$a$};
			\node[vtx] (b2) at (3,-1.5) {$b$};
			\node[vtxC] (xc2) at (6,0.75) {$x_C$};
			\node[vtx] (e2) at (6,-1.5) {$e$};

			% Arcos justos
			\draw[tight] (r2) -- node[costB, above left] {0} (a2);
			\draw[tight] (r2) -- node[costB, below left] {0} (b2);
			\draw[tight] (a2) -- node[costB, right] {0} (xc2);
			\draw[tight] (b2) -- node[costB, below] {0} (e2);

			% Arcos não justos
			\draw[loose] (r2) .. controls (1,3) and (5,3) .. node[costG, above] {3} (xc2);
			\draw[loose] (b2) to[bend right=12] node[costG, left] {3} (a2);
			\draw[loose] (xc2) -- node[costG, right] {1} (e2);

			% Anotação
			\node[red!70, font=\small, align=center] at (3,-3.2) {Supervértice $x_C$\\representa $\{c,d\}$};
		\end{scope}
	\end{tikzpicture}
	\caption{Contração do ciclo justo \(\{c,d\}\). À esquerda, o dígrafo após as reduções de
		custo mostra o ciclo justo formado pelos arcos \((c,d)\) e \((d,c)\) (em vermelho).
		À direita, o dígrafo contraído onde os vértices \(c\) e \(d\) são substituídos pelo
		supervértice \(x_C\). Os arcos que entravam ou saíam do ciclo são redirecionados para
		\(x_C\). Note que os arcos justos agora formam uma \(r\)-arborescência no dígrafo contraído.}
	\label{fig:frank-contracao-ciclo}
\end{figure}

Após a contração, os arcos justos formam uma \(r\)-arborescência no dígrafo contraído.

Assim termina a fase 1 do algoritmo de Frank. A fase 2 envolve a expansão do supervértice \(x_C\) de volta para o ciclo \(\{c,d\}\) e a reconstrução da \(r\)-arborescência ótima no dígrafo original. Isso é feito selecionando o arco que entra em \(x_C\) na arborescência do dígrafo contraído e substituindo-o pelo arco correspondente que entra em \(c\) ou \(d\) no dígrafo original, além dos arcos justos internos ao ciclo, exceto o arco que entra no vértice escolhido.

\subsection{Identificação de conjuntos minimais}
\label{sec:identificacao-minimais}

Um aspecto fundamental do algoritmo de Frank é a identificação correta de \emph{conjuntos minimais}.
Um conjunto \(X \subseteq V \setminus \{r\}\) é dito \textbf{minimal} se:
\begin{enumerate}\setlength{\itemsep}{2pt}
	\item Não há arcos justos entrando em \(X\) (ou seja, nenhum arco \((u,v)\) com \(u \notin X\) e \(v \in X\) possui custo reduzido zero).
	\item Para qualquer subconjunto próprio \(Y \subset X\), existe ao menos um arco justo entrando em \(Y\).
\end{enumerate}

A segunda condição garante a \emph{minimalidade}: não podemos encontrar um subconjunto menor que também não tenha arcos justos entrando. Essa propriedade é crucial para a corretude do algoritmo, pois escolher um conjunto não-minimal poderia levar a uma solução subótima.

\paragraph{Componentes fortemente conexas e fontes.} O algoritmo utiliza componentes fortemente conexas (SCCs) formadas pelos arcos justos para identificar eficientemente os conjuntos minimais. Quando construímos o grafo de condensação das SCCs:
\begin{itemize}\setlength{\itemsep}{2pt}
	\item Cada nó do grafo de condensação representa uma SCC do grafo original formado pelos arcos justos.
	\item Um arco no grafo de condensação conecta duas SCCs se existe um arco justo no grafo original indo de um vértice da primeira SCC para um vértice da segunda.
	\item O grafo de condensação é sempre acíclico (DAG).
\end{itemize}

Uma \textbf{fonte} no grafo de condensação é uma SCC sem arcos justos entrando. Essas fontes correspondem exatamente aos conjuntos minimais que buscamos:
\begin{itemize}\setlength{\itemsep}{2pt}
	\item \textbf{Sem arcos justos entrando:} Por definição de fonte, não há arcos no grafo de condensação entrando naquela SCC, o que significa que não há arcos justos do grafo original entrando em nenhum vértice da SCC.
	\item \textbf{Maximalidade da componente:} Como trabalhamos com SCCs, qualquer vértice dentro da componente é alcançável a partir de qualquer outro usando arcos justos. Isso garante que não há subconjunto próprio sem arcos justos entrando (pois dentro da componente, todos os vértices são conectados por arcos justos).
\end{itemize}

\paragraph{Múltiplas escolhas possíveis.} Em uma iteração do algoritmo, pode haver múltiplas fontes no grafo de condensação (excluindo a componente que contém a raiz). Qualquer uma dessas fontes pode ser escolhida como conjunto minimal para elevação de potenciais naquela iteração. A escolha específica não afeta a corretude do algoritmo, apenas a ordem em que os arcos se tornam justos.

Para ilustrar, considere um dígrafo simples com raiz \(r_0\) conectada a três vértices \(a\), \(b\), e \(c\) através de arcos com custos 2, 3, e 2 respectivamente. Após a inicialização, todas as três componentes \(\{a\}\), \(\{b\}\), \(\{c\}\) são fontes (cada uma sem arcos justos entrando). O algoritmo pode escolher qualquer uma delas:
\begin{itemize}\setlength{\itemsep}{2pt}
	\item Se escolhermos \(\{a\}\): elevamos seu potencial por \(\Delta(\{a\}) = 2\), tornando \((r_0, a)\) justo.
	\item Se escolhermos \(\{b\}\): elevamos seu potencial por \(\Delta(\{b\}) = 3\), tornando \((r_0, b)\) justo.
	\item Se escolhermos \(\{c\}\): elevamos seu potencial por \(\Delta(\{c\}) = 2\), tornando \((r_0, c)\) justo.
\end{itemize}

Em cada caso, após a elevação, a componente escolhida deixa de ser uma fonte (pois agora possui um arco justo entrando). O algoritmo continua processando as fontes restantes nas iterações subsequentes. A ordem de processamento não afeta o custo total da arborescência final, pois todas as elevações são necessárias e determinadas univocamente pelos custos dos arcos.

\begin{figure}[H]
	\centering
	\begin{tikzpicture}[>=Stealth, scale=1.0]
		\tikzset{
			vtx/.style={circle, draw, fill=blue!8, thick, inner sep=1.2pt, minimum size=7mm},
			vtxRoot/.style={circle, draw, fill=red!15, thick, inner sep=1.2pt, minimum size=7mm},
			vtxSource/.style={circle, draw=orange!70, fill=orange!15, thick, inner sep=1.2pt, minimum size=7mm},
			arc/.style={->, thick, draw=gray!60},
			cost/.style={font=\scriptsize, fill=white, inner sep=1pt}
		}

		% Dígrafo inicial
		\begin{scope}
			\node[font=\bfseries, above] at (2, 3.2) {Estado inicial: múltiplas fontes};

			\node[vtxRoot] (r0) at (2, 2) {$r_0$};
			\node[vtxSource] (a) at (0, 0) {$a$};
			\node[vtxSource] (b) at (2, 0) {$b$};
			\node[vtxSource] (c) at (4, 0) {$c$};

			\draw[arc] (r0) -- node[cost, left] {2} (a);
			\draw[arc] (r0) -- node[cost, right] {3} (b);
			\draw[arc] (r0) -- node[cost, right] {2} (c);

			\node[orange!70!black, font=\small, align=center] at (2, -1.2) {Três fontes: $\{a\}$, $\{b\}$, $\{c\}$\\Qualquer uma pode ser processada};
		\end{scope}

		% Seta
		\draw[->, ultra thick, gray!60] (5.5, 1) -- node[above, font=\small, align=center] {escolhe\\$\{a\}$} (6.5, 1);

		% Após processar {a}
		\begin{scope}[xshift=7.5cm]
			\node[font=\bfseries, above] at (2, 3.2) {Após processar $\{a\}$};

			\node[vtxRoot] (r0b) at (2, 2) {$r_0$};
			\node[vtx] (ab) at (0, 0) {$a$};
			\node[vtxSource] (bb) at (2, 0) {$b$};
			\node[vtxSource] (cb) at (4, 0) {$c$};

			\draw[arc, blue!70, ultra thick] (r0b) -- node[cost, left, fill=blue!10] {0} (ab);
			\draw[arc] (r0b) -- node[cost, right] {3} (bb);
			\draw[arc] (r0b) -- node[cost, right] {2} (cb);

			\node[blue!70!black, font=\small, align=center] at (2, -1.2) {$(r_0, a)$ justo\\Fontes restantes: $\{b\}$, $\{c\}$};
		\end{scope}
	\end{tikzpicture}
	\caption{Exemplo de múltiplas fontes disponíveis para processamento. À esquerda, o estado
		inicial possui três componentes \(\{a\}\), \(\{b\}\), \(\{c\}\) (em laranja) que são fontes
		no grafo de condensação. Qualquer uma pode ser escolhida. À direita, após escolher e
		processar \(\{a\}\) (elevando seu potencial por \(\Delta(\{a\}) = 2\)), o arco \((r_0, a)\)
		torna-se justo (em azul). Agora \(\{a\}\) deixa de ser fonte e as fontes restantes são
		\(\{b\}\) e \(\{c\}\). A ordem de processamento não afeta a arborescência ótima final.}
	\label{fig:frank-multiplas-fontes}
\end{figure}

No exemplo da Figura~\ref{fig:frank-iter1-result}, após a primeira iteração de redução, temos os vértices \(\{a\}\), \(\{b\}\), \(\{e\}\) que são componentes triviais (cada um forma sua própria SCC) e todos possuem arcos justos entrando. Porém, o conjunto \(\{c,d\}\) forma uma SCC não-trivial (um ciclo) sem arcos justos entrando, constituindo uma fonte no grafo de condensação e, portanto, um conjunto minimal. Não poderíamos escolher apenas \(\{c\}\) ou apenas \(\{d\}\) isoladamente, pois esses subconjuntos já possuem arcos justos entrando (os arcos do ciclo interno).

\subsection{Por que a escolha do conjunto minimal é importante}
\label{sec:escolha-minimal}

Escolher um conjunto que não seja minimal pode violar a otimalidade da solução. Para entender isso, considere a interpretação dual do algoritmo: cada vez que elevamos o potencial de um conjunto \(X\) por \(\Delta(X)\), estamos aumentando a variável dual correspondente. As condições de folga complementar da programação linear dual exigem que:
\begin{itemize}\setlength{\itemsep}{2pt}
	\item Se um arco \((u,v)\) está na arborescência ótima, então seu custo reduzido deve ser zero.
	\item Se um conjunto \(X\) teve seu potencial elevado (\(\Delta(X) > 0\)), então exatamente um arco da arborescência deve cruzar a fronteira de \(X\).
\end{itemize}

Se escolhêssemos um conjunto não-minimal \(X\) (isto é, um conjunto que contém um subconjunto próprio \(Y \subset X\) que também não tem arcos justos entrando), poderíamos elevar os potenciais de forma redundante, criando folga nas restrições duais. Isso pode levar a uma solução que satisfaz as restrições mas não atinge o valor ótimo.

Ao garantir que sempre escolhemos conjuntos minimais, mantemos a propriedade de que a sequência de elevações de potenciais constrói progressivamente uma solução dual ótima, que por sua vez guia a construção de uma arborescência primal ótima através dos arcos justos.

\subsection{Arcos justos podem conter ``sujeira''}

Um aspecto sutil mas importante do algoritmo é que o conjunto \(A_0\) de arcos justos obtido na Fase~1 pode conter \textbf{mais arcos do que necessário} para formar uma arborescência. Especificamente:
\begin{itemize}\setlength{\itemsep}{2pt}
	\item Uma \(r\)-arborescência em um dígrafo com \(n\) vértices contém exatamente \(n-1\) arcos.
	\item O conjunto \(A_0\) pode conter ciclos formados por arcos justos.
	\item Mesmo sem ciclos, \(A_0\) pode conter múltiplos arcos entrando em um mesmo vértice.
\end{itemize}

Essa ``sujeira'' não é um problema --- é uma característica do algoritmo. Durante a Fase~1, todos os arcos em \(A_0\) são garantidamente parte de \emph{alguma} arborescência ótima (não necessariamente a mesma), mas apenas um subconjunto de \(A_0\) formará a arborescência específica que o algoritmo constrói.

\paragraph{Contração de ciclos.} Quando \(A_0\) contém um ciclo, a operação de contração (ilustrada na Figura~\ref{fig:frank-contracao-ciclo}) é necessária para eliminar essa ambiguidade. Ao contrair o ciclo em um supervértice e resolver recursivamente, o algoritmo efetivamente escolhe quais arcos do ciclo fazer parte da solução final. Durante a expansão, apenas \(|C|-1\) arcos do ciclo contraído \(C\) são incluídos na arborescência (onde \(|C|\) é o número de vértices no ciclo), descartando exatamente um arco --- aquele que entra no vértice por onde a arborescência alcança o ciclo.

\paragraph{Construção incremental.} Mesmo quando \(A_0\) não contém ciclos, a Fase~2 do algoritmo constrói a arborescência \emph{incrementalmente}, adicionando arcos de \(A_0\) um por vez, garantindo que cada vértice não-raiz receba exatamente um arco de entrada. O algoritmo sempre escolhe um arco \((u,v) \in A_0\) tal que \(u\) já está na arborescência parcial e \(v\) ainda não está. Esse processo naturalmente seleciona um subconjunto de \(A_0\) sem ambiguidades, descartando arcos "extras".

A presença dessa sujeira demonstra que a Fase~1 do algoritmo de Frank não constrói diretamente a arborescência, mas sim um \emph{certificado de otimalidade} através dos arcos justos e potenciais duais. A Fase~2 então utiliza esse certificado para extrair uma arborescência ótima específica.

\subsection{Evolução das componentes fortemente conexas}

Durante a execução da Fase~1, as componentes fortemente conexas (SCCs) formadas pelos arcos justos evoluem de forma dinâmica e sistemática. Compreender essa evolução é essencial para entender por que o algoritmo termina corretamente.

\paragraph{Estado inicial.} No início do algoritmo, \(A_0 = \emptyset\) (nenhum arco justo), portanto cada vértice forma sua própria SCC trivial. O grafo de condensação tem \(n\) nós (um para cada vértice original), e todas as SCCs exceto a raiz são fontes.

\paragraph{Após cada elevação de potenciais.} Quando escolhemos uma fonte (conjunto minimal) \(X\) e elevamos seus potenciais por \(\Delta(X)\):
\begin{enumerate}\setlength{\itemsep}{2pt}
	\item Ao menos um arco entrando em \(X\) torna-se justo (aquele com custo reduzido original igual a \(\Delta(X)\)).
	\item Esse novo arco justo conecta \(X\) a alguma outra componente pré-existente no grafo de arcos justos.
	\item As SCCs podem se \textbf{fundir}: se o novo arco justo cria um caminho bidirecional entre duas SCCs anteriormente separadas, elas se tornam uma única SCC maior.
\end{enumerate}

\paragraph{Progressão monotônica.} A cada iteração, o número de SCCs no grafo de arcos justos diminui (ou permanece igual):
\begin{itemize}\setlength{\itemsep}{2pt}
	\item No melhor caso, múltiplas SCCs se fundem em uma única componente maior.
	\item No pior caso, uma SCC deixa de ser fonte (passa a ter arcos justos entrando) mas não se funde com outras.
	\item \textbf{Importante:} O número de SCCs nunca aumenta, pois adicionamos arcos mas nunca os removemos.
\end{itemize}

\paragraph{Condição de término.} O algoritmo termina quando existe exatamente \textbf{uma fonte} no grafo de condensação das SCCs formadas pelos arcos justos. Essa condição significa:
\begin{itemize}\setlength{\itemsep}{2pt}
	\item A fonte única é a SCC que contém a raiz \(r\).
	\item Todas as outras SCCs possuem arcos justos entrando (não são fontes).
	\item Todo vértice \(v \neq r\) possui ao menos um arco justo entrando nele.
\end{itemize}

Quando essa condição é satisfeita, o grafo \((V, A_0)\) formado pelos arcos justos contém uma \(r\)-arborescência, pois:
\begin{enumerate}\setlength{\itemsep}{2pt}
	\item Todo vértice não-raiz é alcançável a partir de \(r\) através de arcos justos (consequência de haver apenas uma fonte).
	\item Existe uma seleção de \(n-1\) arcos de \(A_0\) que formam uma arborescência (possivelmente com sujeira adicional em \(A_0\)).
\end{enumerate}

\paragraph{Exemplo visual.} Na Figura~\ref{fig:frank-scc-minimal}, após a primeira iteração de reduções, o grafo de condensação possui as seguintes SCCs:
\begin{itemize}\setlength{\itemsep}{2pt}
	\item \(\{r, a\}\): componente contendo a raiz, alcançável via arco justo \((r,a)\).
	\item \(\{b\}\): componente trivial, alcançável via arco justo \((r,b)\).
	\item \(\{e\}\): componente trivial, alcançável via arco justo \((b,e)\).
	\item \(\{c, d\}\): componente não-trivial (ciclo justo interno), \textbf{fonte} (sem arcos justos entrando).
\end{itemize}

O grafo de condensação tem um arco de \(\{r,a\}\) para \(\{b\}\), de \(\{b\}\) para \(\{e\}\), mas nenhum arco entrando em \(\{c,d\}\), que portanto é uma fonte e representa o conjunto minimal a ser processado na próxima iteração. Após elevar os potenciais de \(\{c,d\}\) (Figura~\ref{fig:frank-reducao-cd}), um novo arco justo \((a,d)\) é criado, conectando \(\{c,d\}\) à componente \(\{r,a\}\). Nesse momento, todas as SCCs exceto a que contém \(r\) possuem arcos justos entrando, satisfazendo a condição de término.

Essa evolução garante que o algoritmo progride de forma finita: como cada iteração processa ao menos uma fonte (exceto a raiz) e o número de SCCs é limitado por \(n\), o algoritmo termina em no máximo \(O(n)\) iterações da Fase~1.

\begin{figure}[H]
	\centering
	\begin{tikzpicture}[>=Stealth, scale=0.85]
		\tikzset{
			scc/.style={rectangle, draw, fill=blue!10, thick, rounded corners, inner sep=4pt, minimum width=15mm, minimum height=10mm},
			sccRoot/.style={rectangle, draw=green!70, fill=green!10, thick, rounded corners, inner sep=4pt, minimum width=15mm, minimum height=10mm},
			sccSource/.style={rectangle, draw=orange!70, fill=orange!15, thick, rounded corners, inner sep=4pt, minimum width=15mm, minimum height=10mm},
			arcCond/.style={->, very thick, draw=blue!60},
			costG/.style={font=\scriptsize, fill=white, inner sep=1pt}
		}

		% Estado 1: Após primeira iteração
		\begin{scope}
			\node[font=\bfseries, above] at (3, 3.5) {Após 1ª iteração};

			% SCCs
			\node[sccRoot] (ra1) at (1, 2) {$\{r,a\}$};
			\node[scc] (b1) at (1, 0) {$\{b\}$};
			\node[scc] (e1) at (1, -2) {$\{e\}$};
			\node[sccSource] (cd1) at (5, 1) {$\{c,d\}$};

			% Arcos do grafo de condensação
			\draw[arcCond] (ra1) -- (b1);
			\draw[arcCond] (b1) -- (e1);

			% Anotações
			\node[green!70!black, font=\scriptsize, align=center, below] at (1, -3) {Verde: contém raiz};
			\node[orange!70!black, font=\scriptsize, align=center, below] at (5, -1) {Laranja: fonte\\(sem arcos entrando)};

			\draw[orange!70, ultra thick, rounded corners, dashed] (4.2, 2) rectangle (5.8, 0);
		\end{scope}

		% Seta de transformação
		\draw[->, ultra thick, gray!60] (6.5, 0.5) -- node[above, font=\small] {eleva $\{c,d\}$} (7.5, 0.5);

		% Estado 2: Após segunda iteração
		\begin{scope}[xshift=8.5cm]
			\node[font=\bfseries, above] at (3, 3.5) {Após 2ª iteração};

			% SCCs (agora todas conectadas)
			\node[sccRoot] (racd2) at (3, 2) {$\{r,a,c,d\}$};
			\node[scc] (b2) at (1, 0) {$\{b\}$};
			\node[scc] (e2) at (1, -2) {$\{e\}$};

			% Arcos do grafo de condensação
			\draw[arcCond] (racd2) -- (b2);
			\draw[arcCond] (b2) -- (e2);
			\draw[arcCond] (racd2) to[bend left=20] (e2);

			% Anotação
			\node[green!70!black, font=\scriptsize, align=center, below] at (3, -3) {Uma única fonte\\(contém raiz)\\$\Rightarrow$ Término da Fase~1};
		\end{scope}
	\end{tikzpicture}
	\caption{Evolução do grafo de condensação durante a Fase~1 do algoritmo de Frank.
		À esquerda: após a primeira iteração, temos 4 SCCs formadas pelos arcos justos.
		A SCC \(\{r,a\}\) (em verde) contém a raiz. A SCC \(\{c,d\}\) (em laranja) é uma
		fonte (sem arcos justos entrando) e portanto um conjunto minimal. À direita: após
		elevar os potenciais de \(\{c,d\}\), o arco \((a,d)\) torna-se justo, conectando
		\(\{c,d\}\) a \(\{r,a\}\). As SCCs se fundem em \(\{r,a,c,d\}\). Agora existe apenas
		uma fonte (a que contém \(r\)), satisfazendo a condição de término da Fase~1.}
	\label{fig:frank-condensation-evolution}
\end{figure}

\section{Descrição do algoritmo}
\label{sec:descricao-algoritmo}

Apresentamos agora uma descrição formal do algoritmo de András Frank.

O algoritmo opera em duas fases. A Fase~1 reduz progressivamente os custos dos arcos,
criando arcos justos (de custo zero) através da identificação de subconjuntos minimais.
A Fase~2 constrói a arborescência a partir dos arcos justos, usando contração e expansão
quando necessário.

A diferença fundamental em relação ao Chu--Liu--Edmonds está na Fase~1:
\begin{itemize}
	\item \textbf{Chu--Liu:} Para cada vértice \(v\), subtrai o menor custo entrando em \(v\).
	      Processa vértice a vértice, uma vez.
	\item \textbf{Frank:} A cada iteração, identifica componentes fortemente conexas no grafo
	      de arcos justos. Para cada componente sem arcos justos entrando (subconjunto minimal \(X\)),
	      subtrai \(\delta(X)\) de todos os arcos entrando em \(X\). Repete até todos os vértices
	      terem arcos justos entrando.
\end{itemize}

A Fase~2 é idêntica em ambos os algoritmos: se há ciclos nos arcos justos, contrai,
resolve recursivamente, e expande.

\begin{algobox}{András Frank}{andras-frank}
	Entrada: dígrafo \(D=(V,A)\), custos \(c:A\to\mathbb{R}_{\ge 0}\), raiz \(r\).\footnote{Se algum \(v\neq r\) não possui arco de entrada, não existe r-arborescência.}

	\textbf{Fase 1: Redução de custos e construção de \(A_0\)}
	\begin{enumerate}\setlength{\itemsep}{2pt}
		\item \textbf{Inicialização:} defina \(A_0 := \emptyset\) (conjunto de arcos justos).
		\item \textbf{Iteração:} enquanto existir subconjunto minimal \(X \subseteq V \setminus \{r\}\):
		      \begin{itemize}\setlength{\itemsep}{2pt}
			      \item Calcule as componentes fortemente conexas de \((V, A_0)\).
			      \item Para cada componente \(X\) que não contém \(r\) e não possui arcos de \(A_0\) entrando:
			            \begin{itemize}
				            \item Calcule \(\delta(X) := \min\{c(u,v) : u \notin X, v \in X\}\).
				            \item Para todo arco \((u,v)\) com \(u \notin X\) e \(v \in X\), atualize \(c(u,v) := c(u,v) - \delta(X)\).
				            \item Adicione a \(A_0\) todos os arcos \((u,v)\) com \(u \notin X, v \in X\) que atingiram custo zero.
			            \end{itemize}
		      \end{itemize}
		      Ao final, todo vértice \(v \neq r\) possui ao menos um arco justo entrando.
	\end{enumerate}

	\textbf{Fase 2: Construção da arborescência}
	\begin{enumerate}\setlength{\itemsep}{2pt}\setcounter{enumi}{2}
		\item Se \((V,A_0)\) forma uma r-arborescência, devolva \(A_0\). Por construção, todos os arcos têm custo reduzido zero e os demais arcos têm custo não negativo, garantindo otimalidade.
		\item Caso contrário, identifique um ciclo dirigido \(C\) em \(A_0\) (com \(r\notin C\)). \textbf{Contração:} contraia \(C\) em um supervértice \(x_C\) e ajuste os custos dos arcos incidentes, descartando laços em \(x_C\) e permitindo paralelos. Denote o dígrafo contraído por \(D'=(V',A')\).
		\item \textbf{Recursão:} compute uma r-arborescência ótima \(T'\) de \(D'\) com os custos ajustados.
		\item \textbf{Expansão:} seja \((u,x_C)\in T'\) o único arco que entra em \(x_C\). No dígrafo original, ele corresponde a \((u,w)\) com \(w\in C\). Forme
		      \[
			      T := \bigl(T'\setminus\{\text{arcos incidentes a } x_C\}\bigr)\ \cup\ \{(u,w)\}\ \cup\ \bigl((A_0\cap A(C))\setminus\{a_w\}\bigr),
		      \]
		      onde \(a_w\) é o arco de \(C\) que entra em \(w\). Então \(T\) é uma r-arborescência ótima de \(D\).
	\end{enumerate}
\end{algobox}

\paragraph{Observação importante sobre a Fase~1.} A descrição acima enfatiza que em cada iteração devemos escolher um \textbf{subconjunto minimal}, não um subconjunto arbitrário sem arcos justos entrando. Esta distinção é crucial para a corretude do algoritmo:
\begin{itemize}\setlength{\itemsep}{2pt}
	\item Se escolhermos um conjunto \(X\) que não seja minimal (ou seja, que contenha um subconjunto próprio \(Y \subset X\) também sem arcos justos entrando), podemos elevar potenciais de forma redundante.
	\item Elevações redundantes podem criar folga desnecessária nas restrições duais, potencialmente levando a uma solução dual que não é ótima.
	\item A implementação através de componentes fortemente conexas e fontes no grafo de condensação garante automaticamente que apenas conjuntos minimais são processados.
\end{itemize}

Como discutido anteriormente nas Seções~\ref{sec:identificacao-minimais} e~\ref{sec:escolha-minimal} (onde \texttt{\textbackslash label\{sec:...\}} será adicionado nas subseções anteriores), as fontes no grafo de condensação correspondem exatamente aos conjuntos minimais que devemos processar.

\paragraph{Observação sobre a Fase~2.} A descrição teórica acima apresenta a Fase~2 com contração e recursão (Passos 4--6), seguindo a estrutura clássica do algoritmo de Chu--Liu--Edmonds. No entanto, na implementação apresentada neste capítulo, adotamos uma abordagem alternativa:
\begin{itemize}\setlength{\itemsep}{2pt}
	\item A Fase~1 continua elevando potenciais iterativamente até que o grafo de arcos justos \((V, A_0)\) contenha uma \(r\)-arborescência (possivelmente com arcos extras).
	\item A Fase~2 constrói a arborescência de forma \textbf{incremental} a partir de \(A_0\), sem recursão explícita.
	\item Apresentamos duas versões da construção incremental: uma versão ingênua \(O(nm)\) e uma versão otimizada \(O(m \log m)\) usando fila de prioridade.
\end{itemize}

Ambas as abordagens (recursiva vs. incremental) são corretas e produzem arborescências ótimas. A escolha entre elas é uma questão de implementação e eficiência prática.

\subsection{Corretude}

A corretude do algoritmo baseia-se em três ideias principais:

\begin{enumerate}\setlength{\itemsep}{2pt}
	\item \emph{Equivalência com potenciais duais:} A operação de subtrair \(\delta(X)\)
	      dos arcos entrando em \(X\) equivale a aumentar um potencial dual \(y(v)\) em \(\delta(X)\)
	      para cada \(v \in X\). Trabalhar com custos reduzidos \(c(u,v)\) é equivalente
	      a trabalhar com \(c_{\text{original}}(u,v) - y(v)\).

	\item \emph{Condições de otimalidade:} Uma \(r\)-arborescência \(T\) é ótima se, e somente se:
	      \begin{itemize}\setlength{\itemsep}{2pt}
		      \item Todos os arcos de \(T\) são justos (custo reduzido zero).
		      \item Todos os arcos do dígrafo têm custo reduzido não negativo.
	      \end{itemize}
	      Isso porque, para qualquer \(r\)-arborescência \(F\),
	      \[
		      c(F) = \sum_{v \neq r} c_y(a_v) + \sum_{v \neq r} y(v),
	      \]
	      onde \(a_v\) é o arco de \(F\) entrando em \(v\). Como \(\sum_{v \neq r} y(v)\)
	      é constante, minimizar \(c(F)\) equivale a minimizar \(\sum_{v \neq r} c_y(a_v)\).

	\item \emph{Identificação de subconjuntos minimais:} O algoritmo usa componentes fortemente
	      conexas para identificar quais conjuntos ainda precisam de arcos justos entrando.
	      Inicialmente cada vértice é sua própria componente. Após criar arcos justos,
	      se formarem ciclos, as componentes agrupam vértices e o processo continua
	      sobre esses conjuntos maiores.
\end{enumerate}

\textbf{Conclusão:} A operação é a mesma do Chu--Liu--Edmonds (subtrair o menor custo
entrando em cada conjunto), mas organizada diferentemente: Chu--Liu opera vértice a vértice;
Frank opera sobre componentes fortemente conexas.

\subsection{Complexidade}

A implementação, baseada em componentes fortemente conexas, detecta em cada iteração, quais conjuntos \(X\) necessitam elevação de potenciais. Calcular componentes fortemente conexas custa \(O(n+m)\) usando algoritmos como Tarjan ou Kosaraju. Para cada componente (exceto a raiz), eleva-se o potencial calculando \(\Delta(X)\) em \(O(m)\), atualizando os custos reduzidos.

No pior caso, cada iteração reduz o número de componentes em pelo menos uma unidade, resultando em \(O(n)\) iterações. Cada iteração processa todos os arcos para atualizar custos reduzidos e recalcular componentes, resultando em \(O(nm)\) no total para a Fase~1. A Fase~2 constrói a arborescência percorrendo \(A_0\) uma vez, custando \(O(n)\).

O uso de memória é \(O(n+m)\), incluindo as estruturas para armazenar o dígrafo, potenciais e componentes. A implementação a seguir adota a versão \(O(nm)\) por simplicidade e está disponível no repositório do projeto (\url{https://github.com/lorenypsum/GraphVisualizer}).

\subsection{Observações finais sobre o algoritmo}

Antes de apresentar a implementação detalhada, é útil consolidar alguns pontos-chave sobre o comportamento e as propriedades do algoritmo de András Frank:

\paragraph{1. O algoritmo sempre termina.} A Fase~1 progride monotonicamente: a cada iteração, ao menos uma componente fortemente conexa (exceto a raiz) recebe um arco justo entrando e deixa de ser fonte. Como o número de componentes é limitado superiormente por \(n\) (o número de vértices) e cada iteração reduz o número de fontes em pelo menos uma unidade, o algoritmo termina em no máximo \(O(n)\) iterações.

\paragraph{2. Conjuntos minimais garantem otimalidade.} A escolha de conjuntos minimais (fontes no grafo de condensação) não é apenas uma conveniência algorítmica, mas uma exigência para a corretude. Escolher um conjunto não-minimal poderia levar a elevações redundantes de potenciais, violando as condições de folga complementar da programação linear dual e potencialmente produzindo uma solução subótima.

\paragraph{3. A Fase~1 constrói um certificado, não a arborescência.} O conjunto \(A_0\) de arcos justos produzido pela Fase~1 geralmente contém mais arcos do que os \(n-1\) necessários para uma arborescência. Essa "sujeira" é intencional: \(A_0\) representa o conjunto de \emph{todos} os arcos que podem fazer parte de \emph{alguma} arborescência ótima, não necessariamente a mesma. A Fase~2 seleciona um subconjunto específico de \(A_0\) que forma uma arborescência.

\paragraph{4. Duas abordagens para a Fase~2.} A literatura apresenta duas estratégias equivalentes para a Fase~2:
\begin{itemize}\setlength{\itemsep}{2pt}
	\item \textbf{Abordagem recursiva (clássica):} Se \(A_0\) contém ciclos, contrai cada ciclo em um supervértice, resolve recursivamente o problema no dígrafo contraído, e expande a solução de volta ao dígrafo original. Esta é a abordagem apresentada no pseudocódigo formal (Passos 4--6).
	\item \textbf{Abordagem incremental (implementação):} Continua a Fase~1 até que \((V, A_0)\) contenha uma \(r\)-arborescência (possivelmente com arcos extras), e então constrói a arborescência de forma gulosa e incremental, adicionando arcos de \(A_0\) um por vez. Esta é a abordagem adotada na implementação Python deste capítulo.
\end{itemize}

Ambas as abordagens são corretas e produzem arborescências de custo mínimo. A escolha entre elas é uma questão de preferência de implementação e eficiência prática em diferentes cenários.

\paragraph{5. Relação com Chu--Liu--Edmonds.} O algoritmo de Frank pode ser visto como uma generalização do algoritmo de Chu--Liu--Edmonds:
\begin{itemize}\setlength{\itemsep}{2pt}
	\item \textbf{Chu--Liu--Edmonds:} Processa vértices individualmente (\(X = \{v\}\) para cada \(v \neq r\)), elevando potenciais uma vez por vértice.
	\item \textbf{Frank:} Processa componentes fortemente conexas formadas por arcos justos, permitindo elevações para conjuntos \(X\) que podem conter múltiplos vértices (quando formam ciclos).
\end{itemize}

Essa generalização permite ao algoritmo de Frank lidar de forma mais natural com estruturas cíclicas que aparecem durante a elevação de potenciais, mantendo a mesma operação fundamental de redução de custos.

\paragraph{6. Eficiência através de componentes fortemente conexas.} O uso de componentes fortemente conexas e grafos de condensação é mais do que uma ferramenta teórica --- é uma estratégia de implementação eficiente. Ao trabalhar com o grafo de condensação:
\begin{itemize}\setlength{\itemsep}{2pt}
	\item Evitamos enumerar explicitamente todos os subconjuntos de vértices.
	\item Identificamos automaticamente apenas os conjuntos minimais (fontes).
	\item Detectamos quando o algoritmo deve terminar (uma única fonte contendo a raiz).
\end{itemize}

Bibliotecas modernas como NetworkX fornecem implementações eficientes de algoritmos de SCC (Tarjan, Kosaraju), tornando esta abordagem prática e elegante.

Com essas observações em mente, passamos agora à descrição detalhada da implementação em Python, que materializa todos esses conceitos em código executável.

\section{Implementação em Python}
\label{sec:implementacao}

Esta seção descreve a implementação do algoritmo de András Frank em Python, estruturada para refletir com precisão as duas fases formais discutidas anteriormente. A Fase~1 realiza a elevação de potenciais e identifica os arcos justos, enquanto a Fase~2 constrói a arborescência de custo mínimo a partir desses arcos. Utilizamos a biblioteca NetworkX para manipulação de digrafos, aproveitando suas funcionalidades para representar grafos, calcular componentes fortemente conexas e gerenciar atributos de arcos.

A entrada consiste em um dígrafo orientado \(D = (V, A)\), com custos dos arcos registrados no atributo \texttt{"w"}, e uma raiz \(r \in V\). As hipóteses adotadas são: (i) o dígrafo é conexo a partir de \(r\), isto é, todo vértice \(v \neq r\) é alcançável a partir da raiz; (ii) para todo subconjunto \(X \subseteq V \setminus \{r\}\), existe ao menos um arco entrando em \(X\); e (iii) todos os custos são não negativos.

A saída é um subdigrafo \(T\) de \(D\) com \(|A_T| = |V| - 1\) arcos, tal que cada vértice \(v \neq r\) possui grau de entrada igual a 1, todos os vértices são alcançáveis a partir de \(r\), e o custo total \(\sum_{a \in A_T} c(a)\) é mínimo.

A estrutura do código é modular: funções auxiliares tratam cada etapa do algoritmo — cálculo de componentes fortemente conexas, elevação de potenciais, construção do subdigrafo \(A_0\) e construção da arborescência final. Todas operam sobre objetos \texttt{nx.DiGraph} e são coordenadas por uma função principal que gerencia o fluxo das duas fases. As subseções seguintes detalham cada função auxiliar, abordando lógica, parâmetros, saídas e complexidade.

\subsection{Construção do dígrafo \texorpdfstring{\(D_0\)}{D_0} inicial}

Começamos escrevendo uma função que constrói o dígrafo inicial \(D_0\) que será utilizado na Fase~1 do algoritmo. O dígrafo \(D_0\) é inicializado como um grafo vazio contendo apenas os vértices do dígrafo original, sem arcos. Essa estrutura será gradualmente populada com arcos de custo reduzido zero à medida que os potenciais são elevados.

Recebe como entrada um dígrafo \texttt{D} (objeto \texttt{nx.DiGraph}). A implementação cria um novo dígrafo vazio \texttt{D\_zero} (linha 2) e adiciona todos os vértices de \texttt{D} a \texttt{D\_zero} (linhas 3-4), preservando a estrutura de vértices sem incluir arcos inicialmente.

A função devolve o dígrafo \texttt{D\_zero} contendo todos os vértices de \texttt{D} mas nenhum arco. O dígrafo original \texttt{D} não é modificado. A complexidade é \(O(n)\), onde \(n = |V|\), pois itera sobre todos os vértices uma única vez.

\begin{tcolorbox}[
		enhanced, breakable,
		colframe=blue!60!black, colback=blue!2,
		colbacktitle=blue!15, coltitle=black,
		title={Construção do dígrafo $D_0$ inicial},
		boxed title style={sharp corners, boxrule=0.6pt},
		sharp corners, boxrule=0.6pt
	]
	\emph{Constrói um dígrafo vazio contendo apenas os vértices de D, sem arcos. Este dígrafo será populado com arcos justos durante a elevação de potenciais.}
	\tcblower
	\begin{lstlisting}[language=Python]
def build_D_zero(D):
    D_zero = nx.DiGraph()
    for v in D.nodes():
        D_zero.add_node(v)
    return D_zero
\end{lstlisting}
\end{tcolorbox}

\subsection{Identificação de arcos entrando em conjunto \texorpdfstring{\(X\)}{X}}

Esta função auxiliar identifica todos os arcos que entram em um conjunto \(X \subseteq V\), isto é, arcos \((u,v)\) tais que \(u \notin X\) e \(v \in X\). Essa operação é fundamental para calcular o mínimo custo de entrada em \(X\) durante a elevação de potenciais.

Recebe como entrada um dígrafo \texttt{D} e um conjunto de vértices \texttt{X}. A implementação cria uma lista vazia \texttt{arcs} (linha 2) e itera sobre todos os arcos do dígrafo com seus dados (linha 3), incluindo o peso. Para cada arco \((u,v,\text{data})\), verifica se \(u \notin X\) e \(v \in X\) (linha 4), adicionando à lista apenas os arcos que cruzam a fronteira de \(X\) (linha 5).

A função devolve uma lista de tuplas \((u, v, \text{data})\) representando os arcos que entram em \(X\), onde \texttt{data} contém o atributo \texttt{"w"} com o peso do arco. A complexidade é \(O(m)\), onde \(m = |A|\), pois examina cada arco uma vez.

\begin{tcolorbox}[
		enhanced, breakable,
		colframe=blue!60!black, colback=blue!2,
		colbacktitle=blue!15, coltitle=black,
		title={Identificação de arcos entrando em conjunto X},
		boxed title style={sharp corners, boxrule=0.6pt},
		sharp corners, boxrule=0.6pt
	]
	\emph{Identifica todos os arcos $(u,v)$ do dígrafo D tais que $u \notin X$ e $v \in X$, devolvendo uma lista com as tuplas $(u, v, data)$ onde data contém o peso do arco.}
	\tcblower
	\begin{lstlisting}[language=Python]
def get_arcs_entering_X(D, X):
    arcs = []
    for u, v, data in D.edges(data=True):
        if u not in X and v in X:
            arcs.append((u, v, data))
    return arcs
\end{lstlisting}
\end{tcolorbox}

A figura a seguir ilustra o funcionamento da função \texttt{get\_arcs\_entering\_X} em um digrafo que vamos denotar por \(D_{32}\). O dígrafo possui uma raiz \(r_0\) conectada aos vértices \(u_1, u_2, u_3\). Os vértices em laranja pertencem ao conjunto \(X = \{v_1, v_2, v_3\}\), e a função identifica apenas os arcos em vermelho, que saem de vértices fora de \(X\) e entram em vértices dentro de \(X\). Arcos da raiz, arcos internos a \(X\), externos a \(X\), ou saindo de \(X\) não são retornados.

\begin{figure}[H]
	\centering
	\begin{tikzpicture}[>=Stealth]
		% estilos
		\tikzset{
			vtx/.style={circle, draw, fill=blue!8, thick, inner sep=1.2pt, minimum size=7mm},
			vtxRoot/.style={circle, draw, fill=red!15, thick, inner sep=1.2pt, minimum size=7mm},
			vtxX/.style={circle, draw=orange!80!black, fill=orange!15, thick, inner sep=1.2pt, minimum size=7mm},
			arc/.style={->, >=Stealth, thick, draw=black!40},
			arcEntering/.style={->, >=Stealth, very thick, draw=red!70!black},
			cost/.style={font=\scriptsize, fill=white, inner sep=1pt}
		}

		% Raiz
		\node[vtxRoot] (r0) at (2, 4) {$r_0$};

		% Vértices fora de X
		\node[vtx] (u1) at (0, 2) {$u_1$};
		\node[vtx] (u2) at (2, 2) {$u_2$};
		\node[vtx] (u3) at (4, 2) {$u_3$};

		% Vértices dentro de X (destacados)
		\node[vtxX] (v1) at (0.5, -0.5) {$v_1$};
		\node[vtxX] (v2) at (2, -0.5) {$v_2$};
		\node[vtxX] (v3) at (3.5, -0.5) {$v_3$};

		% Arcos da raiz (não retornados, pois r0 não está em consideração para X)
		\draw[arc] (r0) -- node[cost, left, pos=0.4] {1} (u1);
		\draw[arc] (r0) -- node[cost, right] {2} (u2);
		\draw[arc] (r0) -- node[cost, right, pos=0.4] {1} (u3);

		% Arcos externos a X (não retornados)
		\draw[arc] (u1) to[bend left=15] node[cost, above] {1} (u2);
		\draw[arc] (u2) to[bend left=15] node[cost, above] {3} (u3);

		% Arcos entrando em X (destacados em vermelho)
		\draw[arcEntering] (u1) -- node[cost, left] {3} (v1);
		\draw[arcEntering] (u2) -- node[cost, right] {2} (v2);
		\draw[arcEntering] (u3) -- node[cost, right] {4} (v3);
		\draw[arcEntering] (u1) to[bend right=20] node[cost, below, pos=0.3] {5} (v2);

		% Arcos internos a X (não retornados)
		\draw[arc] (v1) -- node[cost, above] {1} (v2);
		\draw[arc] (v2) -- node[cost, above] {2} (v3);

		% Arcos saindo de X (não retornados)
		\draw[arc] (v1) to[bend right=30] node[cost, left, pos=0.3] {2} (u1);

		% Região X destacada
		\draw[orange!60!black, thick, dashed, rounded corners=8pt]
		(-0.3, 0.3) rectangle (4.3, -1.3);
		\node[orange!80!black, font=\bfseries] at (5, 0.3) {$X$};
	\end{tikzpicture}
	\caption{Ilustração da função \texttt{get\_arcs\_entering\_X} em \(D_{32}\). A raiz \(r_0\) (em vermelho claro) conecta-se aos vértices \(u_1, u_2, u_3\). Os vértices em \textcolor{orange!80!black}{laranja} pertencem ao conjunto \(X = \{v_1, v_2, v_3\}\). A função identifica apenas os arcos \textcolor{red!70!black}{em vermelho}: aqueles que saem de vértices fora de \(X\) e entram em vértices dentro de \(X\). Arcos da raiz, arcos internos a \(X\), externos a \(X\), ou saindo de \(X\) não são retornados.}
\end{figure}

\subsection{Cálculo do peso mínimo de corte}

Esta função calcula o peso mínimo entre todos os arcos fornecidos, correspondendo ao valor \(\Delta(X)\) necessário para elevar os potenciais dos vértices em \(X\).

Recebe como entrada uma lista \texttt{arcos} de tuplas \((u, v, \text{data})\). A implementação usa a função \texttt{min} com uma compreensão de gerador (linha 2) que extrai o atributo \texttt{"w"} de cada tupla em \texttt{data}.

A função devolve o peso mínimo encontrado entre todos os arcos da lista. A complexidade é \(O(k)\), onde \(k\) é o número de arcos na lista, pois examina cada arco uma vez para encontrar o mínimo.

\begin{tcolorbox}[
		enhanced, breakable,
		colframe=blue!60!black, colback=blue!2,
		colbacktitle=blue!15, coltitle=black,
		title={Cálculo do peso mínimo de corte},
		boxed title style={sharp corners, boxrule=0.6pt},
		sharp corners, boxrule=0.6pt
	]
	\emph{Calcula o peso mínimo entre todos os arcos fornecidos, correspondendo ao valor $\Delta(X)$ usado na elevação de potenciais.}
	\tcblower
	\begin{lstlisting}[language=Python]
def get_minimum_weight_cut(arcs):
    return min(data["w"] for _, _, data in arcs)
\end{lstlisting}
\end{tcolorbox}

A seguir temos uma ilustração do funcionamento da função \texttt{get\_minimum\_weight\_cut} em \(D_{32}\). Considerando os arcos em vermelho que entram em \(X\) (identificados pela função anterior), esta função calcula o peso mínimo entre eles. O arco em verde possui o menor peso (2), correspondendo ao valor \(\Delta(X) = 2\) que será devolvido pela função.

\begin{figure}[H]
	\centering
	\begin{tikzpicture}[>=Stealth]
		% estilos
		\tikzset{
			vtx/.style={circle, draw, fill=blue!8, thick, inner sep=1.2pt, minimum size=7mm},
			vtxRoot/.style={circle, draw, fill=red!15, thick, inner sep=1.2pt, minimum size=7mm},
			vtxX/.style={circle, draw=orange!80!black, fill=orange!15, thick, inner sep=1.2pt, minimum size=7mm},
			arc/.style={->, >=Stealth, thick, draw=black!40},
			arcEntering/.style={->, >=Stealth, very thick, draw=red!70!black},
			arcMin/.style={->, >=Stealth, ultra thick, draw=green!60!black},
			cost/.style={font=\scriptsize, fill=white, inner sep=1pt},
			costMin/.style={font=\scriptsize\bfseries, fill=green!10, inner sep=2pt, draw=green!60!black, rounded corners=1pt}
		}

		% Raiz
		\node[vtxRoot] (r0) at (2, 4) {$r_0$};

		% Vértices fora de X
		\node[vtx] (u1) at (0, 2) {$u_1$};
		\node[vtx] (u2) at (2, 2) {$u_2$};
		\node[vtx] (u3) at (4, 2) {$u_3$};

		% Vértices dentro de X (destacados)
		\node[vtxX] (v1) at (0.5, -0.5) {$v_1$};
		\node[vtxX] (v2) at (2, -0.5) {$v_2$};
		\node[vtxX] (v3) at (3.5, -0.5) {$v_3$};

		% Arcos da raiz
		\draw[arc] (r0) -- node[cost, left, pos=0.4] {1} (u1);
		\draw[arc] (r0) -- node[cost, right] {2} (u2);
		\draw[arc] (r0) -- node[cost, right, pos=0.4] {1} (u3);

		% Arcos externos a X
		\draw[arc] (u1) to[bend left=15] node[cost, above] {1} (u2);
		\draw[arc] (u2) to[bend left=15] node[cost, above] {3} (u3);

		% Arcos entrando em X (em vermelho, mas o mínimo em verde)
		\draw[arcEntering] (u1) -- node[cost, left] {3} (v1);
		\draw[arcMin] (u2) -- node[costMin, right] {2} (v2);
		\draw[arcEntering] (u3) -- node[cost, right] {4} (v3);
		\draw[arcEntering] (u1) to[bend right=20] node[cost, below, pos=0.3] {5} (v2);

		% Arcos internos a X
		\draw[arc] (v1) -- node[cost, above] {1} (v2);
		\draw[arc] (v2) -- node[cost, above] {2} (v3);

		% Arcos saindo de X
		\draw[arc] (v1) to[bend right=30] node[cost, left, pos=0.3] {2} (u1);

		% Região X destacada
		\draw[orange!60!black, thick, dashed, rounded corners=8pt]
		(-0.3, 0.3) rectangle (4.3, -1.3);
		\node[orange!80!black, font=\bfseries] at (5, 0.3) {$X$};

		% Anotação do resultado
		\node[font=\bfseries, green!60!black] at (2, -2.2) {$\Delta(X) = \min\{3, 2, 4, 5\} = 2$};
	\end{tikzpicture}
	\caption{Ilustração da função \texttt{get\_minimum\_weight\_cut} em \(D_{32}\). Considerando os arcos \textcolor{red!70!black}{em vermelho} que entram em \(X\) (identificados pela função anterior), esta função calcula o peso mínimo entre eles. O arco \textcolor{green!60!black}{em verde} possui o menor peso (2), correspondendo ao valor \(\Delta(X) = 2\).}
\end{figure}

\subsection{Atualização de pesos em \texorpdfstring{\(X\)}{X}}

Esta função auxiliar atualiza os pesos dos arcos que entram em um conjunto \(X\), subtraindo o valor \(\Delta(X)\) de cada peso. Arcos que atingem peso zero são adicionados a \(A_0\) e a \(D_0\).

Recebe como entrada um dígrafo \texttt{D}, lista de \texttt{arcs} entrando em \(X\), o valor \texttt{min\_weight} a ser subtraído, uma lista \texttt{A\_zero} para armazenar arcos de peso zero, e o dígrafo \texttt{D\_zero} para adicionar os arcos justos.

A implementação itera sobre cada arco \((u,v,\_)\) da lista (linha 2), subtrai \texttt{min\_weight} do peso armazenado em \texttt{D[u][v]["w"]} (linha 3), e verifica se o peso resultante é zero (linha 4). Caso sim, adiciona-se \((u,v)\) à lista \texttt{A\_zero} (linha 5) e ao dígrafo \texttt{D\_zero} (linha 6).

A função não devolve valor, pois modifica diretamente as estruturas passadas como parâmetros: o dígrafo \texttt{D} tem seus pesos atualizados, \texttt{A\_zero} acumula arcos justos, e \texttt{D\_zero} é populado com esses arcos. A complexidade é \(O(k)\), onde \(k\) é o número de arcos em \texttt{arcs}.

\begin{tcolorbox}[
		enhanced, breakable,
		colframe=blue!60!black, colback=blue!2,
		colbacktitle=blue!15, coltitle=black,
		title={Atualização de pesos em X},
		boxed title style={sharp corners, boxrule=0.6pt},
		sharp corners, boxrule=0.6pt
	]
	\emph{Atualiza os pesos dos arcos que entram em X, subtraindo o valor mínimo. Arcos que atingem peso zero são registrados em $A_0$ e adicionados a $D_0$.}
	\tcblower
	\begin{lstlisting}[language=Python]
def update_weights_in_X(D, arcs, min_weight, A_zero, D_zero):
    for u, v, _ in arcs:
        D[u][v]["w"] -= min_weight
        if D[u][v]["w"] == 0:
            A_zero.append((u, v))
            D_zero.add_edge(u, v)
\end{lstlisting}
\end{tcolorbox}

A seguir ilustramos o funcionamento da função \texttt{update\_weights\_in\_X} em \(D_{32}\). A figura mostra o dígrafo antes e depois da atualização dos pesos. No estado inicial (esquerda), temos \(\Delta(X) = 2\). A função subtrai esse valor de todos os arcos que entram em \(X\). No estado final (direita), os arcos que atingiram peso zero (destacados em azul) são adicionados a \(A_0\) e \(D_0\).

\begin{figure}[H]
	\centering
	\begin{tikzpicture}[>=Stealth]
		% estilos
		\tikzset{
			vtx/.style={circle, draw, fill=blue!8, thick, inner sep=1.2pt, minimum size=6.5mm},
			vtxRoot/.style={circle, draw, fill=red!15, thick, inner sep=1.2pt, minimum size=6.5mm},
			vtxX/.style={circle, draw=orange!80!black, fill=orange!15, thick, inner sep=1.2pt, minimum size=6.5mm},
			arc/.style={->, >=Stealth, thick, draw=black!40},
			arcEntering/.style={->, >=Stealth, very thick, draw=red!70!black},
			arcTight/.style={->, >=Stealth, ultra thick, draw=blue!70!black},
			cost/.style={font=\scriptsize, fill=white, inner sep=1pt},
			costTight/.style={font=\scriptsize\bfseries, fill=blue!10, inner sep=2pt, draw=blue!70!black, rounded corners=1pt}
		}

		% ===== ANTES (esquerda) =====
		\begin{scope}
			\node[font=\bfseries, blue!80!black] at (2, 4.2) {Antes: pesos originais};

			% Raiz
			\node[vtxRoot] (r0) at (2, 3) {$r_0$};

			% Vértices fora de X
			\node[vtx] (u1) at (0, 1.5) {$u_1$};
			\node[vtx] (u2) at (2, 1.5) {$u_2$};
			\node[vtx] (u3) at (4, 1.5) {$u_3$};

			% Vértices dentro de X
			\node[vtxX] (v1) at (0.5, -0.5) {$v_1$};
			\node[vtxX] (v2) at (2, -0.5) {$v_2$};
			\node[vtxX] (v3) at (3.5, -0.5) {$v_3$};

			% Arcos da raiz
			\draw[arc] (r0) -- node[cost, left, pos=0.4] {1} (u1);
			\draw[arc] (r0) -- node[cost, right] {2} (u2);
			\draw[arc] (r0) -- node[cost, right, pos=0.4] {1} (u3);

			% Arcos externos a X
			\draw[arc] (u1) to[bend left=15] node[cost, above] {1} (u2);
			\draw[arc] (u2) to[bend left=15] node[cost, above] {3} (u3);

			% Arcos entrando em X
			\draw[arcEntering] (u1) -- node[cost, left] {3} (v1);
			\draw[arcEntering] (u2) -- node[cost, right] {2} (v2);
			\draw[arcEntering] (u3) -- node[cost, right] {4} (v3);
			\draw[arcEntering] (u1) to[bend right=20] node[cost, below, pos=0.3] {5} (v2);

			% Arcos internos a X
			\draw[arc] (v1) -- node[cost, above] {1} (v2);
			\draw[arc] (v2) -- node[cost, above] {2} (v3);

			% Arcos saindo de X
			\draw[arc] (v1) to[bend right=30] node[cost, left, pos=0.3] {2} (u1);

			% Região X
			\draw[orange!60!black, thick, dashed, rounded corners=8pt]
			(-0.3, 0.3) rectangle (4.3, -1.3);
			\node[orange!80!black, font=\bfseries\small] at (4.8, 0.1) {$X$};

			\node[font=\small, green!60!black] at (2, -2.2) {$\Delta(X) = 2$};
		\end{scope}

		% Seta indicando transformação
		\draw[->, ultra thick, blue!60!black] (5.3, 0.5) -- node[above, font=\small] {subtrai $\Delta(X)$} (6.7, 0.5);

		% ===== DEPOIS (direita) =====
		\begin{scope}[xshift=7.5cm]
			\node[font=\bfseries, blue!80!black] at (2, 4.2) {Depois: pesos atualizados};

			% Raiz
			\node[vtxRoot] (r0b) at (2, 3) {$r_0$};

			% Vértices fora de X
			\node[vtx] (u1b) at (0, 1.5) {$u_1$};
			\node[vtx] (u2b) at (2, 1.5) {$u_2$};
			\node[vtx] (u3b) at (4, 1.5) {$u_3$};

			% Vértices dentro de X
			\node[vtxX] (v1b) at (0.5, -0.5) {$v_1$};
			\node[vtxX] (v2b) at (2, -0.5) {$v_2$};
			\node[vtxX] (v3b) at (3.5, -0.5) {$v_3$};

			% Arcos da raiz (inalterados)
			\draw[arc] (r0b) -- node[cost, left, pos=0.4] {1} (u1b);
			\draw[arc] (r0b) -- node[cost, right] {2} (u2b);
			\draw[arc] (r0b) -- node[cost, right, pos=0.4] {1} (u3b);

			% Arcos externos a X (inalterados)
			\draw[arc] (u1b) to[bend left=15] node[cost, above] {1} (u2b);
			\draw[arc] (u2b) to[bend left=15] node[cost, above] {3} (u3b);

			% Arcos entrando em X (atualizados)
			\draw[arcEntering] (u1b) -- node[cost, left] {1} (v1b);
			\draw[arcTight] (u2b) -- node[costTight, right] {0} (v2b);
			\draw[arcEntering] (u3b) -- node[cost, right] {2} (v3b);
			\draw[arcEntering] (u1b) to[bend right=20] node[cost, below, pos=0.3] {3} (v2b);

			% Arcos internos a X (inalterados)
			\draw[arc] (v1b) -- node[cost, above] {1} (v2b);
			\draw[arc] (v2b) -- node[cost, above] {2} (v3b);

			% Arcos saindo de X (inalterados)
			\draw[arc] (v1b) to[bend right=30] node[cost, left, pos=0.3] {2} (u1b);

			% Região X
			\draw[orange!60!black, thick, dashed, rounded corners=8pt]
			(-0.3, 0.3) rectangle (4.3, -1.3);
			\node[orange!80!black, font=\bfseries\small] at (4.8, 0.1) {$X$};

			\node[font=\small, blue!70!black] at (2, -2.2) {Arco \textcolor{blue!70!black}{justo} $\to A_0$};
		\end{scope}
	\end{tikzpicture}
	\caption{Ilustração da função \texttt{update\_weights\_in\_X} em \(D_{32}\). À esquerda, o dígrafo antes da atualização, com os arcos \textcolor{red!70!black}{em vermelho} entrando em \(X\) e \(\Delta(X) = 2\). À direita, após subtrair \(\Delta(X)\) de cada arco entrando em \(X\): o peso $(u_1, v_1)$ reduz de 3 para 1, $(u_2, v_2)$ de 2 para \textcolor{blue!70!black}{\textbf{0}} (torna-se justo), $(u_3, v_3)$ de 4 para 2, e $(u_1, v_2)$ de 5 para 3. O arco justo é adicionado a \(A_0\) e \(D_0\). Note que os arcos da raiz e arcos internos/externos a \(X\) permanecem inalterados.}
\end{figure}

\subsection{Verificação de arborescência}

Esta função verifica se um dígrafo \(D\) contém uma r-arborescência com raiz \(r_0\). Utiliza busca em profundidade (DFS) a partir da raiz para verificar se todos os vértices são alcançáveis.

Recebe como entrada um dígrafo \texttt{D} e a raiz \texttt{r0}. A implementação constrói uma árvore DFS a partir de \texttt{r0} usando \texttt{nx.dfs\_tree} (linha 2), que devolve um subdigrafo contendo apenas os vértices alcançáveis a partir da raiz seguindo arcos. Em seguida, compara o número de vértices da árvore DFS com o número total de vértices de \texttt{D} (linha 3).

A função devolve \texttt{True} se todos os vértices são alcançáveis (indicando presença de r-arborescência), \texttt{False} caso contrário. A complexidade é \(O(n+m)\), onde \(n=|V|\) e \(m=|A|\), devido à busca em profundidade. Precisamos dessa verificação para garantir que a Fase~1 produza um dígrafo \(D_0\) que contenha uma r-arborescência antes de prosseguir para a Fase~2.

\begin{tcolorbox}[
		enhanced, breakable,
		colframe=blue!60!black, colback=blue!2,
		colbacktitle=blue!15, coltitle=black,
		title={Verificação de arborescência},
		boxed title style={sharp corners, boxrule=0.6pt},
		sharp corners, boxrule=0.6pt
	]
	\emph{Verifica se o dígrafo D contém uma r-arborescência com raiz r0, usando busca em profundidade para testar alcançabilidade de todos os vértices.}
	\tcblower
	\begin{lstlisting}[language=Python]
def has_arborescence(D, r0):
    tree = nx.dfs_tree(D, r0)
    return tree.number_of_nodes() == D.number_of_nodes()
\end{lstlisting}
\end{tcolorbox}

\subsection{Fase 1: Elevação de potenciais e construção de \texorpdfstring{\(A_0\)}{A_0}}

A seguir apresentamos a função principal da Fase~1, responsável por elevar os potenciais dos vértices iterativamente até que cada conjunto de vértices possua ao menos um arco justo entrando. O processo utiliza componentes fortemente conexas para identificar quais conjuntos necessitam elevação.

Recebe como entrada um dígrafo \texttt{D\_original} e a raiz \texttt{r0}. A implementação cria uma cópia do dígrafo original (linha 2) para preservar a entrada, inicializa estruturas auxiliares \texttt{A\_zero} (lista de arcos justos), \texttt{Dual\_list} (lista de pares \((X, \Delta(X))\) para fins de validação dual), e \texttt{D\_zero} (dígrafo de arcos justos) (linhas 3-5). Um contador de iterações é inicializado na linha 6.

O loop principal (linhas 7-22) itera enquanto houver conjuntos sem arcos justos entrando. Em cada iteração, incrementa-se o contador (linha 8), calcula-se as componentes fortemente conexas de \(D_0\) usando \texttt{nx.condensation} (linha 9), que devolve um grafo acíclico dirigido (DAG, do inglês \emph{directed acyclic graph}) onde cada vértice representa uma componente e contém o atributo \texttt{"members"} com os vértices originais. Utilizamos componentes fortemente conexas porque elas identificam naturalmente os conjuntos maximais de vértices que ainda não possuem arcos justos entrando, evitando a necessidade de rastrear manualmente quais conjuntos já foram processados.

Em seguida, identificam-se as fontes (componentes sem arcos entrando) no grafo de condensação (linha 10). Se há apenas uma fonte, significa que todos os vértices estão em uma única componente alcançável pela raiz através de arcos justos, garantindo que \(D_0\) contém uma r-arborescência e encerrando o loop (linhas 11-12).

Para cada fonte \(u\) no grafo de condensação (linha 13), obtém-se o conjunto \(X\) de vértices da componente (linha 14). Se \(r_0 \in X\), a fonte é ignorada (linhas 15-16), pois a componente contendo a raiz não necessita elevação. Caso contrário, identificam-se os arcos entrando em \(X\) usando \texttt{get\_arcs\_entering\_X} (linha 17), calcula-se o peso mínimo \(\Delta(X)\) usando \texttt{get\_minimum\_weight\_cut} (linha 18), e atualiza-se os pesos com \texttt{update\_weights\_in\_X}, registrando novos arcos justos (linha 19). A elevação simultânea de potenciais para todos os vértices de \(X\) mantém a propriedade de que arcos internos a \(X\) permanecem com o mesmo custo reduzido relativo, preservando a correção do algoritmo. Finalmente, adiciona-se \((X, \Delta(X))\) à lista dual se \(\Delta(X) > 0\) (linhas 20-21), permitindo verificação posterior das condições de otimalidade dual.

A função devolve \texttt{A\_zero} (lista de arcos justos) e \texttt{Dual\_list} (pares \((X, \Delta(X))\) para validação). A complexidade é \(O(nm)\) no pior caso, com \(O(n)\) iterações, cada uma custando \(O(m)\) para calcular componentes e atualizar pesos.

\begin{tcolorbox}[
		enhanced, breakable,
		colframe=blue!60!black, colback=blue!2,
		colbacktitle=blue!15, coltitle=black,
		title={Fase 1: Elevação de potenciais e construção de $A_0$},
		boxed title style={sharp corners, boxrule=0.6pt},
		sharp corners, boxrule=0.6pt
	]
	\emph{Eleva iterativamente os potenciais dos vértices até que cada conjunto possua ao menos um arco justo entrando. Devolve a lista $A_0$ de arcos justos e a lista de pares $(X, \Delta(X))$ para validação dual.}
	\tcblower
	\begin{lstlisting}[language=Python, basicstyle=\ttfamily\fontsize{8}{9}\selectfont]
def phase1(D_original, r0):
    D_copy = D_original.copy()
    A_zero = []
    Dual_list = []
    D_zero = build_D_zero(D_copy)
    iteration = 0
    while True:
        iteration += 1
        C = nx.condensation(D_zero)
        sources = [x for x in C.nodes() if C.in_degree(x) == 0]
        if len(sources) == 1:
            break
        for u in sources:
            X = C.nodes[u]["members"]
            if r0 in X:
                continue
            arcs = get_arcs_entering_X(D_copy, X)
            min_weight = get_minimum_weight_cut(arcs)
            update_weights_in_X(D_copy, arcs, min_weight, A_zero, D_zero)
            if min_weight != 0:
                Dual_list.append((X, min_weight)) 
    return A_zero, Dual_list
\end{lstlisting}
\end{tcolorbox}

A seguir ilustramos a execução da função \texttt{phase1} no dígrafo \(D_{32}\) estendido com a raiz \(r_0\). A figura mostra três estados principais: o dígrafo original \(D\) com seus pesos, o dígrafo \(D_0\) inicial (vazio, sem arcos), e o dígrafo \(D_0\) final após as iterações de elevação de potenciais, contendo apenas os arcos justos (em azul) que formam uma r-arborescência.

\begin{figure}[H]
	\centering
	\begin{tikzpicture}[>=Stealth, scale=0.85, every node/.style={scale=0.85}]
		% Estilos
		\tikzset{
			vtx/.style={circle, draw, fill=blue!8, thick, inner sep=1.2pt, minimum size=6.5mm},
			vtxRoot/.style={circle, draw, fill=red!15, thick, inner sep=1.2pt, minimum size=6.5mm},
			vtxX/.style={circle, draw, fill=orange!20, thick, inner sep=1.2pt, minimum size=6.5mm},
			arc/.style={->, thick, gray!60},
			arcTight/.style={->, ultra thick, blue!70!black},
			cost/.style={font=\scriptsize, fill=white, inner sep=1pt, rounded corners=1pt},
			costTight/.style={font=\scriptsize\bfseries, fill=blue!10, inner sep=2pt, draw=blue!70!black, rounded corners=1pt}
		}

		% ===== DÍGRAFO ORIGINAL D (esquerda) =====
		\begin{scope}
			\node[font=\bfseries, blue!80!black] at (2, 4.2) {Dígrafo original $D$};

			% Raiz
			\node[vtxRoot] (r0) at (2, 3) {$r_0$};

			% Vértices fora de X
			\node[vtx] (u1) at (0, 1.5) {$u_1$};
			\node[vtx] (u2) at (2, 1.5) {$u_2$};
			\node[vtx] (u3) at (4, 1.5) {$u_3$};

			% Vértices dentro de X
			\node[vtxX] (v1) at (0.5, -0.5) {$v_1$};
			\node[vtxX] (v2) at (2, -0.5) {$v_2$};
			\node[vtxX] (v3) at (3.5, -0.5) {$v_3$};

			% Arcos da raiz
			\draw[arc] (r0) -- node[cost, left, pos=0.4] {1} (u1);
			\draw[arc] (r0) -- node[cost, right] {2} (u2);
			\draw[arc] (r0) -- node[cost, right, pos=0.4] {1} (u3);

			% Arcos externos a X
			\draw[arc] (u1) to[bend left=15] node[cost, above] {1} (u2);
			\draw[arc] (u2) to[bend left=15] node[cost, above] {3} (u3);

			% Arcos entrando em X
			\draw[arc] (u1) -- node[cost, left] {3} (v1);
			\draw[arc] (u2) -- node[cost, right] {2} (v2);
			\draw[arc] (u3) -- node[cost, right] {4} (v3);
			\draw[arc] (u1) to[bend right=20] node[cost, below, pos=0.3] {5} (v2);

			% Arcos internos a X
			\draw[arc] (v1) -- node[cost, above] {1} (v2);
			\draw[arc] (v2) -- node[cost, above] {2} (v3);

			% Arcos saindo de X
			\draw[arc] (v1) to[bend right=30] node[cost, left, pos=0.3] {2} (u1);

			\node[font=\small, gray!70!black] at (2, -2) {Pesos originais};
		\end{scope}

		% ===== D_0 INICIAL (centro) =====
		\begin{scope}[xshift=6cm]
			\node[font=\bfseries, blue!80!black] at (2, 4.2) {$D_0$ inicial (linha 5)};

			% Vértices apenas, sem arcos
			\node[vtxRoot] (r0i) at (2, 3) {$r_0$};
			\node[vtx] (u1i) at (0, 1.5) {$u_1$};
			\node[vtx] (u2i) at (2, 1.5) {$u_2$};
			\node[vtx] (u3i) at (4, 1.5) {$u_3$};
			\node[vtxX] (v1i) at (0.5, -0.5) {$v_1$};
			\node[vtxX] (v2i) at (2, -0.5) {$v_2$};
			\node[vtxX] (v3i) at (3.5, -0.5) {$v_3$};

			\node[font=\small, gray!70!black] at (2, -2) {Sem arcos (vazio)};
		\end{scope}

		% ===== D_0 FINAL (direita) =====
		\begin{scope}[xshift=12cm]
			\node[font=\bfseries, blue!80!black] at (2, 4.2) {$D_0$ final (após loop)};

			% Vértices
			\node[vtxRoot] (r0f) at (2, 3) {$r_0$};
			\node[vtx] (u1f) at (0, 1.5) {$u_1$};
			\node[vtx] (u2f) at (2, 1.5) {$u_2$};
			\node[vtx] (u3f) at (4, 1.5) {$u_3$};
			\node[vtxX] (v1f) at (0.5, -0.5) {$v_1$};
			\node[vtxX] (v2f) at (2, -0.5) {$v_2$};
			\node[vtxX] (v3f) at (3.5, -0.5) {$v_3$};

			% Arcos justos (peso 0)
			\draw[arcTight] (r0f) -- node[costTight, left, pos=0.4] {0} (u1f);
			\draw[arcTight] (r0f) -- node[costTight, right, pos=0.4] {0} (u3f);
			\draw[arcTight] (u1f) to[bend left=15] node[costTight, above] {0} (u2f);
			\draw[arcTight] (u1f) -- node[costTight, left] {0} (v1f);
			\draw[arcTight] (u2f) -- node[costTight, right] {0} (v2f);
			\draw[arcTight] (v2f) -- node[costTight, above] {0} (v3f);

			\node[font=\small, blue!70!black] at (2, -2) {Arcos justos em $A_0$};
		\end{scope}

		% Setas indicando progressão
		\draw[->, ultra thick, gray!50] (4.5, 1) -- node[above, font=\small] {elevação} (5.5, 1);
		\draw[->, ultra thick, gray!50] (10.5, 1) -- node[above, font=\small] {iterações} (11.5, 1);
	\end{tikzpicture}
	\caption{Execução da função \texttt{phase1} em \(D_{32}\). À esquerda, o dígrafo original \(D\) com pesos dos arcos. Ao centro, \(D_0\) inicial após linha 5 (\texttt{build\_D\_zero}), contendo apenas vértices sem arcos. À direita, \(D_0\) final após o loop de elevação de potenciais, contendo apenas os arcos \textcolor{blue!70!black}{justos} (custo reduzido zero) que formam uma r-arborescência. Durante as iterações (linhas 7-22), os potenciais são elevados para cada componente sem arcos justos entrando, até que todos os vértices sejam alcançáveis a partir de \(r_0\) através de arcos em \(D_0\).}
\end{figure}

A seguir ilustramos a execução da função \texttt{phase2} em \(D_{32}\), mostrando como a r-arborescência é construída incrementalmente a partir do conjunto \(A_0\) de arcos justos obtidos da Fase~1. A figura apresenta quatro estados: o conjunto inicial \(A_0\) com 6 arcos justos, e três estados intermediários da arborescência \texttt{Arb} sendo construída, destacando em verde os arcos adicionados em cada iteração.

\begin{figure}[H]
	\centering
	\begin{tikzpicture}[>=Stealth, scale=0.72, every node/.style={scale=0.72}]
		% Estilos
		\tikzset{
			vtx/.style={circle, draw, fill=blue!8, thick, inner sep=1.2pt, minimum size=6.5mm},
			vtxRoot/.style={circle, draw, fill=red!15, thick, inner sep=1.2pt, minimum size=6.5mm},
			vtxIn/.style={circle, draw, fill=green!15, thick, inner sep=1.2pt, minimum size=6.5mm},
			vtxOut/.style={circle, draw, fill=gray!10, thick, inner sep=1.2pt, minimum size=6.5mm},
			arc/.style={->, thick, blue!70!black},
			arcNew/.style={->, ultra thick, green!70!black},
			cost/.style={font=\scriptsize, fill=white, inner sep=1pt}
		}

		% ===== A_0 (esquerda superior) =====
		\begin{scope}
			\node[font=\bfseries, blue!80!black] at (2, 4.5) {$A_0$ (arcos justos)};

			\node[vtxRoot] (r0) at (2, 3.2) {$r_0$};
			\node[vtx] (u1) at (0, 1.7) {$u_1$};
			\node[vtx] (u2) at (2, 1.7) {$u_2$};
			\node[vtx] (u3) at (4, 1.7) {$u_3$};
			\node[vtx] (v1) at (0.5, 0) {$v_1$};
			\node[vtx] (v2) at (2, 0) {$v_2$};
			\node[vtx] (v3) at (3.5, 0) {$v_3$};

			\draw[arc] (r0) -- node[cost, left, pos=0.3] {0} (u1);
			\draw[arc] (r0) -- node[cost, right, pos=0.3] {0} (u3);
			\draw[arc] (u1) to[bend left=12] node[cost, above, pos=0.4] {0} (u2);
			\draw[arc] (u1) -- node[cost, left] {0} (v1);
			\draw[arc] (u2) -- node[cost, right] {0} (v2);
			\draw[arc] (v2) -- node[cost, above] {0} (v3);

			\node[font=\small, gray!70!black] at (2, -1) {6 arcos com custo 0};
		\end{scope}

		% ===== Iteração 1 (direita superior) =====
		\begin{scope}[xshift=6.5cm]
			\node[font=\bfseries, blue!80!black] at (2, 4.5) {Iteração 1: $|$Arb$| = 1$};

			\node[vtxRoot] (r01) at (2, 3.2) {$r_0$};
			\node[vtxIn] (u11) at (0, 1.7) {$u_1$};
			\node[vtxOut] (u21) at (2, 1.7) {$u_2$};
			\node[vtxOut] (u31) at (4, 1.7) {$u_3$};
			\node[vtxOut] (v11) at (0.5, 0) {$v_1$};
			\node[vtxOut] (v21) at (2, 0) {$v_2$};
			\node[vtxOut] (v31) at (3.5, 0) {$v_3$};

			\draw[arcNew] (r01) -- node[cost, left, pos=0.3, fill=green!10] {1} (u11);

			\node[font=\small, green!70!black] at (2, -1) {Adiciona $(r_0, u_1)$};
		\end{scope}

		% ===== Iteração 2 (esquerda inferior) =====
		\begin{scope}[yshift=-6.2cm]
			\node[font=\bfseries, blue!80!black] at (2, 4.5) {Iteração 2: $|$Arb$| = 2$};

			\node[vtxRoot] (r02) at (2, 3.2) {$r_0$};
			\node[vtxIn] (u12) at (0, 1.7) {$u_1$};
			\node[vtxOut] (u22) at (2, 1.7) {$u_2$};
			\node[vtxIn] (u32) at (4, 1.7) {$u_3$};
			\node[vtxOut] (v12) at (0.5, 0) {$v_1$};
			\node[vtxOut] (v22) at (2, 0) {$v_2$};
			\node[vtxOut] (v32) at (3.5, 0) {$v_3$};

			\draw[arc] (r02) -- node[cost, left, pos=0.3] {1} (u12);
			\draw[arcNew] (r02) -- node[cost, right, pos=0.3, fill=green!10] {1} (u32);

			\node[font=\small, green!70!black] at (2, -1) {Adiciona $(r_0, u_3)$};
		\end{scope}

		% ===== Iteração 4 (direita inferior) =====
		\begin{scope}[xshift=6.5cm, yshift=-6.2cm]
			\node[font=\bfseries, blue!80!black] at (2, 4.5) {Iteração 4: $|$Arb$| = 4$};

			\node[vtxRoot] (r04) at (2, 3.2) {$r_0$};
			\node[vtxIn] (u14) at (0, 1.7) {$u_1$};
			\node[vtxIn] (u24) at (2, 1.7) {$u_2$};
			\node[vtxIn] (u34) at (4, 1.7) {$u_3$};
			\node[vtxIn] (v14) at (0.5, 0) {$v_1$};
			\node[vtxOut] (v24) at (2, 0) {$v_2$};
			\node[vtxOut] (v34) at (3.5, 0) {$v_3$};

			\draw[arc] (r04) -- node[cost, left, pos=0.3] {1} (u14);
			\draw[arc] (r04) -- node[cost, right, pos=0.3] {1} (u34);
			\draw[arc] (u14) to[bend left=12] node[cost, above, pos=0.4] {1} (u24);
			\draw[arcNew] (u14) -- node[cost, left, fill=green!10] {3} (v14);

			\node[font=\small, green!70!black] at (2, -1) {Adiciona $(u_1, v_1)$};
		\end{scope}

		% Setas de progressão
		\draw[->, ultra thick, gray!50] (4.8, 2) -- node[above, font=\small] {linha 6-10} (5.7, 2);
		\draw[->, ultra thick, gray!50] (2, -1.5) -- node[left, font=\small] {linha 6-10} (2, -2.4);
		\draw[->, ultra thick, gray!50] (4.8, -4.2) -- node[above, font=\small] {linha 6-10} (5.7, -4.2);
	\end{tikzpicture}
	\caption{Execução da função \texttt{phase2} em \(D_{32}\). Superior esquerdo: conjunto \(A_0\) com 6 arcos justos (custo reduzido zero) obtidos da Fase~1. Superior direito: Iteração 1 — adiciona arco $(r_0, u_1)$ pois $r_0 \in$ Arb e $u_1 \notin$ Arb. Inferior esquerdo: Iteração 2 — adiciona $(r_0, u_3)$. Inferior direito: Iteração 4 — após adicionar $(u_1, u_2)$ na iteração 3, adiciona $(u_1, v_1)$. Vértices \textcolor{green!70!black}{verdes} foram recém-adicionados, vértices \textcolor{gray!70!black}{cinzas} ainda não pertencem a Arb. O processo continua até que todos os 6 arcos de \(A_0\) sejam incluídos, formando uma r-arborescência com pesos originais de \(D\).}
\end{figure}

As funções auxiliares implementadas nesta seção correspondem diretamente aos passos da Fase~1 do algoritmo de András Frank da seguinte forma:

\begin{tcolorbox}[
		enhanced, breakable,
		colframe=purple!60!black, colback=purple!5,
		colbacktitle=purple!15, coltitle=black,
		title={Correspondência entre Teoria e Implementação — Fase 1},
		boxed title style={sharp corners, boxrule=0.6pt},
		sharp corners, boxrule=0.6pt
	]
	\textbf{Passo 1 — Inicialização:}
	\begin{itemize}
		\item \textbf{Descrição teórica:} Defina \(y(v) := 0\) para todo \(v \in V\).
		\item \textbf{Implementação:} A função \texttt{build\_D\_zero(D)} inicializa o dígrafo \(D_0\) vazio, que será populado apenas com arcos justos. Implicitamente, os potenciais iniciam em zero, pois os pesos no dígrafo \(D\) representam os custos reduzidos \(c_y(u,v) = c(u,v) - y(v)\). Com \(y(v) = 0\), temos \(c_y = c\) no início.
	\end{itemize}

	\vspace{2mm}
	\textbf{Passo 2 — Iteração de elevação de potenciais:}
	\begin{itemize}
		\item \textbf{Descrição teórica:} Enquanto existir conjunto \(X \subseteq V \setminus \{r\}\) sem arco justo entrando:
		      \begin{itemize}
			      \item Calcule \(\Delta(X) := \min\{c(u,v) - y(v) : u \notin X, v \in X\}\).
			      \item Para cada \(v \in X\), atualize \(y(v) := y(v) + \Delta(X)\).
		      \end{itemize}
		\item \textbf{Implementação:} Esse processo de iteração é realizado pela composição sequencial de três funções auxiliares:
		      \begin{enumerate}
			      \item \texttt{get\_arcs\_entering\_X(D, X)}: Identifica o conjunto \(\{(u,v) : u \notin X, v \in X\}\), isto é, todos os arcos que cruzam a fronteira de \(X\). Essa função corresponde diretamente à definição do conjunto sobre o qual o mínimo é calculado na fórmula \(\Delta(X)\).

			      \item \texttt{get\_minimum\_weight\_cut(arcs)}: Calcula \(\min\{\text{data}["w"] : (u,v,\text{data}) \in \text{arcs}\}\), que é exatamente \(\Delta(X) = \min\{c_y(u,v) : u \notin X, v \in X\}\). Como os pesos no dígrafo já representam custos reduzidos (são atualizados a cada iteração), essa função devolve precisamente o valor teórico de \(\Delta(X)\).

			      \item \texttt{update\_weights\_in\_X(D, arcs, min\_weight, A\_zero, D\_zero)}: Implementa a atualização dos potenciais. Para cada arco \((u,v)\) entrando em \(X\), subtrai \texttt{min\_weight} de \texttt{D[u][v]["w"]}, efetivamente calculando o novo custo reduzido:
			            \[c_y'(u,v) = c_y(u,v) - \Delta(X) = \]
			            \[c(u,v) - y(v) - \Delta(X) = \]
			            \[c(u,v) - \bigl(y(v) + \Delta(X)\bigr) = c(u,v) - y'(v), \]
			            onde \(y'(v) = y(v) + \Delta(X)\) é o novo potencial. Arcos cujo custo reduzido atinge zero (\texttt{D[u][v]["w"] == 0}) são adicionados a \(A_0\) e \(D_0\), tornando-se \textbf{justos}.
		      \end{enumerate}
	\end{itemize}

	\vspace{2mm}
	\textbf{Passo 3 — Construção de \(A_0\):}
	\begin{itemize}
		\item \textbf{Descrição teórica:} Defina \(A_0 := \{a \in A : c_y(a) = 0\}\), o conjunto de arcos justos.
		\item \textbf{Implementação:} A construção de \(A_0\) ocorre de forma incremental durante as iterações do Passo~2. Cada chamada a \texttt{update\_weights\_in\_X} verifica quais arcos atingiram custo reduzido zero e os adiciona tanto à lista \texttt{A\_zero} quanto ao dígrafo \texttt{D\_zero}. Esse processo continua até que a função principal da Fase~1 (que será apresentada adiante) determine que cada componente fortemente conexa em \(D_0\) (exceto a raiz) possui ao menos um arco justo entrando, garantindo que \(A_0\) é suficiente para formar a base de uma \(r\)-arborescência.
		\item O resultado final é o conjunto completo \(A_0 = \{a \in A : c_y(a) = 0\}\), usado na Fase~2 para construir a arborescência ótima através de uma seleção gulosa de arcos justos.
	\end{itemize}
\end{tcolorbox}

\subsection{Fase 2: Construção da arborescência}
Esta é a função principal da Fase~2, responsável por construir a r-arborescência de custo mínimo a partir do conjunto \(A_0\) de arcos justos. A construção é incremental: inicia-se com a raiz e adiciona-se iterativamente arcos de \(A_0\) que conectam vértices já incluídos a novos vértices, garantindo que cada vértice não-raiz receba exatamente um arco de entrada.

Recebe como entrada um dígrafo \texttt{D\_original}, a raiz \texttt{r0}, e a lista \texttt{A\_zero} de arcos justos. A implementação cria um novo dígrafo vazio \texttt{Arb} (linha 2) e adiciona a raiz (linha 3).

O loop principal (linhas 5-12) itera \(n-1\) vezes, onde \(n = |V|\), pois uma r-arborescência tem exatamente \(|V|-1\) arcos. Em cada iteração:
\begin{enumerate}\setlength{\itemsep}{2pt}
	\item Percorre os arcos \((u,v)\) de \texttt{A\_zero} (linha 6).
	\item Verifica se \(u\) já está em \texttt{Arb} e \(v\) ainda não (linha 7).
	\item Se sim, obtém os dados do arco do dígrafo original (linha 8) e adiciona \((u,v)\) a \texttt{Arb} (linha 9).
	\item Interrompe o loop interno para reiniciar a busca, garantindo descoberta em largura (linha 10).
\end{enumerate}

A função devolve o dígrafo \texttt{Arb} representando a r-arborescência de custo mínimo. A complexidade é \(O(nm)\) no pior caso, pois cada uma das \(O(n)\) iterações pode percorrer todos os \(O(m)\) arcos de \texttt{A\_zero}.

\begin{tcolorbox}[
		enhanced, breakable,
		colframe=blue!60!black, colback=blue!2,
		colbacktitle=blue!15, coltitle=black,
		title={Fase 2: Construção da arborescência},
		boxed title style={sharp corners, boxrule=0.6pt},
		sharp corners, boxrule=0.6pt
	]
	\emph{Constrói incrementalmente a r-arborescência a partir de $A_0$, adicionando iterativamente arcos que conectam vértices já incluídos a novos vértices.}
	\tcblower
	\begin{lstlisting}[language=Python]
def phase2(D_original, r0, A_zero):
    Arb = nx.DiGraph()
    Arb.add_node(r0)
    n = len(D_original.nodes())
    for _ in range(n - 1):
        for u, v in A_zero:
            if u in Arb.nodes() and v not in Arb.nodes():
                edge_data = D_original.get_edge_data(u, v)
                Arb.add_edge(u, v, **edge_data)
                break
    return Arb
\end{lstlisting}
\end{tcolorbox}

Apresentamos também uma versão alternativa da Fase~2 que utiliza busca em largura (BFS) para construir a r-arborescência de forma mais eficiente. Diferentemente da versão anterior que itera \(n-1\) vezes sobre todos os arcos, esta implementação usa uma fila de prioridade para explorar os arcos em ordem, evitando buscas lineares repetidas.

Recebe como entrada um dígrafo \texttt{D\_original}, a raiz \texttt{r0}, e a lista \texttt{A\_zero} de arcos justos. A implementação começa criando um dígrafo auxiliar \texttt{Arb} (linha 2) onde cada arco de \texttt{A\_zero} recebe um peso igual ao seu índice na lista (linhas 3-4), estabelecendo uma ordem de exploração. Inicializa-se o conjunto \texttt{V} de vértices visitados contendo apenas a raiz (linha 5) e uma fila de prioridade vazia \texttt{q} (linha 6).

Todos os arcos que saem da raiz em \texttt{Arb} são adicionados à fila de prioridade (linhas 7-8), usando o peso (índice) como critério de ordenação. Cria-se então o dígrafo \texttt{A} que conterá a arborescência resultante (linha 9).

O loop principal (linhas 10-17) extrai arcos da fila de prioridade em ordem crescente de índice. Para cada arco \((u,v)\) extraído (linha 11), verifica-se se o vértice destino \(v\) já foi visitado (linha 12); em caso positivo, o arco é ignorado via \texttt{continue} (linha 13). Caso contrário, adiciona-se o arco \((u,v)\) à arborescência \texttt{A} com o peso original de \texttt{D\_original} (linha 14), marca-se \(v\) como visitado (linha 15), e todos os arcos que saem de \(v\) em \texttt{Arb} são adicionados à fila de prioridade para exploração futura (linhas 16-17).

A função devolve o dígrafo \texttt{A} representando a r-arborescência de custo mínimo. A complexidade é \(O(m \log m)\), onde \(m = |A_0|\), devido às operações de inserção e remoção na fila de prioridade. Esta versão é mais eficiente que a anterior quando \(|A_0|\) é grande, pois evita percorrer todos os arcos em cada iteração.

\begin{tcolorbox}[
		enhanced, breakable,
		colframe=blue!60!black, colback=blue!2,
		colbacktitle=blue!15, coltitle=black,
		title={Fase 2 (versão BFS): Construção da arborescência com fila de prioridade},
		boxed title style={sharp corners, boxrule=0.6pt},
		sharp corners, boxrule=0.6pt
	]
	\emph{Constrói a r-arborescência usando busca em largura guiada por fila de prioridade, explorando arcos de $A_0$ em ordem e evitando buscas lineares repetidas. Complexidade $O(m \log m)$.}
	\tcblower
	\begin{lstlisting}[language=Python]
def phase2_v2(D_original, r0, A_zero):
    Arb = nx.DiGraph()
    for i, (u, v) in enumerate(A_zero):
        Arb.add_edge(u, v, w=i)
    V = {r0}
    q = []
    for u, v, data in Arb.out_edges(r0, data=True):
        heapq.heappush(q, (data["w"], u, v))
    A = nx.DiGraph()
    while q:
        _, u, v = heapq.heappop(q)
        if v in V:
            continue
        A.add_edge(u, v, w=D_original[u][v]["w"])
        V.add(v)
        for x, y, data in Arb.out_edges(v, data=True):
            heapq.heappush(q, (data["w"], x, y))
    return A
\end{lstlisting}
\end{tcolorbox}

As duas versões da Fase~2 implementadas acima correspondem diretamente ao Passo~4 da descrição teórica do algoritmo de András Frank:

\begin{tcolorbox}[
		enhanced, breakable,
		colframe=purple!60!black, colback=purple!5,
		colbacktitle=purple!15, coltitle=black,
		title={Correspondência entre Teoria e Implementação — Fase 2},
		boxed title style={sharp corners, boxrule=0.6pt},
		sharp corners, boxrule=0.6pt
	]
	\textbf{Passo 4 — Construção da arborescência (caso acíclico):}
	\begin{itemize}
		\item \textbf{Descrição teórica:} Se \((V,A_0)\) forma uma r-arborescência, devolva \(A_0\). Por otimalidade dos potenciais duais, trata-se de uma r-arborescência de custo mínimo.
		\item \textbf{Implementação:} Ambas as versões de \texttt{phase2} constroem uma r-arborescência a partir do conjunto \(A_0\) de arcos justos obtido na Fase~1. A corretude baseia-se no fato de que todos os arcos em \(A_0\) têm custo reduzido zero, e a Fase~1 garante que existe uma r-arborescência formada exclusivamente por arcos justos.
		      \begin{itemize}
			      \item \textbf{Versão 1 (\texttt{phase2}):} Construção incremental por exploração exaustiva. Em cada uma das \(n-1\) iterações, percorre todos os arcos de \(A_0\) procurando um arco \((u,v)\) tal que \(u\) já pertence à arborescência parcial e \(v\) ainda não. Essa abordagem simples corresponde diretamente à ideia teórica de construir a arborescência adicionando um vértice por vez, conectando-o à estrutura existente através de um arco justo. Complexidade: \(O(nm)\).

			      \item \textbf{Versão 2 (\texttt{phase2\_v2}):} Construção por busca em largura guiada por fila de prioridade. Cria um dígrafo auxiliar onde arcos são indexados, usa a fila de prioridade para explorar arcos sistematicamente a partir da raiz, evitando buscas lineares repetidas. Essa versão otimizada mantém a mesma correção teórica — construir uma r-arborescência usando apenas arcos de \(A_0\) — mas melhora a eficiência prática. Complexidade: \(O(m \log m)\).
		      \end{itemize}
	\end{itemize}

	\vspace{2mm}
	\textbf{Nota sobre Passos 5-7 (contração/recursão/expansão):}
	\begin{itemize}
		\item A descrição teórica do algoritmo de András Frank inclui os Passos~5-7 para tratar o caso onde \(A_0\) contém ciclos dirigidos, exigindo contração, resolução recursiva e reexpansão, de forma análoga ao algoritmo de Chu--Liu--Edmonds.
		\item Na implementação apresentada, optamos por uma abordagem não-recursiva baseada em componentes fortemente conexas. A Fase~1 já garante que \(A_0\) formará uma r-arborescência ao término das iterações de elevação de potenciais, eliminando a necessidade de tratar ciclos explicitamente na Fase~2. Essa simplificação é possível porque a elevação de potenciais progressivamente "quebra" todos os ciclos ao criar novos arcos justos que conectam diferentes componentes, até que reste apenas uma única componente fortemente conexa contendo todos os vértices.
		\item Portanto, quando a Fase~2 é executada, o conjunto \(A_0\) já está livre de ciclos e forma uma r-arborescência, correspondendo diretamente ao caso tratado pelo Passo~4 da descrição teórica. A verificação prévia \texttt{has\_arborescence(D, r0)} (realizada pela função principal) confirma essa propriedade antes de invocar a Fase~2.
	\end{itemize}
\end{tcolorbox}

\subsection{Verificação de otimalidade dual}

Esta função verifica se a condição de otimalidade dual é satisfeita para a r-arborescência construída. Segundo a teoria de programação linear dual aplicada ao problema de arborescência de custo mínimo, uma solução é ótima se e somente se cada conjunto \(X \subseteq V \setminus \{r\}\) que teve seu potencial elevado durante a Fase~1 possui exatamente um arco entrando na arborescência final.

Recebe como entrada a arborescência \texttt{Arb} e a lista \texttt{Dual\_list} contendo pares \((X, \Delta(X))\) onde \(X\) é um conjunto de vértices cujos potenciais foram elevados e \(\Delta(X) > 0\) é o valor da elevação. A implementação itera sobre cada par \((X, z)\) na lista dual (linha 2), e para cada conjunto \(X\), percorre todos os arcos \((u,v)\) da arborescência (linha 3). Inicializa um contador \texttt{count} em zero (linha 4) e verifica se o arco cruza a fronteira de \(X\), isto é, se \(u \notin X\) e \(v \in X\) (linha 5). Quando essa condição é satisfeita, incrementa o contador (linha 6) e imediatamente verifica se já há mais de um arco entrando em \(X\) (linha 7). Caso positivo, a condição de otimalidade dual é violada e a função devolve \texttt{False} (linha 8).

A função devolve \texttt{True} se todos os conjuntos em \texttt{Dual\_list} possuem exatamente um arco entrando na arborescência, confirmando que a solução satisfaz as condições de folga complementar da programação linear dual. A complexidade é \(O(km)\), onde \(k = |\texttt{Dual\_list}|\) e \(m = |A|\), pois para cada conjunto dual verifica-se todos os arcos da arborescência.

Esta verificação é fundamental para garantir a correção do algoritmo: a Fase~1 constrói uma solução dual viável (potenciais \(y(v)\)), a Fase~2 constrói uma solução primal viável (arborescência), e esta função confirma que ambas satisfazem as condições de folga complementar, implicando otimalidade pelo teorema da dualidade forte.

\begin{tcolorbox}[
		enhanced, breakable,
		colframe=blue!60!black, colback=blue!2,
		colbacktitle=blue!15, coltitle=black,
		title={Verificação de otimalidade dual},
		boxed title style={sharp corners, boxrule=0.6pt},
		sharp corners, boxrule=0.6pt
	]
	\emph{Verifica se a condição de otimalidade dual é satisfeita, confirmando que cada conjunto dual possui exatamente um arco entrando na arborescência.}
	\tcblower
	\begin{lstlisting}[language=Python]
def check_dual_optimality_condition(Arb, Dual_list):
    for X, z in Dual_list:
        count = 0
        for u, v in Arb.edges():
            if u not in X and v in X:
                count += 1
                if count > 1:
                    return False
    return True
\end{lstlisting}
\end{tcolorbox}

\subsection{O algoritmo completo de András Frank}

Finalmente, apresentamos a função principal que implementa o algoritmo de András Frank para encontrar uma r-arborescência de custo mínimo em um dígrafo com pesos. A função integra as fases de construção dos potenciais duais, obtenção dos arcos justos, construção da arborescência e verificação de otimalidade dual.

\begin{tcolorbox}[
		enhanced, breakable,
		colframe=blue!60!black, colback=blue!2,
		colbacktitle=blue!15, coltitle=black,
		title={Verificação de otimalidade dual},
		boxed title style={sharp corners, boxrule=0.6pt},
		sharp corners, boxrule=0.6pt
	]
	\emph{Implementa o algoritmo completo de András Frank, integrando as fases de construção dos potenciais duais, obtenção dos arcos justos, construção da arborescência e verificação de otimalidade dual.}
	\tcblower
	\begin{lstlisting}[language=Python]
def andras_frank_algorithm(D):
    A_zero, Dual_list = phase1(D,"r0")
    arborescence_frank = phase2(D, "r0", A_zero)
    arborescence_frank_v2 = phase2_v2(D, "r0", A_zero)
    dual_frank = check_dual_optimality_condition(
        arborescence_frank, Dual_list)
    dual_frank_v2 = check_dual_optimality_condition(
        arborescence_frank_v2, Dual_list)
    return arborescence_frank, arborescence_frank_v2, dual_frank, dual_frank_v2
\end{lstlisting}
\end{tcolorbox}

\subsection*{Exemplo de execução do algoritmo}

Aqui ilustraremos cada fase do algoritmo de András Frank: inicialização dos potenciais, iterações de elevação, construção de \(A_0\), e formação da arborescência final. Utilizaremos o dígrafo \(D_{32}\) estendido com a raiz \(r_0\), mostrado na Figura~\ref{fig:frank-exemplo-inicial}.

\begin{figure}[H]
	\centering
	\begin{tikzpicture}[>=Stealth, scale=0.9, every node/.style={scale=0.9}]
		\tikzset{
			vtx/.style={circle, draw, fill=blue!8, thick, inner sep=1.2pt, minimum size=6.5mm},
			vtxRoot/.style={circle, draw, fill=red!15, thick, inner sep=1.2pt, minimum size=6.5mm},
			arc/.style={->, thick, gray!60},
			cost/.style={font=\scriptsize, fill=white, inner sep=1pt, rounded corners=1pt}
		}

		\node[font=\bfseries, blue!80!black] at (3, 4.5) {Dígrafo inicial $D$ com raiz $r_0$};

		% Raiz
		\node[vtxRoot] (r0) at (3, 3) {$r_0$};

		% Vértices camada 1
		\node[vtx] (u1) at (0, 1.5) {$u_1$};
		\node[vtx] (u2) at (3, 1.5) {$u_2$};
		\node[vtx] (u3) at (6, 1.5) {$u_3$};

		% Vértices camada 2
		\node[vtx] (v1) at (1, 0) {$v_1$};
		\node[vtx] (v2) at (3, 0) {$v_2$};
		\node[vtx] (v3) at (5, 0) {$v_3$};

		% Arcos da raiz
		\draw[arc] (r0) -- node[cost, left, pos=0.4] {1} (u1);
		\draw[arc] (r0) -- node[cost, right] {2} (u2);
		\draw[arc] (r0) -- node[cost, right, pos=0.4] {1} (u3);

		% Arcos camada 1
		\draw[arc] (u1) to[bend left=15] node[cost, above] {1} (u2);
		\draw[arc] (u2) to[bend left=15] node[cost, above] {3} (u3);

		% Arcos entrando camada 2
		\draw[arc] (u1) -- node[cost, left] {3} (v1);
		\draw[arc] (u2) -- node[cost, right] {2} (v2);
		\draw[arc] (u3) -- node[cost, right] {4} (v3);
		\draw[arc] (u1) to[bend right=20] node[cost, below, pos=0.3] {5} (v2);

		% Arcos internos camada 2
		\draw[arc] (v1) -- node[cost, above] {1} (v2);
		\draw[arc] (v2) -- node[cost, above] {2} (v3);

		% Arco retorno
		\draw[arc] (v1) to[bend right=30] node[cost, left, pos=0.3] {2} (u1);

		\node[font=\small, gray!70!black] at (3, -1.2) {Pesos originais $c(u,v)$};
	\end{tikzpicture}
	\caption{Dígrafo inicial \(D\) com raiz \(r_0\) e 6 vértices adicionais. O dígrafo contém múltiplos arcos com pesos variados. A Fase~1 do algoritmo iniciará com potenciais \(y(v) = 0\) para todos os vértices, correspondendo aos custos reduzidos iniciais \(c_y(u,v) = c(u,v)\).}
	\label{fig:frank-exemplo-antigo-inicial}
\end{figure}

\paragraph*{Fase 1 — Iteração 1:} O algoritmo inicia com todos os potenciais \(y(v) = 0\) e \(D_0\) vazio (sem arcos justos). Calcula-se as componentes fortemente conexas de \(D_0\): cada vértice forma sua própria componente. As fontes são todos os vértices exceto \(r_0\). Para o conjunto \(X = \{u_1, u_2, u_3\}\), identifica-se os arcos entrando: \((r_0, u_1)\) com peso 1, \((r_0, u_2)\) com peso 2, \((r_0, u_3)\) com peso 1. O mínimo é \(\Delta(X) = 1\). Subtraindo esse valor, os arcos \((r_0, u_1)\) e \((r_0, u_3)\) tornam-se justos (peso 0) e são adicionados a \(A_0\).

\begin{figure}[H]
	\centering
	\begin{tikzpicture}[>=Stealth, scale=0.85, every node/.style={scale=0.85}]
		\tikzset{
			vtx/.style={circle, draw, fill=blue!8, thick, inner sep=1.2pt, minimum size=6.5mm},
			vtxRoot/.style={circle, draw, fill=red!15, thick, inner sep=1.2pt, minimum size=6.5mm},
			vtxX/.style={circle, draw, fill=orange!20, thick, inner sep=1.2pt, minimum size=6.5mm},
			arc/.style={->, thick, gray!60},
			arcTight/.style={->, ultra thick, blue!70!black},
			cost/.style={font=\scriptsize, fill=white, inner sep=1pt},
			costTight/.style={font=\scriptsize\bfseries, fill=blue!10, inner sep=2pt, draw=blue!70!black, rounded corners=1pt}
		}

		% Antes
		\begin{scope}
			\node[font=\bfseries, blue!80!black] at (2, 4.5) {Antes: $\Delta(X_1) = 1$};

			\node[vtxRoot] (r0) at (2, 3) {$r_0$};
			\node[vtxX] (u1) at (0, 1.5) {$u_1$};
			\node[vtxX] (u2) at (2, 1.5) {$u_2$};
			\node[vtxX] (u3) at (4, 1.5) {$u_3$};

			\draw[arc] (r0) -- node[cost, left, pos=0.4] {1} (u1);
			\draw[arc] (r0) -- node[cost, right] {2} (u2);
			\draw[arc] (r0) -- node[cost, right, pos=0.4] {1} (u3);

			\node[font=\small, orange!80!black] at (2, 0.5) {$X_1 = \{u_1, u_2, u_3\}$};
		\end{scope}

		% Depois
		\begin{scope}[xshift=7cm]
			\node[font=\bfseries, blue!80!black] at (2, 4.5) {Depois: arcos justos};

			\node[vtxRoot] (r0b) at (2, 3) {$r_0$};
			\node[vtx] (u1b) at (0, 1.5) {$u_1$};
			\node[vtx] (u2b) at (2, 1.5) {$u_2$};
			\node[vtx] (u3b) at (4, 1.5) {$u_3$};

			\draw[arcTight] (r0b) -- node[costTight, left, pos=0.4] {0} (u1b);
			\draw[arc] (r0b) -- node[cost, right] {1} (u2b);
			\draw[arcTight] (r0b) -- node[costTight, right, pos=0.4] {0} (u3b);

			\node[font=\small, blue!70!black] at (2, 0.5) {2 arcos adicionados a $A\_0$};
		\end{scope}
	\end{tikzpicture}
	\caption{Fase~1, Iteração 1: Elevação de potenciais para \(X\_1 = \{u\_1, u\_2, u\_3\}\). À esquerda, o conjunto \(X\_1\) (em laranja) sem arcos justos entrando. Calcula-se \(\Delta(X\_1) = \min\{1, 2, 1\} = 1\). À direita, após subtrair \(\Delta(X_1)\), os arcos \((r\_0, u\_1)\) e \((r\_0, u\_3)\) tornam-se \textcolor{blue!70!black}{justos} (custo reduzido 0) e são adicionados a \(A\_0\).}
	\label{fig:frank-exemplo-iter1}
\end{figure}

\paragraph*{Fase 1 — Iteração 2:} Com \(A\_0 = \{(r\_0, u\_1), (r\_0, u\_3)\}\), as componentes fortemente conexas são: \(\{r\_0, u\_1, u\_3\}\) e \(\{u\_2\}\), \(\{v\_1\}\), \(\{v\_2\}\), \(\{v\_3\}\). A fonte (excluindo a raiz) é \(\{u\_2\}\). Para \(X = \{u\_2\}\), o único arco entrando é \((r\_0, u\_2)\) com peso atual 1 (após iteração anterior). Portanto \(\Delta(X) = 1\), e após subtração, \((r\_0, u\_2)\) torna-se justo. Também na mesma iteração, para \(X = \{v\_1, v\_2, v\_3\}\), calcula-se \(\Delta(X) = \min\{3, 2, 4, 5\} = 2\), e os arcos são atualizados conforme ilustrado.

\begin{figure}[H]
	\centering
	\begin{tikzpicture}[>=Stealth, scale=0.75, every node/.style={scale=0.75}]
		\tikzset{
			vtx/.style={circle, draw, fill=blue!8, thick, inner sep=1.2pt, minimum size=6mm},
			vtxRoot/.style={circle, draw, fill=red!15, thick, inner sep=1.2pt, minimum size=6mm},
			vtxX/.style={circle, draw, fill=orange!20, thick, inner sep=1.2pt, minimum size=6mm},
			arc/.style={->, thick, gray!60},
			arcTight/.style={->, ultra thick, blue!70!black},
			cost/.style={font=\scriptsize, fill=white, inner sep=1pt},
			costTight/.style={font=\scriptsize\bfseries, fill=blue!10, inner sep=2pt, draw=blue!70!black, rounded corners=1pt}
		}

		\node[font=\bfseries, blue!80!black] at (3, 5.5) {Iteração 2: $\Delta(\{v_1, v_2, v_3\}) = 2$};

		\node[vtxRoot] (r0) at (3, 4) {$r_0$};
		\node[vtx] (u1) at (0.5, 2.5) {$u_1$};
		\node[vtx] (u2) at (3, 2.5) {$u_2$};
		\node[vtx] (u3) at (5.5, 2.5) {$u_3$};
		\node[vtxX] (v1) at (1.5, 0.5) {$v_1$};
		\node[vtxX] (v2) at (3, 0.5) {$v_2$};
		\node[vtxX] (v3) at (4.5, 0.5) {$v_3$};

		% Arcos já justos
		\draw[arcTight] (r0) -- node[costTight, left, pos=0.3] {0} (u1);
		\draw[arcTight] (r0) -- node[costTight, right, pos=0.3] {0} (u3);
		\draw[arcTight] (u1) to[bend left=12] node[costTight, above] {0} (u2);

		% Arcos entrando em X (antes de ficarem justos)
		\draw[arc] (u1) -- node[cost, left, fill=orange!10] {3→1} (v1);
		\draw[arc] (u2) -- node[cost, right, fill=orange!10] {2→0} (v2);
		\draw[arc] (u3) -- node[cost, right] {4→2} (v3);
		\draw[arc] (u1) to[bend right=15] node[cost, below, pos=0.35] {5→3} (v2);

		\node[font=\small, orange!80!black] at (3, -0.5) {Após subtração: $(u_2, v_2)$ torna-se justo};
	\end{tikzpicture}
	\caption{Fase~1, Iteração 2: Para o conjunto \(X = \{v_1, v_2, v_3\}\) (em laranja), calcula-se \(\Delta(X) = \min\{3, 2, 4, 5\} = 2\). Após subtrair esse valor dos arcos entrando em \(X\), o arco \((u_2, v_2)\) atinge custo reduzido 0 e é adicionado a \(A_0\). Note que \((u_1, u_2)\) também se tornou justo na mesma iteração ao processar \(X = \{u_2\}\).}
	\label{fig:frank-exemplo-iter2}
\end{figure}

\paragraph*{Fase 1 — Estado final:} Após mais iterações elevando potenciais para os conjuntos restantes, o dígrafo \(D_0\) de arcos justos fica completo, contendo uma r-arborescência. A Figura~\ref{fig:frank-exemplo-A0-final} mostra o conjunto final \(A_0\) com 6 arcos de custo reduzido zero.

\begin{figure}[H]
	\centering
	\begin{tikzpicture}[>=Stealth, scale=0.85, every node/.style={scale=0.85}]
		\tikzset{
			vtx/.style={circle, draw, fill=blue!8, thick, inner sep=1.2pt, minimum size=6.5mm},
			vtxRoot/.style={circle, draw, fill=red!15, thick, inner sep=1.2pt, minimum size=6.5mm},
			arcTight/.style={->, ultra thick, blue!70!black},
			costTight/.style={font=\scriptsize\bfseries, fill=blue!10, inner sep=2pt, draw=blue!70!black, rounded corners=1pt}
		}

		\node[font=\bfseries, blue!80!black] at (3, 4.5) {$A_0$ final: arcos justos após Fase~1};

		\node[vtxRoot] (r0) at (3, 3) {$r_0$};
		\node[vtx] (u1) at (0.5, 1.5) {$u_1$};
		\node[vtx] (u2) at (3, 1.5) {$u_2$};
		\node[vtx] (u3) at (5.5, 1.5) {$u_3$};
		\node[vtx] (v1) at (1.5, 0) {$v_1$};
		\node[vtx] (v2) at (3, 0) {$v_2$};
		\node[vtx] (v3) at (4.5, 0) {$v_3$};

		\draw[arcTight] (r0) -- node[costTight, left, pos=0.3] {0} (u1);
		\draw[arcTight] (r0) -- node[costTight, right, pos=0.3] {0} (u3);
		\draw[arcTight] (u1) to[bend left=12] node[costTight, above] {0} (u2);
		\draw[arcTight] (u1) -- node[costTight, left] {0} (v1);
		\draw[arcTight] (u2) -- node[costTight, right] {0} (v2);
		\draw[arcTight] (v2) -- node[costTight, above] {0} (v3);

		\node[font=\small, blue!70!black] at (3, -1.2) {$|A_0| = 6$ arcos com custo reduzido $c_y = 0$};
	\end{tikzpicture}
	\caption{Conjunto final \(A_0\) de arcos justos após conclusão da Fase~1. Todos os 6 arcos \textcolor{blue!70!black}{destacados} possuem custo reduzido zero: \((r_0, u_1)\), \((r_0, u_3)\), \((u_1, u_2)\), \((u_1, v_1)\), \((u_2, v_2)\), \((v_2, v_3)\). O dígrafo formado por esses arcos é acíclico e alcança todos os vértices a partir de \(r_0\), satisfazendo as condições para prosseguir à Fase~2.}
	\label{fig:frank-exemplo-A0-final}
\end{figure}

\paragraph*{Fase 2 — Construção da arborescência:} Com \(A_0\) completo e acíclico, a Fase~2 constrói incrementalmente a arborescência final. Inicia-se com \(\texttt{Arb} = \{r_0\}\) e em cada iteração adiciona-se um arco \((u,v) \in A_0\) tal que \(u \in \texttt{Arb}\) e \(v \notin \texttt{Arb}\). A Figura~\ref{fig:frank-exemplo-arborescencia-final} mostra a arborescência resultante.

\begin{figure}[H]
	\centering
	\begin{tikzpicture}[>=Stealth, scale=0.85, every node/.style={scale=0.85}]
		\tikzset{
			vtx/.style={circle, draw, fill=green!15, thick, inner sep=1.2pt, minimum size=6.5mm},
			vtxRoot/.style={circle, draw, fill=red!15, thick, inner sep=1.2pt, minimum size=6.5mm},
			arcArb/.style={->, ultra thick, green!70!black},
			costArb/.style={font=\scriptsize\bfseries, fill=green!10, inner sep=2pt, draw=green!70!black, rounded corners=1pt}
		}

		\node[font=\bfseries, blue!80!black] at (3, 4.5) {Arborescência final (Fase~2)};

		\node[vtxRoot] (r0) at (3, 3) {$r_0$};
		\node[vtx] (u1) at (0.5, 1.5) {$u_1$};
		\node[vtx] (u2) at (3, 1.5) {$u_2$};
		\node[vtx] (u3) at (5.5, 1.5) {$u_3$};
		\node[vtx] (v1) at (1.5, 0) {$v_1$};
		\node[vtx] (v2) at (3, 0) {$v_2$};
		\node[vtx] (v3) at (4.5, 0) {$v_3$};

		\draw[arcArb] (r0) -- node[costArb, left, pos=0.3] {1} (u1);
		\draw[arcArb] (r0) -- node[costArb, right, pos=0.3] {1} (u3);
		\draw[arcArb] (u1) to[bend left=12] node[costArb, above] {1} (u2);
		\draw[arcArb] (u1) -- node[costArb, left] {3} (v1);
		\draw[arcArb] (u2) -- node[costArb, right] {2} (v2);
		\draw[arcArb] (v2) -- node[costArb, above] {2} (v3);

		\node[font=\small, green!70!black] at (3, -1.2) {Custo total: $1+1+1+3+2+2 = 10$};
	\end{tikzpicture}
	\caption{Arborescência de custo mínimo final obtida pela Fase~2. Os pesos mostrados são os \emph{originais} de \(D\), restaurados após a construção. Cada vértice não-raiz possui exatamente um arco de entrada, não há ciclos, e todos os vértices são alcançáveis a partir de \(r_0\). A verificação de otimalidade dual confirma que cada conjunto \(X\) que teve potenciais elevados possui exatamente um arco da arborescência cruzando sua fronteira, garantindo que a solução é ótima.}
	\label{fig:frank-exemplo-arborescencia-final}
\end{figure}

\paragraph*{Verificação de otimalidade dual:} A função \texttt{check\_dual\_optimality\_condition} confirma que para cada par \((X, \Delta(X))\) em \texttt{Dual\_list} (conjuntos cujos potenciais foram elevados com \(\Delta(X) > 0\)), existe exatamente um arco da arborescência final cruzando a fronteira de \(X\). Essa condição, juntamente com os arcos justos, garante que as condições de folga complementar da programação linear dual são satisfeitas, implicando que a arborescência encontrada é de custo mínimo global.

\subsection{Correspondência entre teoria e implementação}

A implementação em Python do algoritmo de András Frank segue fielmente a descrição teórica primal-dual apresentada anteriormente. A tabela abaixo estabelece o paralelo direto entre os passos teóricos e sua realização no código:

\begin{table}[H]
	\centering
	\scriptsize
	\renewcommand{\arraystretch}{1.3}
	\begin{tabular}{>{\raggedright\arraybackslash}p{0.44\textwidth}|>{\raggedright\arraybackslash}p{0.48\textwidth}}
		\toprule
		\textbf{\normalsize Descrição Teórica} & \textbf{\normalsize Implementação Python} \\
		\midrule
		\rowcolor{blue!5}
		\textbf{Passo 1:} Inicialização

		Defina \(y(v) := 0\) para todo \(v \in V\).

		Inicialize \(A_0 := \emptyset\).

		Construa dígrafo vazio \(D_0\) (arcos justos).
		                                       &
		\textbf{Função \texttt{phase1} — Linhas 2--5:}

		\texttt{D\_copy = D\_original.copy()}

		\texttt{A\_zero = []}

		\texttt{D\_zero = build\_D\_zero(D\_copy)}

		\vspace{1mm}
		Potenciais \(y(v) = 0\) implícitos, custos \(c_y = c\).
		\\
		\midrule
		\rowcolor{green!5}
		\textbf{Passo 2:} Elevação de potenciais

		Enquanto \(\exists X \subseteq V \setminus \{r\}\) sem arco justo:

		\quad Calcule \(\Delta(X) := \min\{c_y(u,v) : u \notin X, v \in X\}\)

		\quad Atualize \(y(v) := y(v) + \Delta(X)\), \(\forall v \in X\)

		\quad Adicione arcos com \(c_y = 0\) a \(A_0\)
		                                       &
		\textbf{Loop principal — Linhas 7--22:}

		\texttt{C = nx.condensation(D\_zero)}

		\texttt{sources = [x for x in C.nodes()]}

		\texttt{\quad if C.in\_degree(x) == 0]}

		Para fonte \texttt{u} (exceto raiz):

		\texttt{\quad X = C.nodes[u]["members"]}

		\texttt{\quad arcs = get\_arcs\_entering\_X(D, X)}

		\texttt{\quad min\_w = get\_minimum\_weight\_cut(arcs)}

		\texttt{\quad update\_weights\_in\_X(D, arcs, min\_w,}

		\texttt{\quad\quad A\_zero, D\_zero)}
		\\
		\midrule
		\rowcolor{orange!5}
		\textbf{Passo 2(a):} Identificar arcos entrando

		Determine \(\{(u,v) \in A : u \notin X, v \in X\}\)
		                                       &
		\textbf{Função \texttt{get\_arcs\_entering\_X}:}

		\texttt{return [(u, v, data)}

		\texttt{\quad for u, v, data in D.edges(data=True)}

		\texttt{\quad if u not in X and v in X]}
		\\
		\midrule
		\rowcolor{purple!5}
		\textbf{Passo 2(b):} Calcular \(\Delta(X)\)

		\(\Delta(X) := \min\{c_y(u,v) : u \notin X, v \in X\}\)
		                                       &
		\textbf{Função \texttt{get\_minimum\_weight\_cut}:}

		\texttt{return min(data["w"]}

		\texttt{\quad for \_, \_, data in arcs)}
		\\
		\midrule
		\rowcolor{yellow!5}
		\textbf{Passo 2(c):} Atualizar pesos

		Para \((u,v)\) entrando em \(X\):

		\quad \(c_y(u,v) := c_y(u,v) - \Delta(X)\)

		\quad Se \(c_y(u,v) = 0\), adicione a \(A_0\)
		                                       &
		\textbf{Função \texttt{update\_weights\_in\_X}:}

		\texttt{for u, v, \_ in arcs:}

		\texttt{\quad D[u][v]["w"] -= min\_weight}

		\texttt{\quad if D[u][v]["w"] == 0:}

		\texttt{\quad\quad A\_zero.append((u, v))}

		\texttt{\quad\quad D\_zero.add\_edge(u, v)}
		\\
		\midrule
		\rowcolor{cyan!5}
		\textbf{Passo 3:} Verificar término

		Se \(D_0\) contém r-arborescência, encerre.
		                                       &
		\textbf{Condição — Linhas 11--12:}

		\texttt{if len(sources) == 1: break}

		\vspace{1mm}
		Uma fonte \(\Rightarrow\) r-arborescência acíclica.
		\\
		\midrule
		\rowcolor{red!5}
		\textbf{Passo 4:} Construir arborescência

		Construa \(F\) a partir de \(A_0\), conectando vértices incrementalmente.
		                                       &
		\textbf{Função \texttt{phase2} (incremental):}

		\texttt{Arb = nx.DiGraph(); Arb.add\_node(r0)}

		\texttt{for \_ in range(n - 1):}

		\texttt{\quad for u, v in A\_zero:}

		\texttt{\quad\quad if u in Arb and v not in Arb:}

		\texttt{\quad\quad\quad Arb.add\_edge(u, v, **data)}

		\texttt{\quad\quad\quad break}

		\vspace{1mm}
		Complexidade: \(O(nm)\).
		\\
		\midrule
		\rowcolor{red!5}
		\textbf{Passo 4:} Versão otimizada

		Mesma ideia, com fila de prioridade.
		                                       &
		\textbf{Função \texttt{phase2\_v2} (BFS):}

		\texttt{Arb = nx.DiGraph()}

		\texttt{for i, (u, v) in enumerate(A\_zero):}

		\texttt{\quad Arb.add\_edge(u, v, w=i)}

		\texttt{q = [] \# fila de prioridade}

		\texttt{while q:}

		\texttt{\quad \_, u, v = heapq.heappop(q)}

		\texttt{\quad if v in V: continue}

		\texttt{\quad A.add\_edge(u, v, w=D[u][v]["w"])}

		\vspace{1mm}
		Complexidade: \(O(m \log m)\).
		\\
		\midrule
		\rowcolor{pink!5}
		\textbf{Otimalidade dual}

		Para cada \(X\) elevado (\(\Delta(X) > 0\)), exatamente um arco de \(F\) cruza \(\delta^-(X)\).
		                                       &
		\textbf{Função \texttt{check\_dual\_optimality}:}

		\texttt{for X, z in Dual\_list:}

		\texttt{\quad count = 0}

		\texttt{\quad for u, v in Arb.edges():}

		\texttt{\quad\quad if u not in X and v in X:}

		\texttt{\quad\quad\quad count += 1}

		\texttt{\quad\quad\quad if count > 1: return False}

		\texttt{return True}
		\\
		\bottomrule
	\end{tabular}
	\caption{Correspondência entre a descrição teórica do algoritmo de András Frank e sua implementação em Python. Cores: inicialização (azul), elevação de potenciais (verde/laranja/roxo/amarelo), verificação (ciano), construção (vermelho) e validação dual (rosa).}
	\label{tab:frank-teoria-implementacao}
\end{table}

Esta correspondência demonstra que a implementação traduz fielmente a abordagem primal-dual em código executável. As funções auxiliares (\texttt{get\_arcs\_entering\_X}, \texttt{get\_minimum\_weight\_cut}, \texttt{update\_weights\_in\_X}, \texttt{phase1}, \texttt{phase2}, \texttt{phase2\_v2},
\texttt{check\_dual\_}-
\texttt{optimality\_condition} encapsulam exatamente as operações descritas na teoria, preservando as propriedades de correção e as garantias de otimalidade do algoritmo original. A utilização de componentes fortemente conexas (\texttt{nx.condensation}) para identificar conjuntos sem arcos justos entrando é uma implementação eficiente da verificação teórica, evitando enumeração explícita de todos os subconjuntos de vértices.
