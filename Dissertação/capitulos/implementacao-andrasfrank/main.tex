\chapter{Algoritmo Guloso–Dual de András Frank}

Assim como o algoritmo de Chu–Liu/Edmonds, o método de András Frank resolve o problema da r-arborescência de custo mínimo em digrafos ponderados. A diferença está na abordagem: Frank utiliza uma estrutura gulosa–dual.

O algoritmo de Frank é dividido em duas fases, conforme a descrição abaixo:

\begin{tcolorbox}[
		enhanced, breakable,
		colframe=blue!60!black, colback=blue!2,
		colbacktitle=blue!15, coltitle=black,
		title={Algoritmo de András Frank},
		boxed title style={sharp corners, boxrule=0.6pt},
		sharp corners, boxrule=0.6pt
	]
	\textbf{Fase I — Elevação de potenciais (dual):}
	\begin{itemize}
		\item Para cada vértice $v \neq r$, eleva-se o potencial $y(v)$ até que exista ao menos um arco de custo reduzido zero entrando em $v$.
		\item Sempre que um ciclo de arcos de custo zero surgir, contrai-se esse ciclo em um supervértice, ajustando os custos conforme a regra dual.
		\item O resultado é um subgrafo $D_0$ onde cada vértice não-raiz tem ao menos uma entrada de custo zero.
	\end{itemize}
	\vspace{2mm}
	\textbf{Fase II — Extração primal:}
	\begin{itemize}
		\item Seleciona-se exatamente uma entrada de custo zero para cada vértice $v \neq r$.
		\item Se as escolhas formarem um ciclo, contrai-se e repete o processo no grafo menor; ao final, reexpande cada contração removendo uma aresta interna para restaurar a estrutura de arborescência.
		\item O resultado é uma r-arborescência ótima, composta apenas por arcos apertados.
	\end{itemize}
\end{tcolorbox}

Vamos ilustrar o funcionamento das fase 1 e 2 com um exemplo.

Consideremos então o mesmo digrafo que apresentamos como exemplo na sessão de chuliu/edmonds, e vamos mostrar o comportamento do algortimo de andras frank sobre ele.




\section{Implementação em Python}

Assim como no capítulo anterior, a implementação é modular e didática, com funções auxiliares para cada etapa do algoritmo. Utilizamos a biblioteca NetworkX para manipulação de digrafos e mantemos a clareza e paralelismo com a teoria.

\begin{tcolorbox}[
		enhanced, breakable,
		colframe=blue!60!black, colback=blue!2,
		colbacktitle=blue!15, coltitle=black,
		title={Funções auxiliares da implementação},
		boxed title style={sharp corners, boxrule=0.6pt},
		sharp corners, boxrule=0.6pt
	]
	\textbf{get\_arcs\_entering\_X(D, X):} retorna as arestas que entram em $X$.

	\textbf{get\_minimum\_weight\_cut(arcs):} retorna o peso mínimo entre as arestas que entram em $X$.

	\textbf{update\_weights\_in\_X(D, arcs, min\_weight, A\_zero, D\_zero):} atualiza os pesos das arestas que entram em $X$, subtraindo o valor mínimo e registrando as que atingem peso zero.

	\textbf{has\_arborescence(D, r0):} verifica se o digrafo possui uma arborescência com raiz $r_0$.
\end{tcolorbox}

\section{Exemplo de execução do algoritmo}

Considere o digrafo da Figura~\ref{fig:frank-exemplo-potenciais}. A Fase I eleva os potenciais até que cada vértice não-raiz tenha ao menos uma entrada de custo zero. Se um ciclo de arcos de custo zero surgir, ele é contraído. A Fase II seleciona uma entrada de custo zero para cada vértice, tratando ciclos por contração e reexpansão, até obter a r-arborescência ótima.

\begin{figure}[H]
	\centering
	% Exemplo de execução do algoritmo de Frank
	%\input{capitulos/implementacao-andrasfrank/figures/fig_frank_exemplo_execucao.tex}
	\caption{Execução do algoritmo de András Frank: elevação de potenciais, contração de ciclo e extração da arborescência ótima.}
	\label{fig:frank-exemplo-execucao}
\end{figure}

\section{Complexidade e comparação com Chu–Liu/Edmonds}

O algoritmo de Frank tem complexidade $O(mn)$, podendo ser otimizado para $O(m \log n)$ com uso de heaps. A estrutura modular permite comparação direta com o algoritmo de Chu–Liu/Edmonds, tanto em termos de desempenho quanto de clareza conceitual.

\section{Notas finais}

Assim como no capítulo anterior, a implementação e análise do algoritmo de András Frank reforçam a importância da abordagem primal–dual e da estrutura laminar de cortes. A comparação sistemática entre os métodos será apresentada na próxima seção, destacando semelhanças, diferenças e aplicações práticas.
