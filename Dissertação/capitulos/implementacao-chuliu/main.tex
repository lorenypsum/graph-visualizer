\chapter{Algoritmo de Chu–Liu--Edmonds}

Neste capítulo, apresentaremos o algoritmo de Chu--Liu--Edmonds, que determina
uma arborescência de custo mínimo em um digrafo ponderado.
O algoritmo baseia-se em duas operações fundamentais:
(i) a redução gulosa dos custos dos arcos e (ii) a contração de ciclos,
de modo a resolver recursivamente uma instância menor do problema e, em seguida,
estender a solução para o problema original.
O propósito deste capítulo é fornecer uma descrição precisa tanto do algoritmo
quanto da implementação desenvolvida neste trabalho.

\section{O algoritmo}
O algoritmo de Chu--Liu--Edmonds recebe uma tripla \((D,c,r)\), em que \(D=(V,A)\) é um digrafo, \(c\colon A\to\mathbb{R}\) é uma função custo e \(r\in V\) é a raiz, sob a hipótese de que \(D\) admite ao menos uma \(r\)-arborescência. O algoritmo devolve uma \(r\)-arborescência \(c\)-mínima de \(D\).

Para evitar repetir essa hipótese, introduzimos a seguinte definição.
Uma tripla \((D,c, r)\) é um \textbf{\(r\)-digrafo ponderado} se $(D, c)$
é um digrafo ponderado, $r$ é um vértice de $D$, $\delta^-(r) = \varnothing$
e $D$ possui uma $r$-arborescência. Note que a hipótese $\delta^-(r)$ é uma trivialidade,
pois uma $r$-arborescência não contém nenhum arco que entra em $r$ e, portanto,
tais arcos podem ser eliminados de $D$ sem nenhum prejuízo.

Vamos tecer algumas considerações para motivar o algoritmo.

\subsection*{Caráter Guloso}
Suponha doravante que $(D, c, r)$ é um $r$-digrafo ponderado.
O algoritmo tem um caráter guloso. Note que, se \(T\) é uma \(r\)-arborescência de $D$,
então, para cada vértice \(v \neq r\), existe exatamente um arco de \(T\) que entra em \(v\). Isso sugere a seguinte escolha gulosa: para cada vértice \(v \neq r\), selecione um arco \(a_v\) de custo mínimo que entra em \(v\) e forme o conjunto \(T := \{a_v : v \in V \setminus \{r\}\}\).

\begin{figure}[h]
	\centering
	\begin{tikzpicture}[>=Stealth]
		% estilos
		\tikzset{
			vtx/.style={circle, draw, thick, inner sep=1.2pt, minimum size=6mm},
			chosen/.style={->, very thick, draw=blue},
			other/.style={->, semithick, draw=black!35},
			costB/.style={font=\scriptsize, fill=white, inner sep=1pt, text=blue},
			costG/.style={font=\scriptsize, fill=white, inner sep=1pt, text=black!55}
		}

		% layout (mais espaçado)
		\node[vtx] (r) at (0,0) {$r$};
		\node[vtx] (a) at (3,1.6) {$a$};
		\node[vtx] (b) at (3,-1.6) {$b$};
		\node[vtx] (c) at (6,2.2) {$c$};
		\node[vtx] (d) at (6,0.0) {$d$};
		\node[vtx] (e) at (6,-2.2) {$e$};

		% --- arcos NÃO escolhidos (cinza), agora com curvaturas mais limpas ---
		\draw[other] (b) to[bend left=12] node[costG, above] {4} (a);   % b->a
		\draw[other] (a) to[bend left=14] node[costG, below] {5} (b);   % a->b

		% r->c: externo por cima, suave (pontos de controle explícitos)
		\draw[other]
		(r) .. controls (0.8,2.4) and (5.2,3.0) ..
		node[costG, yshift=4pt, pos=0.53] {3} (c);

		% a->d (referência)
		\draw[other] (a) -- node[costG, right] {3} (d);

		% c->e: leve curvatura pela direita (sem "barriga")
		\draw[other]
		(c) .. controls (7.6,2.6) and (7.6,-2.6) ..
		node[costG, xshift=8pt, pos=0.52] {5} (e);

		% --- arcos ESCOLHIDOS (AZUL) — formam a r-arborescência T ---
		\draw[chosen] (r) -- node[costB, above] {1} (a);   % r->a
		\draw[chosen] (r) -- node[costB, below] {2} (b);   % r->b
		\draw[chosen] (a) -- node[costB, above] {1} (c);   % a->c
		\draw[chosen] (b) -- node[costB, above] {1} (d);   % b->d
		\draw[chosen] (b) -- node[costB, below] {2} (e);   % b->e

		% legenda compacta
		\node[align=left, anchor=west] at (8.4,1.9) {\footnotesize \textbf{Escolha gulosa:}\\[-2pt]
			\footnotesize para cada \(v\neq r\), escolher\\[-1pt]
			\footnotesize um arco de custo mínimo\\[-1pt]
			\footnotesize que entra em \(v\).};
		\draw[chosen] (9.0,0.8) -- +(0.9,0) node[right, costB] {\footnotesize arcos de \(T\)};
		\draw[other]  (9.0,0.2) -- +(0.9,0) node[right, costG] {\footnotesize demais arcos};
	\end{tikzpicture}

	\caption{A figura ilustra a escolha gulosa quando esta produz uma $r$-arborescência.
		Os arcos em \textcolor{blue}{azul} são os escolhidos; os cinza são os demais arcos
		do digrafo.}
\end{figure}

Suponha que \(T\) é uma \(r\)-arborescência. Não é difícil verificar que \(T\) tem custo mínimo.
De fato, seja \(F\) uma \(r\)-arborescência de \(D\). Para cada vértice \(v \neq r\), escreva \(b_v\) para o \emph{único} arco de \(F\) que entra em \(v\). Pela escolha gulosa,
\[
	c(a_v) \leq c(b_v) \quad \text{para todo } v \neq r.
\]
Logo,
\[
	c(F) \;=\; \sum_{v \in V \setminus \{r\}} c(b_v)
	\;\;\geq\;\; \sum_{v \in V \setminus \{r\}} c(a_v)
	\;=\; c(T).
\]
Portanto, \(T\) é uma \(r\)-arborescência de custo mínimo.

A seguinte figura ilustra que podemos não ter tanta sorte.
\begin{figure}[H]
	\centering
	\begin{tikzpicture}[>=Stealth, node distance=2.0cm]
		% estilos
		\tikzset{
			v/.style={circle, draw, fill=blue!8, minimum size=7mm, inner sep=0pt},
			cheap/.style={->, very thick, draw=blue!70},
			expensive/.style={->, dashed, draw=gray!60}
		}
		% vértices
		\node[v] (r) {\small $r$};
		\node[v] (a) [right=2.2cm of r] {\small $a$};
		\node[v] (b) [above right=1.2cm and 1.6cm of a] {\small $b$};
		\node[v] (c) [below right=1.2cm and 1.6cm of a] {\small $c$};
		% ciclo de escolhas mais baratas (custo 1)
		\draw[cheap] (a) to[bend left=12] node[midway, above, sloped] {\scriptsize 3} (b);
		\draw[cheap] (b) to[bend left=12] node[midway, above, sloped] {\scriptsize 2} (c);
		\draw[cheap] (c) to[bend left=14] node[midway, below, sloped] {\scriptsize 3} (a);
		% arcos da raiz mais caros (não escolhidos pelo critério local)
		\draw[expensive] (r) to[bend left=8] node[midway, above, sloped] {\scriptsize 3} (a);
		\draw[expensive] (r) to[bend left=18] node[midway, above, sloped] {\scriptsize 4} (b);
		\draw[expensive] (r) to[bend right=10] node[midway, below, sloped] {\scriptsize 5} (c);
	\end{tikzpicture}
	\caption{Os arcos azuis são os da escolha gulosa.}
\end{figure}
Ora, se no lugar do arco $(c,a)$ tivessemos escolhido o arco $(r, a)$, então
$r$-arborescência resultante seria de custo mínimo.
\begin{figure}[H]
	\centering
	\begin{tikzpicture}[>=Stealth, node distance=2.0cm]
		% estilos
		\tikzset{
			v/.style={circle, draw, fill=blue!8, minimum size=7mm, inner sep=0pt},
			cheap/.style={->, very thick, draw=blue!70},
			expensive/.style={->, dashed, draw=gray!60}
		}
		% vértices
		\node[v] (r) {\small $r$};
		\node[v] (a) [right=2.2cm of r] {\small $a$};
		\node[v] (b) [above right=1.2cm and 1.6cm of a] {\small $b$};
		\node[v] (c) [below right=1.2cm and 1.6cm of a] {\small $c$};
		% ciclo de escolhas mais baratas (custo 1)
		\draw[cheap] (a) to[bend left=12] node[midway, above, sloped] {\scriptsize 3} (b);
		\draw[cheap] (b) to[bend left=12] node[midway, above, sloped] {\scriptsize 2} (c);
		\draw[expensive] (c) to[bend left=14] node[midway, below, sloped] {\scriptsize 3} (a);
		% arcos da raiz mais caros (não escolhidos pelo critério local)
		\draw[cheap] (r) to[bend left=8] node[midway, above, sloped] {\scriptsize 3} (a);
		\draw[expensive] (r) to[bend left=18] node[midway, above, sloped] {\scriptsize 4} (b);
		\draw[expensive] (r) to[bend right=10] node[midway, below, sloped] {\scriptsize 5} (c);
	\end{tikzpicture}
	\caption{Os arcos azuis são os da escolha gulosa.}
\end{figure}

O exemplo acima sugere que devemos formar o subdigrafo $H$ de $D$
com \(V(H)=V(D)\) e
\[
	A(H)\;:=\; \bigcup_{v \in V \setminus \{r\}}
	\arg\min\{\, c(a) : a \in \delta^{-}(v) \,\}.
\]
Ou seja, para cada \(v \neq r\) incluímos em \(H\) \emph{todos} os arcos de custo mínimo que entram em \(v\).
Um argumento análogo ao anterior mostra que, se \(H\) contém uma \(r\)-arborescência, então ela é de custo mínimo.

Infelizmente, só isso não é suficiente, como mostra a próxima figura.
\begin{figure}[H]
	\centering
	\begin{tikzpicture}[>=Stealth, node distance=2.0cm]
		% estilos
		\tikzset{
			v/.style={circle, draw, fill=blue!8, minimum size=7mm, inner sep=0pt},
			cheap/.style={->, very thick, draw=blue!70},
			expensive/.style={->, dashed, draw=gray!60}
		}
		% vértices
		\node[v] (r) {\small $r$};
		\node[v] (a) [right=2.2cm of r] {\small $a$};
		\node[v] (b) [above right=1.2cm and 1.6cm of a] {\small $b$};
		\node[v] (c) [below right=1.2cm and 1.6cm of a] {\small $c$};
		% ciclo de escolhas mais baratas (custo 1)
		\draw[cheap] (a) to[bend left=12] node[midway, above, sloped] {\scriptsize 3} (b);
		\draw[cheap] (b) to[bend left=12] node[midway, above, sloped] {\scriptsize 2} (c);
		\draw[cheap] (c) to[bend left=14] node[midway, below, sloped] {\scriptsize 1} (a);
		% arcos da raiz mais caros (não escolhidos pelo critério local)
		\draw[expensive] (r) to[bend left=8] node[midway, above, sloped] {\scriptsize 3} (a);
		\draw[expensive] (r) to[bend left=18] node[midway, above, sloped] {\scriptsize 4} (b);
		\draw[expensive] (r) to[bend right=10] node[midway, below, sloped] {\scriptsize 5} (c);
	\end{tikzpicture}
	\caption{Os arcos azuis são os da escolha gulosa.}
	\label{fig:antes:red}
\end{figure}

O ideal, do ponto de vista algorítmico, é dispor de uma forma simples de identificar o subdigrafo \(H\).
Uma transformação nos custos fornece exatamente isso. Para tanto, introduzimos a noção de
\textbf{custo \(q\)-reduzido}.

Seja \(q : V \setminus \{r\} \to \mathbb{R}\) (convencionamos \(q(r)=0\)).
Definimos o \textbf{custo \(q\)-reduzido} \(c_q : A \to \mathbb{R}\) por
\[
	c_q(a) := c(a) - q\bigl(\head(a)\bigr), \qquad a \in A.
\]
Para um conjunto \(X \subseteq V\), escrevemos \(q(X) := \sum_{u \in X} q(u)\).

A próxima proposição mostra que a transformação por custo \(q\)-reduzido preserva a otimalidade.

\begin{proposicao}
	Para toda função \(q: V\setminus \{r\} \to \mathbb{R}\),
	uma \(r\)-arborescência \(T\) é \(c\)-mínima em \(D\) se, e somente se, \(T\) é \(c_q\)-mínima em \(D\).
\end{proposicao}
\begin{proof}[Prova.]
	Seja \(F\) uma \(r\)-arborescência. Para cada \(u \in V \setminus \{r\}\), seja \(a_u\) o único arco de \(F\) que entra em \(u\). Então
	\begin{align*}
		c_q(F)
		 & = \sum_{u \in V \setminus \{r\}} c_q(a_u)                                     \\
		 & = \sum_{u \in V \setminus \{r\}} \bigl(c(a_u) - q(u)\bigr)                    \\
		 & = \sum_{u \in V \setminus \{r\}} c(a_u) - \sum_{u \in V \setminus \{r\}} q(u) \\
		 & = c(F) - q(V \setminus \{r\}).
	\end{align*}
	Assim, para quaisquer $r$-arborescências $T$ e $F$,
	\[
		c(T) \le c(F)
		\;\;\Longleftrightarrow\;\;
		c'(T) = c(T) - q(V \setminus \{r\}) \le c(F) - q(V \setminus \{r\}) = c_q(F),
	\]
	o que prova a proposição.
\end{proof}

Para cada \(v \in V \setminus \{r\}\), defina
\[
	\lambda(v) := \lambda_c(v) := \min\{\, c(a) : a \in \delta^{-}(v) \,\}.
\]
Note que $\lambda$ está bem definida uma vez que $D$ possui uma $r$-arborescência e, portanto,
existe ao menos um arco que entra em cada vértice diferente de $r$.
Então, para todo \(v \in V \setminus \{r\}\),
\[
	\min\{\, c_\lambda(a) : a \in \delta^{-}(v) \,\} = 0,
\]
isto é, precisamente os arcos de custo mínimo que entram em \(v\) passam a ter custo zero, e os demais ficam com custo positivo.
Consequentemente, o subdigrafo \(H\) obtém-se simplesmente como o subdigrafo induzido pelos arcos de custo zero de \(c_\lambda\):
\[
	V(H) = V(D)
	\quad\text{e}\quad
	A(H) = \{\, a \in A : c_\lambda(a) = 0 \,\}.
\]

A figura a seguir ilustra a redução de custos no digrafo da Figura~\ref{fig:antes:red}.

\begin{figure}[H]
	\centering
	\begin{tikzpicture}[>=Stealth, node distance=2.0cm]
		% estilos
		\tikzset{
			v/.style={circle, draw, fill=blue!8, minimum size=7mm, inner sep=0pt},
			cheap/.style={->, very thick, draw=blue!70},
			expensive/.style={->, dashed, draw=gray!60}
		}
		% vértices
		\node[v] (r) {\small $r$};
		\node[v] (a) [right=2.2cm of r] {\small $a$};
		\node[v] (b) [above right=1.2cm and 1.6cm of a] {\small $b$};
		\node[v] (c) [below right=1.2cm and 1.6cm of a] {\small $c$};
		% ciclo de escolhas mais baratas (custo 1)
		\draw[cheap] (a) to[bend left=12] node[midway, above, sloped] {\scriptsize 0} (b);
		\draw[cheap] (b) to[bend left=12] node[midway, above, sloped] {\scriptsize 0} (c);
		\draw[cheap] (c) to[bend left=14] node[midway, below, sloped] {\scriptsize 0} (a);
		% arcos da raiz mais caros (não escolhidos pelo critério local)
		\draw[expensive] (r) to[bend left=8] node[midway, above, sloped] {\scriptsize 2} (a);
		\draw[expensive] (r) to[bend left=18] node[midway, above, sloped] {\scriptsize 1} (b);
		\draw[expensive] (r) to[bend right=10] node[midway, below, sloped] {\scriptsize 3} (c);
	\end{tikzpicture}
	\caption{Os arcos azuis são os da escolha gulosa.}
\end{figure}

Podemos agora retomar o caso no qual o subdigrafo gerador $H$ de $D$, cujos
arcos são aqueles em que o custo $\lambda$-reduzido é zero, não possui uma $r$-arborescência.
Vamos mostrar que $H$ possui um ciclo.

Seja $v \neq r$ um vértice de $V$ que \emph{não} é alcançável a partir de $r$ em $H$.
Considere um caminho simples maximal%
\footnote{Maximal aqui tem o seguinte sentido. Para cada vértice $u$
	de $H$, as sequencias $P \cdot u$ e $u \cdot P$ não são caminhos simples.}
de $H$ que termina em $v$.
Seja $u$ o início de $P$. Como $v$ não é atingível a partir de $r$, temos que
$u \neq r$. Logo, existe exatamente um arco, digamos $wv$, de $H$ que entra em $u$.
Pela maximalidade de \(P\), o vértice \(w\) é um dos vértices de \(P\) (caso contrário,
$w \cdot P$ é um caminho simples, o que contraria a escolha de $P$).
Como \(P\) é um caminho simples que começa em \(u\), o vértice \(w\) aparece
em \(P\) \emph{após} \(u\); portanto, \(P\) contém um subcaminho $S$ de \(u\) até \(w\).
Consequentemente, $S \cdot u$ é um ciclo de $H$.

\begin{figure}[h]
	\centering
	\begin{tikzpicture}[>=Stealth]
		% estilos
		\tikzset{
			vtx/.style={circle, draw, thick, inner sep=1pt, minimum size=6mm},
			Pdash/.style={->, thick, densely dashed},   % parte tracejada de P
			cycleedge/.style={->, ultra thick}          % arco que fecha o ciclo
		}

		% vértices em coordenadas (distância maior entre u e w)
		\node[vtx] (u) at (0,0) {$u$};
		\node[vtx] (w) at (4.8,0) {$w$};
		\node[vtx] (d) at (7.2,0) {$d$};
		\node[vtx] (v) at (9.6,0) {$v$};

		% raiz r (apenas contexto)
		\node[vtx] (r) at (-2,1.6) {$r$};
		\node at (-2,2.2) {\small raiz};

		% --- Caminho P ---
		% parte inicial de P (u ~~~> w) como arco ondulado azul (sem o vértice intermediário)
		\draw[blue, very thick, -{Stealth[length=2mm]}, decorate,
		decoration={snake, amplitude=1.2pt, segment length=5pt}]
		(u) .. controls (1.4,1.2) and (3.4,1.2) .. node[midway, yshift=8pt] {$S$} (w);

		% continuação de P (tracejada): w -> d -> v
		\draw[Pdash] (w) -- (d);
		\draw[Pdash] (d) -- (v);

		% rótulo P (afastado do arco w->u)
		\node at (7.2,-0.9) {\small \(P\)};

		% arco que fecha o ciclo: w -> u
		\draw[cycleedge, bend left=35] (w) to node[above, yshift=1pt] {$wu \in T$} (u);
	\end{tikzpicture}

	\caption{O caminho simples maximal \(P\) inicia em \(u\) e termina em \(v\).
		A porção \(S\) de \(P\) entre \(u\) e \(w\) é indicada pelo arco ondulado azul; o
		caminho $S \cdot u$ é um ciclo.}
\end{figure}

A solução consiste em \emph{normalizar os custos por vértice}: para cada \(v\neq r\), subtraímos de todo arco que entra em \(v\) o menor custo entre os arcos que chegam a \(v\). Após esse ajuste (custos reduzidos), cada \(v\neq r\) passa a ter ao menos um arco de custo reduzido zero. Se os arcos de custo zero forem acíclicos, já temos a r-arborescência ótima. Se formarem um ciclo \(C\), \emph{contraímos} \(C\) em um \textbf{supervértice} \(x_C\), ajustamos os custos dos arcos externos e resolvemos recursivamente no digrafo menor.

A seguir, detalhamos essa operação de contração de ciclos.

\subsection*{Contração de ciclos}

Vamos agora formalizar a operação de contração de ciclos. Seja \((D, c, r)\) um \(r\)-digrafo ponderado e seja \(C\) um ciclo dirigido de \(D\) tal que \(r \notin C\). A \textbf{contração de \(C\)} consiste em formar um novo digrafo \(D' = (V', A')\) substituindo todos os vértices de \(C\) por um único \textbf{supervértice} \(x_C\) tal que \(x_C \notin V\). Formalmente, o conjunto de vértices de \(D'\) é dado por
\[
	V' \;:=\; (V \setminus C) \cup \{x_C\}.
\]

O conjunto de arcos \(A'\) é construído a partir de \(A\) da seguinte forma: para cada arco \(a = (u,v) \in A\), mantemos \(a\) inalterado em \(A'\) se ambos \(u\) e \(v\) estão fora de \(C\); descartamos \(a\) se ambos pertencem a \(C\); criamos um arco \((u, x_C)\) se \(u \notin C\) e \(v \in C\); e criamos um arco \((x_C, v)\) se \(u \in C\) e \(v \notin C\).

Ajustamos os custos dos arcos que entram e saem do supervértice \(x_C\) em \(D'\) para refletir a contração do ciclo \(C\) da seguinte forma: para cada arco \((u, v)\) com \(u \notin C\) e \(v \in C\), o custo do arco contraído \((u, x_C)\) é definido como \(c_\lambda(u,v)\), onde \(\lambda(v) = \min\{c(a) : a \in \delta^-(v)\}\) é o custo mínimo de entrada em \(v\) e de forma semelhante, para cada arco \((u, v)\) com \(u \in C\) e \(v \notin C\), o custo do arco contraído \((x_C, v)\) é definido como \(c_\lambda(u,v)\), onde \(c_\lambda(u,v) = c(u,v) - \lambda(v)\) e \(\lambda(v) = \min\{c(a) : a \in \delta^-(v)\}\) é o custo mínimo de entrada em \(v\).

Agora vamos ilustrar um exemplo de como essa contração é feita e os custos são ajustados.

Considere o digrafo \(D\) a seguir, com o ciclo \(C = (v_1, v_2, v_3, v_1)\).

\begin{figure}[H]
	\centering
	\begin{tikzpicture}[>=Stealth, node distance=2.0cm]
		% estilos
		\tikzset{
			v/.style={circle, draw, fill=blue!8, minimum size=7mm, inner sep=0pt},
			cycle/.style={->, very thick, draw=blue!70},
			arcs/.style={->, dashed, draw=gray!60},
		}
		% vértices
		\node[v] (r) {\small $r$};
		\node[v] (v1) [right=2.2cm of r] {\small $v_1$};
		\node[v] (v2) [above right=1.2cm and 1.6cm of v1] {\small $v_2$};
		\node[v] (v3) [below right=1.2cm and 1.6cm of v1] {\small $v_3$};
		% vértices adicionais que saem do ciclo
		\node[v] (u) [right=2.0cm of v2] {\small $u$};
		\node[v] (w) [right=2.0cm of v3] {\small $w$};
		% ciclo de escolhas mais baratas (custo 1)
		\draw[cycle] (v1) to[bend left=12] node[midway, above, sloped] {\scriptsize 3} (v2);
		\draw[cycle] (v2) to[bend left=12] node[midway, above, sloped] {\scriptsize 2} (v3);
		\draw[cycle] (v3) to[bend left=14] node[midway, below, sloped] {\scriptsize 3} (v1);
		% arcos da raiz mais caros (não escolhidos pelo critério local)
		\draw[arcs] (r) to[bend left=8] node[midway, above, sloped] {\scriptsize 3} (v1);
		\draw[arcs] (r) to[bend left=18] node[midway, above, sloped] {\scriptsize 4} (v2);
		\draw[arcs] (r) to[bend right=10] node[midway, below, sloped] {\scriptsize 5} (v3);
		% arcos saindo do ciclo
		\draw[arcs] (v2) -- node[midway, above] {\scriptsize 1} (u);
		\draw[arcs] (v3) -- node[midway, below] {\scriptsize 2} (w);
		\draw[arcs] (v3) -- node[midway, below] {\scriptsize 4} (u);
	\end{tikzpicture}
	\caption{O digrafo \(D\) com o ciclo \(C = (v_1, v_2, v_3, v_1)\). Os arcos azuis representam os arcos do ciclo, os tracejados representam os demais arcos do digrafo.}
\end{figure}

Após a normalização dos custos, os arcos internos do ciclo passam a ter custo reduzido zero e os demais arcos são ajustados conforme a definição de custo \(\lambda\)-reduzido:

\begin{figure}[H]
	\centering
	\begin{tikzpicture}[>=Stealth, node distance=2.0cm]
		% estilos
		\tikzset{
			v/.style={circle, draw, fill=blue!8, minimum size=7mm, inner sep=0pt},
			cycle/.style={->, very thick, draw=blue!70},
			arc/.style={->, dashed, draw=gray!60},
			redarc/.style={->, dashed, draw=red!60}
		}
		% vértices
		\node[v] (r) {\small $r$};
		\node[v] (v1) [right=2.2cm of r] {\small $v_1$};
		\node[v] (v2) [above right=1.2cm and 1.6cm of v1] {\small $v_2$};
		\node[v] (v3) [below right=1.2cm and 1.6cm of v1] {\small $v_3$};
		% vértices adicionais que saem do ciclo
		\node[v] (u) [right=2.0cm of v2] {\small $u$};
		\node[v] (w) [right=2.0cm of v3] {\small $w$};

		% ciclo com custo reduzido zero
		\draw[cycle] (v1) to[bend left=12] node[midway, above, sloped] {\scriptsize 0} (v2);
		\draw[cycle] (v2) to[bend left=12] node[midway, above, sloped] {\scriptsize 0} (v3);
		\draw[cycle] (v3) to[bend left=14] node[midway, below, sloped] {\scriptsize 0} (v1);
		% arcos da raiz com custos reduzidos
		\draw[arc] (r) to[bend left=8] node[midway, above, sloped] {\scriptsize 0} (v1);
		\draw[arc] (r) to[bend left=18] node[midway, above, sloped] {\scriptsize 1} (v2);
		\draw[arc] (r) to[bend right=10] node[midway, below, sloped] {\scriptsize 3} (v3);
		% arcos saindo do ciclo com custo reduzido zero
		\draw[arc] (v2) -- node[midway, above] {\scriptsize 0} (u);
		\draw[arc] (v3) -- node[midway, below] {\scriptsize 0} (w);
		\draw[arc] (v3) -- node[midway, below] {\scriptsize 3} (u);
	\end{tikzpicture}
	\caption{digrafo com custos \(\lambda\)-reduzidos. Os arcos internos do ciclo \(C\) têm custo zero (em azul). Os arcos da raiz para o ciclo têm custos 1, 0 e 3 (tracejados).}
\end{figure}

Após a contração do ciclo \(C\), obtemos o digrafo \(D'\) com o supervértice \(x_C\).

\begin{figure}[H]
	\centering
	\begin{tikzpicture}[>=Stealth, node distance=2.0cm]
		% estilos
		\tikzset{
			v/.style={circle, draw, fill=blue!8, minimum size=7mm, inner sep=0pt},
			super/.style={circle, draw, very thick, fill=gray!10, minimum size=9mm, inner sep=0pt},
			cheap/.style={->, very thick, draw=blue!70},
			expensive/.style={->, dashed, draw=gray!60}
		}
		% vértices
		\node[v] (r) {\small $r$};
		\node[super] (xC) [right=3.5cm of r] {\small $x_C$};
		\node[v] (u) [above right=1.2cm and 2.0cm of xC] {\small $u$};
		\node[v] (w) [below right=1.2cm and 2.0cm of xC] {\small $w$};
		% arcos do digrafo contraído que entram em xC (mantêm arcos paralelos, escolhemos o de menor custo)
		\draw[cheap] (r) to[bend left=12] node[midway, above, sloped] {\scriptsize 0} (xC);
		% arcos que saem de xC
		\draw[cheap] (xC) to[bend left=8] node[midway, above] {\scriptsize 0} (u);
		\draw[cheap] (xC) to[bend right=8] node[midway, below] {\scriptsize 0} (w);
	\end{tikzpicture}
	\caption{digrafo \(D'\) após a contração do ciclo \(C\). O supervértice \(x_C\) substitui todos os vértices do ciclo. Originalmente, havia três arcos paralelos de \(r\) para o ciclo: \((r, v_1)\), \((r, v_2)\) e \((r, v_3)\) com custos reduzidos 1, 0 e 3; mantemos apenas o de menor custo 0. Os arcos que saíam do ciclo agora saem de \(x_C\): \((x_C, u)\) com custo 0 e \((x_C, w)\) com custo 0. Note que havia dois arcos de vértices do ciclo para \(u\); mantemos apenas o de menor custo.}
\end{figure}

Por definição não admitimos gerar arcos paralelos entre um mesmo par de vértices, mantemos apenas o arco de menor custo, conforme ilustrado do vértice \(r\) para o supervértice \(x_C\) e de \(x_C\) para \(u\) e isso não afeta a otimalidade, já que na reexpansão qualquer escolha entre arcos paralelos conduz à mesma solução ótima.

\subsection*{Reexpansão de arborescências}

Após resolver o problema no digrafo contraído \(D'\), obtemos uma \(r\)-arborescência ótima \(T'\) em \(D'\). Para reexpandir \(T'\) em uma \(r\)-arborescência \(T\) em \(D\), substituímos o supervértice \(x_C\) pelo ciclo \(C\) e adicionamos os arcos do ciclo que formam a arborescência dentro de \(C\). Especificamente, se o arco \((u, x_C)\) em \(T'\) corresponde a um arco \((u, v_i)\) em \(D\) (onde \(v_i \in C\)), então incluímos esse arco em \(T\). Em seguida, adicionamos os arcos do ciclo \(C\) que conectam os vértices de \(C\) de forma a manter a estrutura de arborescência. Note que, devemos escolher todos os arcos do ciclo \(C\) exceto aquele que entra em \(v_i\), garantindo que cada vértice de \(C\) tenha grau de entrada igual a 1, exceto \(v_i\).

Seguindo nosso exemplo anterior, ilustramos a reexpansão da \(r\)-arborescência, primeiramente adicionando novamente os vértices que pertenciam ao ciclo \(C\) e, em seguida, incluindo os arcos apropriados para formar a \(r\)-arborescência \(T\) em \(D\):
% Seguindo o exemplo anterior, a figura abaixo ilustra a reexpansão de \(T'\) em \(D'\) para obter a \(r\)-arborescência \(T\) em \(D\):

\begin{figure}[H]
	\centering
	\begin{tikzpicture}[>=Stealth, node distance=2.0cm]
		% estilos
		\tikzset{
			v/.style={circle, draw, fill=blue!8, minimum size=7mm, inner sep=0pt},
			cycle/.style={->, very thick, draw=blue!70},
			arcs/.style={->, dashed, draw=gray!60},
			selected/.style={->, very thick, draw=green!70}
		}
		% vértices
		\node[v] (r) {\small $r$};
		\node[v] (v1) [right=2.2cm of r] {\small $v_1$};
		\node[v] (v2) [above right=1.2cm and 1.6cm of v1] {\small $v_2$};
		\node[v] (v3) [below right=1.2cm and 1.6cm of v1] {\small $v_3$};
		% vértices adicionais que saem do ciclo
		\node[v] (u) [right=2.0cm of v2] {\small $u$};
		\node[v] (w) [right=2.0cm of v3] {\small $w$};
		% ciclo de escolhas mais baratas (custo 1)
		\draw[selected] (v1) to[bend left=12] node[midway, above, sloped] {\scriptsize 0} (v2);
		\draw[selected] (v2) to[bend left=12] node[midway, above, sloped] {\scriptsize 0} (v3);
		% \draw[arcs] (v3) to[bend left=14] node[midway, below, sloped] {\scriptsize 0} (v1);
		% arcos da raiz mais caros (não escolhidos pelo critério local)
		\draw[selected] (r) to[bend left=8] node[midway, above, sloped] {\scriptsize 0} (v1);
		% \draw[arcs] (r) to[bend left=18] node[midway, above, sloped] {\scriptsize 0} (v2);
		% \draw[arcs] (r) to[bend right=10] node[midway, below, sloped] {\scriptsize 0} (v3);
		% arcos saindo do ciclo
		\draw[selected] (v2) -- node[midway, above] {\scriptsize 0} (u);
		\draw[selected] (v3) -- node[midway, below] {\scriptsize 0} (w);
		% \draw[arcs] (v3) -- node[midway, below] {\scriptsize 0} (u);
	\end{tikzpicture}
	\caption{Reexpansão da \(r\)-arborescência ótima \(T'\) em \(D'\) para obter a \(r\)-arborescência \(T\) em \(D\)}
\end{figure}

Após isso reinserimos os pesos originais dos arcos. A figura a seguir ilustra esse processo:

\begin{figure}[H]
	\centering
	\begin{tikzpicture}[>=Stealth, node distance=2.0cm]
		% estilos
		\tikzset{
			v/.style={circle, draw, fill=blue!8, minimum size=7mm, inner sep=0pt},
			cycle/.style={->, very thick, draw=blue!70},
			arcs/.style={->, dashed, draw=gray!60},
			selected/.style={->, very thick, draw=green!70}
		}
		% vértices
		\node[v] (r) {\small $r$};
		\node[v] (v1) [right=2.2cm of r] {\small $v_1$};
		\node[v] (v2) [above right=1.2cm and 1.6cm of v1] {\small $v_2$};
		\node[v] (v3) [below right=1.2cm and 1.6cm of v1] {\small $v_3$};
		% vértices adicionais que saem do ciclo
		\node[v] (u) [right=2.0cm of v2] {\small $u$};
		\node[v] (w) [right=2.0cm of v3] {\small $w$};
		% ciclo de escolhas mais baratas (custo 1)
		\draw[selected] (v1) to[bend left=12] node[midway, above, sloped] {\scriptsize 3} (v2);
		\draw[selected] (v2) to[bend left=12] node[midway, above, sloped] {\scriptsize 2} (v3);
		% \draw[arcs] (v3) to[bend left=14] node[midway, below, sloped] {\scriptsize} (v1);
		% arcos da raiz mais caros (não escolhidos pelo critério local)
		\draw[selected] (r) to[bend left=8] node[midway, above, sloped] {\scriptsize 3} (v1);
		% \draw[arcs] (r) to[bend left=18] node[midway, above, sloped] {\scriptsize} (v2);
		% \draw[arcs] (r) to[bend right=10] node[midway, below, sloped] {\scriptsize} (v3);
		% arcos saindo do ciclo
		\draw[selected] (v2) -- node[midway, above] {\scriptsize 1} (u);
		\draw[selected] (v3) -- node[midway, below] {\scriptsize 2} (w);
		% \draw[arcs] (v3) -- node[midway, below] {\scriptsize} (u);
	\end{tikzpicture}
	\caption{Reexpansão da \(r\)-arborescência ótima \(T'\) em \(D'\) para obter a \(r\)-arborescência \(T\) em \(D\). Os arcos selecionados em verde fazem parte de \(T\).}
\end{figure}


É importante observar que, ao depender da forma com a qual extraímos a arborescência ótima de \(D'\) a partir do nosso diagrafo original, podemos obter múltiplas arborescências ótimas em \(D\), o exemplo a seguir ilustra essa situação:

Considere o digrafo a seguir com custos originais:

\begin{figure}[H]
	\centering
	\begin{tikzpicture}[>=Stealth, node distance=2.0cm]
		% estilos
		\tikzset{
			v/.style={circle, draw, fill=blue!8, minimum size=7mm, inner sep=0pt},
			cheap/.style={->, thick, draw=blue!70},
			expensive/.style={->, dashed, draw=gray!60}
		}
		% vértices
		\node[v] (r) {\small $r$};
		\node[v] (v1) [right=2.2cm of r] {\small $v_1$};
		\node[v] (v2) [above right=1.2cm and 1.6cm of v1] {\small $v_2$};
		\node[v] (v3) [below right=1.2cm and 1.6cm of v1] {\small $v_3$};
		\node[v] (u) [right=2.0cm of v2] {\small $u$};

		% ciclo
		\draw[cheap] (v1) to[bend left=12] node[midway, above, sloped] {\scriptsize 2} (v2);
		\draw[cheap] (v2) to[bend left=12] node[midway, above, sloped] {\scriptsize 5} (v3);
		\draw[cheap] (v3) to[bend left=14] node[midway, below, sloped] {\scriptsize 5} (v1);
		% dois arcos paralelos da raiz para o ciclo com mesmo custo
		\draw[expensive] (r) to[bend left=8] node[midway, above, sloped] {\scriptsize 5} (v1);
		\draw[expensive] (r) to[bend right=10] node[midway, below, sloped] {\scriptsize 5} (v3);
		% arco saindo do ciclo
		\draw[expensive] (v2) -- node[midway, above] {\scriptsize 4} (u);
	\end{tikzpicture}
	\caption{digrafo \(D\) com custos originais. O ciclo \(C = (v_1, v_2, v_3, v_1)\) tem arcos com custos 5, 5 e 2. Existem dois arcos da raiz para o ciclo, ambos com custo 5: \((r, v_1)\) e \((r, v_3)\).}
\end{figure}

Após a normalização dos custos (subtraindo \(\lambda(v_1) = 5\), \(\lambda(v_2) = 2\), \(\lambda(v_3) = 5\) e \(\lambda(u) = 4\)), obtemos:

\begin{figure}[H]
	\centering
	\begin{tikzpicture}[>=Stealth, node distance=2.0cm]
		% estilos
		\tikzset{
			v/.style={circle, draw, fill=blue!8, minimum size=7mm, inner sep=0pt},
			cheap/.style={->, thick, draw=blue!70},
			expensive/.style={->, dashed, draw=gray!60}
		}
		% vértices
		\node[v] (r) {\small $r$};
		\node[v] (v1) [right=2.2cm of r] {\small $v_1$};
		\node[v] (v2) [above right=1.2cm and 1.6cm of v1] {\small $v_2$};
		\node[v] (v3) [below right=1.2cm and 1.6cm of v1] {\small $v_3$};
		\node[v] (u) [right=2.0cm of v2] {\small $u$};

		% ciclo com custos reduzidos zero
		\draw[cheap] (v1) to[bend left=12] node[midway, above, sloped] {\scriptsize 0} (v2);
		\draw[cheap] (v2) to[bend left=12] node[midway, above, sloped] {\scriptsize 0} (v3);
		\draw[cheap] (v3) to[bend left=14] node[midway, below, sloped] {\scriptsize 0} (v1);
		% dois arcos paralelos da raiz para o ciclo com mesmo custo reduzido
		\draw[expensive] (r) to[bend left=8] node[midway, above, sloped] {\scriptsize 0} (v1);
		\draw[expensive] (r) to[bend right=10] node[midway, below, sloped] {\scriptsize 0} (v3);
		% arco saindo do ciclo
		\draw[expensive] (v2) -- node[midway, above] {\scriptsize 0} (u);
	\end{tikzpicture}
	\caption{digrafo \(D\) com custos \(\lambda\)-reduzidos. Todos os arcos do ciclo custo mínimo têm agora custo zero.}
\end{figure}

Após a contração do ciclo \(C\), ambas as arborescências \(T_1\) e \(T_2\) mapeiam para a mesma arborescência \(T'\) no digrafo contraído \(D'\):

\begin{figure}[H]
	\centering
	\begin{tikzpicture}[>=Stealth, node distance=2.0cm]
		% estilos
		\tikzset{
			v/.style={circle, draw, fill=blue!8, minimum size=7mm, inner sep=0pt},
			super/.style={circle, draw, fill=orange!15, minimum size=9mm, inner sep=0pt},
			selected/.style={->, ultra thick, draw=blue!70}
		}

		\node at (0, 1.5) {\textbf{Arborescência \(T'\) em \(D'\)}};
		% vértices
		\node[v] (r) {\small $r$};
		\node[super] (xC) [right=3.5cm of r] {\small $x_C$};
		\node[v] (u) [right=2.5cm of xC] {\small $u$};

		% arcos selecionados
		\draw[selected] (r) to node[midway, above] {\scriptsize 0} (xC);
		\draw[selected] (xC) to node[midway, above] {\scriptsize 0} (u);
	\end{tikzpicture}
	\caption{Arborescência \(T'\) no digrafo contraído \(D'\). O arco \((r, x_C)\) pode corresponder ou ao arco \((r, v_1)\) ou ao \((r, v_3)\) em \(D\) e o arco \((x_C, u)\) corresponde ao arco normalizado \((v_2, u)\) em \(D\).}
\end{figure}

No processo de reexpansão, existem duas \(r\)-arborescências ótimas distintas em \(D\), ilustradas a seguir:

\begin{figure}[H]
	\centering
	\begin{tikzpicture}[>=Stealth, node distance=1.8cm, scale=0.85, transform shape]
		% estilos
		\tikzset{
			v/.style={circle, draw, fill=blue!8, minimum size=6mm, inner sep=0pt},
			selected/.style={->, ultra thick, draw=blue!70},
			notselected/.style={->, thick, draw=gray!30}
		}

		% Primeira arborescência
		\begin{scope}[xshift=-2.5cm]
			\node at (2.5, 2.3) {\textbf{Arborescência \(T_1\)}};
			% vértices
			\node[v] (r) {\small $r$};
			\node[v] (v1) [right=1.8cm of r] {\small $v_1$};
			\node[v] (v2) [above right=1.0cm and 1.4cm of v1] {\small $v_2$};
			\node[v] (v3) [below right=1.0cm and 1.4cm of v1] {\small $v_3$};
			\node[v] (u) [right=1.6cm of v2] {\small $u$};

			% arcos selecionados
			\draw[selected] (r) to[bend left=8] node[midway, above, sloped] {\scriptsize 0} (v1);
			\draw[selected] (v1) to[bend left=12] node[midway, above, sloped] {\scriptsize 0} (v2);
			\draw[selected] (v2) to[bend left=12] node[midway, above, sloped] {\scriptsize 0} (v3);
			\draw[selected] (v2) -- node[midway, above] {\scriptsize 0} (u);
			% arcos não selecionados
			\draw[notselected] (r) to[bend right=10] (v3);
			\draw[notselected] (v3) to[bend left=14] (v1);
		\end{scope}

		% Segunda arborescência
		\begin{scope}[xshift=6.5cm]
			\node at (3.5, 2.3) {\textbf{Arborescência \(T_2\)}};
			% vértices
			\node[v] (r) {\small $r$};
			\node[v] (v1) [right=1.8cm of r] {\small $v_1$};
			\node[v] (v2) [above right=1.0cm and 1.4cm of v1] {\small $v_2$};
			\node[v] (v3) [below right=1.0cm and 1.4cm of v1] {\small $v_3$};
			\node[v] (u) [right=1.6cm of v2] {\small $u$};

			% arcos selecionados
			\draw[selected] (r) to[bend right=10] node[midway, below, sloped] {\scriptsize 0} (v3);
			\draw[selected] (v3) to[bend left=14] node[midway, below, sloped] {\scriptsize 0} (v1);
			\draw[selected] (v1) to[bend left=12] node[midway, above, sloped] {\scriptsize 0} (v2);
			\draw[selected] (v2) -- node[midway, above] {\scriptsize 0} (u);
			% arcos não selecionados
			\draw[notselected] (r) to[bend left=8] (v1);
			\draw[notselected] (v2) to[bend left=12] (v3);
		\end{scope}
	\end{tikzpicture}
	\caption{Duas \(r\)-arborescências ótimas distintas em \(D\) com custos \(c_\lambda\)-reduzidos. \(T_1\) usa o arco \((r, v_1)\) e os arcos do ciclo \((v_1, v_2)\) e \((v_2, v_3)\). \(T_2\) usa o arco \((r, v_3)\) e os arcos do ciclo \((v_3, v_1)\) e \((v_1, v_2)\). Ambas incluem o arco \((v_2, u)\) e têm custo total zero.}
\end{figure}

Assim, vemos que a correspondência entre as \(r\)-arborescências de \(D\) e \(D'\) não é bijetiva, pois duas arborescências distintas em \(D\) podem corresponder à mesma arborescência em \(D'\). Isso ocorre porque ambos os arcos \((r, v_1)\) e \((r, v_3)\) têm o mesmo custo \(\lambda\)-reduzido (zero) e ambos entram no ciclo \(C\); após a contração, ambos são representados pelo único arco \((r, x_C)\) no digrafo contraído.

A seguir, apresentamos a proposição que estabelece a correspondência entre as \(r\)-arborescências de \(D\) e \(D'\) após a contração do ciclo \(C\).

\begin{proposicao}
	Seja \(C\) um ciclo dirigido em \(D\) com \(r \notin C\), e seja \(D'\) o digrafo obtido pela contração de \(C\). Para cada vértice \(v \in C\), seja \(a_v\) o único arco de \(C\) que entra em \(v\), e suponha que \(c_\lambda(a_v) = 0\) para todo \(v \in C\), onde \(\lambda(v) = \min\{c(a) : a \in \delta^-(v)\}\). Defina os custos \(c' : A' \to \mathbb{R}\) por
	\[
		c'(a') \;:=\;
		\begin{cases}
			c_\lambda(a)   & \text{se } a' = a \text{ e } a \text{ não envolve } C,                      \\
			c_\lambda(u,w) & \text{se } a' = (u, x_C) \text{ corresponde a } (u,w) \text{ com } w \in C, \\
			c_\lambda(u,v) & \text{se } a' = (x_C, v) \text{ corresponde a } (u,v) \text{ com } u \in C.
		\end{cases}
	\]
	Então existe uma correspondência bijetiva entre as \(r\)-arborescências de \(D'\) com custos \(c'\) e as \(r\)-arborescências de \(D\) com custos \(c_\lambda\) que contêm exatamente um arco entrando em \(C\). Note que, em geral, podem haver múltiplas arborescências ótimas de \(D\) que são mapeadas para uma mesma arborescência ótima de \(D'\), ou seja, a correspondência entre arborescências ótimas pode não ser bijetiva.
\end{proposicao}

\begin{proof}[Prova.]
	Seja \(T'\) uma \(r\)-arborescência de \(D'\). Como \(x_C\) é um vértice de \(D'\) e \(x_C \neq r\), existe exatamente um arco de \(T'\) que entra em \(x_C\). Seja \((u, x_C)\) esse arco. No digrafo original \(D\), o arco \((u, x_C)\) corresponde a um arco \((u, w)\) para algum \(w \in C\).

	Definimos \(T \subseteq A\) da seguinte forma: para cada arco \(a' \in T'\) que não envolve \(x_C\), incluímos o arco correspondente \(a \in A\) em \(T\); para o arco \((u, x_C) \in T'\), incluímos \((u,w) \in A\) em \(T\); e incluímos todos os arcos de \(C\), com exceção do arco \(a_w\) que entra em \(w\).

	Afirmamos que \(T\) é uma \(r\)-arborescência de \(D\). De fato, para cada vértice \(v \in V \setminus \{r\}\), se \(v \notin C\), então \(v \in V'\) e há exatamente um arco de \(T'\) entrando em \(v\), logo há exatamente um arco de \(T\) entrando em \(v\). Se \(v \in C\) e \(v \neq w\), então o único arco de \(T\) entrando em \(v\) é o arco \(a_v\) do ciclo \(C\). Finalmente, se \(v = w\), o único arco de \(T\) entrando em \(w\) é precisamente \((u,w)\).

	Além disso, como \(T'\) é acíclico em \(D'\) e os arcos do ciclo \(C\) formam um caminho de \(w\) até seus predecessores em \(C\) (exceto o arco removido \(a_w\)), o conjunto \(T\) permanece acíclico. Portanto, \(T\) é uma \(r\)-arborescência de \(D\).

	Reciprocamente, seja \(T\) uma \(r\)-arborescência de \(D\) que contém exatamente um arco entrando em \(C\), digamos \((u,w)\) com \(u \notin C\) e \(w \in C\). Definimos \(T' \subseteq A'\) mantendo cada arco de \(T\) que não envolve vértices de \(C\), substituindo o arco \((u,w)\) por \((u, x_C)\), e descartando os arcos internos de \(C\) presentes em \(T\). É direto verificar que \(T'\) é uma \(r\)-arborescência de \(D'\) e que essa correspondência é bijetiva.

	Finalmente, como todos os arcos \(a_v\) do ciclo \(C\) têm custo \(c_\lambda\)-reduzido zero, temos
	\[
		c_\lambda(T) \;=\; \sum_{a \in T \setminus C} c_\lambda(a) + c_\lambda(u,w)
		\;=\; c'(T'),
	\]
	o que estabelece a correspondência entre custos.
\end{proof}

Essa proposição justifica a estratégia recursiva do algoritmo: resolver o problema no digrafo contraído \(D'\) com custos ajustados \(c'\) e, em seguida, expandir a solução para o digrafo original \(D\).

A seguir, apresentamos a implementação completa do algoritmo de Chu–Liu e Edmonds para encontrar uma \(r\)-arborescência de custo mínimo em um \(r\)-digrafo ponderado \((D, c, r)\).

\section{Descrição do algoritmo}
A seguir apresentamos uma descrição formal do algoritmo de Chu–Liu/Edmonds. Detalhes de implementação serão discutidos na próxima seção.

% Denotamos por \(A'\) o conjunto de arcos escolhidos na construção da r-arborescência.

% Construa \(A'\) escolhendo, para cada \(v\neq r\), um arco de menor custo que entra em \(v\). Se \((V,A')\) é acíclico, então \(A'\) já é uma r-arborescência ótima, pois realizamos o menor custo de entrada em cada vértice e nenhuma troca pode reduzir o custo mantendo as restrições \cite[Sec.~4.9]{kleinberg2006}.

% Se \(A'\) contiver um ciclo dirigido \(C\) (que não inclui \(r\)), normalizamos os custos de entrada, contraímos \(C\) em um supervértice \(x_C\) ajustando arcos que entram em \(C\) por \(c'(u,x_C)=c(u,w)-c(a_w)\), e resolvemos recursivamente no digrafo contraído.

% As arborescências obtidas no digrafo contraído estão em correspondência bijetiva com as arborescências do digrafo original que possuem exatamente um arco entrando no ciclo \(C\). Como, após a normalização, todos os arcos internos de \(C\) passam a ter custo reduzido igual a zero, a expansão do supervértice recupera uma arborescência válida no digrafo original sem alterar o custo total da solução.


% \begin{figure}[H]\centering
% 	\begin{tikzpicture}[>=Stealth, node distance=1.2cm]
% 		% (a) Contraído
% 		\node at (-3.8,2.1) {(a) digrafo contraído};
% 		\node[circle,draw,minimum size=6mm] (r1) at (-6.2,1.6) {$r$};
% 		\node[circle,draw,minimum size=8mm,fill=gray!10] (xC1) at (-4.2,0.4) {$x_C$};
% 		\node[circle,draw,minimum size=6mm] (p1) at (-6.4,-0.8) {$p$};
% 		\node[circle,draw,minimum size=6mm] (q1) at (-2.2,1.2) {$q$};
% 		\node[circle,draw,minimum size=6mm] (u1) at (-1.0,-0.2) {$u$};
% 		\draw[->] (r1) -- (q1);
% 		\draw[->] (r1) -- (p1);
% 		\draw[->] (q1) -- (xC1);
% 		\draw[->,very thick] (u1) -- (xC1);

% 		% (b) Expandido e mapeado
% 		\node at (3.8,2.1) {(b) Expansão e bijeção};
% 		\node[circle,draw,minimum size=6mm] (r2) at (1.6,1.6) {$r$};
% 		\node[circle,draw,minimum size=6mm] (p2) at (1.4,-0.8) {$p$};
% 		\node[circle,draw,minimum size=6mm] (q2) at (5.6,1.2) {$q$};
% 		\node[circle,draw,minimum size=6mm] (u2b) at (6.8,-0.2) {$u$};
% 		% cycle C
% 		\draw[dashed,rounded corners] (2.6,-0.9) rectangle (4.6,1.7);
% 		\node at (5.10,-1.10) {$C$};
% 		\node[circle,draw,minimum size=6mm] (aC) at (3.0,1.2) {$a$};
% 		\node[circle,draw,minimum size=6mm] (bC) at (4.2,0.4) {$w$};
% 		\node[circle,draw,minimum size=6mm, above right] (cC) at (3.2,-0.2) {$c$};
% 		\draw[->] (aC) -- (bC);
% 		\draw[->] (bC) -- (cC);
% 		\draw[->] (cC) -- (aC);
% 		% external edges
% 		\draw[->] (r2) -- (q2);
% 		\draw[->] (r2) -- (p2);
% 		\draw[->] (q2) -- (aC);
% 		\draw[->,very thick] (u2b) -- node[above,xshift=15pt] {entra em $w$} (bC);
% 	\end{tikzpicture}
% 	\caption{Bijeção entre arborescências no digrafo contraído e no original: toda arborescência em $D'$ escolhe exatamente um arco que entra em $x_C$; ao expandir $C$, esse arco corresponde a um $(u,w)$ que entra em algum $w\in C$ e os arcos internos (de custo reduzido zero) são mantidos, preservando o custo total.}
% 	\label{fig:chu-liu-bijection}
% \end{figure}

% Na expansão, reintroduzimos \(C\) e removemos exatamente um arco interno para manter grau de entrada 1 e aciclicidade global \cite{schrijver2003comb,kleinberg2006}.

% \begin{figure}[H]\centering
% 	\begin{tikzpicture}[>=Stealth]
% 		% (a) Contraído
% 		\node at (-4.8,2.0) {(a) Contraído};
% 		\node[circle,draw,minimum size=6mm] (r3) at (-6.0,1.2) {$r$};
% 		\node[circle,draw,minimum size=8mm,fill=gray!10] (xC3) at (-4.0,0.2) {$x_C$};
% 		\node[circle,draw,minimum size=6mm] (u3) at (-2.0,0.2) {$u$};
% 		\draw[->] (r3) -- (xC3);
% 		\draw[->,very thick] (u3) -- (xC3);

% 		% (b) Expandido
% 		\node at (0.0,2.0) {(b) Expandido};
% 		\draw[dashed,rounded corners] (-1.2,-0.8) rectangle (1.2,1.6) node[below right] {$C$};
% 		\node[circle,draw,minimum size=6mm] (a3) at (-0.8,1.0) {$a$};
% 		\node[circle,draw,minimum size=6mm] (w3) at (0.8,0.4) {$w$};
% 		\node[circle,draw,minimum size=6mm] (c3) at (-0.4,0.0) {$c$};
% 		\draw[->] (a3) -- (w3);
% 		\draw[->] (w3) -- (c3);
% 		\draw[->] (c3) -- (a3);
% 		\node[circle,draw,minimum size=6mm] (u3b) at (2.4,0.4) {$u$};
% 		\draw[->,very thick] (u3b) -- (w3);

% 		% (c) Remoção interna
% 		\node at (4.8,2.0) {(c) Remoção de arco interno};
% 		\draw[dashed,rounded corners] (3.6,-0.8) rectangle (6.0,1.6) node[below right] {$C$};
% 		\node[circle,draw,minimum size=6mm] (a4) at (4.0,1.0) {$a$};
% 		\node[circle,draw,minimum size=6mm] (w4) at (5.6,0.4) {$w$};
% 		\node[circle,draw,minimum size=6mm] (c4) at (4.8,0.0) {$c$};
% 		\draw[->] (a4) -- (w4);
% 		\draw[->] (w4) -- (c4);
% 		% remove the closing arc with a red cross
% 		\draw[->] (c4) -- (a4);
% 		\draw[red,very thick] (4.35,0.55) -- (4.45,0.45);
% 		\draw[red,very thick] (4.35,0.45) -- (4.45,0.55);
% 	\end{tikzpicture}
% 	\caption{Reexpansão de $C$: no digrafo contraído seleciona-se um arco que entra em $x_C$; ao expandir, $x_C$ é substituído por $C$ e o arco selecionado entra em algum $w\in C$; remove-se exatamente um arco interno de $C$ para eliminar o ciclo, preservando conectividade e custo total (arcos internos têm custo reduzido zero).}
% 	\label{fig:chu-liu-reexpansion}
% \end{figure}

% Abaixo, temos a descrição formal do algoritmo.

\begin{algobox}{Chu–Liu/Edmonds (visão operacional)}{chu-liu-edmonds}
	Entrada: digrafo \(D=(V,A)\), custos \(c:A\to\mathbb{R}_{\ge 0}\), raiz \(r\).\footnote{Se algum \(v\neq r\) não possui arco de entrada, não existe r-arborescência.}
	\begin{enumerate}\setlength{\itemsep}{2pt}
		\item Para cada \(v\neq r\), escolha \(a_v\in\operatorname*{argmin}_{(u,v)\in A} c(u,v)\). Defina \(y(v):=c(a_v)\) e \(A_0:=\{a_v: v\neq r\}.\)
		\item Se \((V,A_0)\) é acíclico, devolva \(A_0\). Por \cite[Obs.~4.36]{kleinberg2006}, trata-se de uma r-arborescência de custo mínimo.
		\item Caso contrário, seja \(C\) um ciclo dirigido de \(A_0\) (com \(r\notin C\)). \textbf{Contração:} contraia \(C\) em um supervértice \(x_C\) e defina custos \(c'\) por
		      \begin{align*}
			      c'(u,x_C) & := c(u,w) - y(w) = c(u,w) - c(a_w) &  & \text{para } u\notin C,\ w\in C, \\
			      c'(x_C,v) & := c(w,v)                          &  & \text{para } w\in C,\ v\notin C,
		      \end{align*}
		      descartando laços em \(x_C\) e permitindo paralelos. Denote o digrafo contraído por $D'=(V',A')$.
		\item \textbf{Recursão:} compute uma r-arborescência ótima \(T'\) de \(D'\) com custos \(c'\).
		\item \textbf{Expansão:} seja \((u,x_C)\in T'\) o único arco que entra em \(x_C\). No digrafo original, ele corresponde a \((u,w)\) com \(w\in C\). Forme
		      \[
			      T := \bigl(T'\setminus\{\text{arcos incidentes a } x_C\}\bigr)\ \cup\ \{(u,w)\}\ \cup\ \bigl((A_0\cap A(C))\setminus\{a_w\}\bigr).
		      \]
		      Então \(T\) tem grau de entrada 1 em cada \(v\neq r\), é acíclico e tem o mesmo custo de \(T'\); logo, é uma r-arborescência ótima de \(D\) \cite[Sec.~4.9]{kleinberg2006,schrijver2003comb}.
	\end{enumerate}
\end{algobox}

\subsection{Corretude}

A corretude do algoritmo de Chu–Liu/Edmonds baseia-se em três pilares principais:
\begin{enumerate}\setlength{\itemsep}{2pt}
	\item \emph{Normalização por custos reduzidos:} para cada \(v\neq r\), defina \(y(v):=\min\{c(u,v):(u,v)\in A\}\) e \(c'(u,v):=c(u,v)-y(v)\). Para qualquer r-arborescência \(T\), vale
	      \[
		      \sum_{a\in T} c'(a) \,=\, \sum_{a\in T} c(a) \, - \, \sum_{v\neq r} y(v),
	      \]
	      pois há exatamente um arco de \(T\) entrando em cada \(v\neq r\). O termo \(\sum_{v\neq r} y(v)\) é constante (independe de \(T\)); assim, minimizar \(\sum c\) equivale a minimizar \(\sum c'\) \cite[Obs.~4.37]{kleinberg2006}. Em particular, os arcos \(a_v\) de menor custo que entram em \(v\) têm custo reduzido zero e formam \(A_0\).
	\item \emph{Caso acíclico:} se \((V,A_0)\) é acíclico, então já é uma r-arborescência e, por realizar o mínimo custo de entrada em cada \(v\neq r\), é ótima \cite[Obs.~4.36]{kleinberg2006}.
	\item \emph{Caso com ciclo (contração/expansão):} se \(A_0\) contém um ciclo dirigido \(C\), todos os seus arcos têm custo reduzido zero.

	      Contraia \(C\) em \(x_C\) e ajuste apenas arcos que \emph{entram} em \(C\): \(c'(u,x_C):=c(u,w)-y(w)=c(u,w)-c(a_w)\).

	      Resolva o problema no digrafo contraído \(D'\), obtendo uma r-arborescência ótima \(T'\) sob \(c'\). Na expansão, substitua o arco \((u,x_C)\in T'\) pelo correspondente \((u,w)\) (com \(w\in C\)) e remova \(a_w\) de \(C\).

	      Considerando que os arcos de \(C\) têm custo reduzido zero e \(c'(u,x_C)=c(u,w)-y(w)\), a soma dos custos reduzidos é preservada na ida e na volta; logo, \(T'\) ótimo em \(D'\) mapeia para \(T\) ótimo em \(D\) para \(c'\). Pela equivalência entre \(c\) e \(c'\), \(T\) também é ótimo para \(c\). Repetindo o argumento a cada contração, obtemos a corretude por indução \cite[Sec.~4.9]{kleinberg2006,schrijver2003comb}.
\end{enumerate}
Em termos intuitivos, \(y\) funciona como um potencial nos vértices: torna “apertados” (custo reduzido zero) os candidatos corretos; ciclos de arcos apertados podem ser contraídos sem perder otimalidade.

\subsection{Complexidade}

Na implementação direta, selecionar os \(a_v\), detectar/contrair ciclos e atualizar estruturas custa \(O(m)\) por nível; como o número de vértices decresce a cada contração, temos no máximo \(O(n)\) níveis e tempo total \(O(mn)\), com \(n=|V|\), \(m=|A|\).

O uso de memória é \(O(m+n)\), incluindo mapeamentos de contração/expansão e as filas de prioridade dos arcos de entrada. A implementação a seguir adota a versão \(O(mn)\) por simplicidade e está disponível no repositório do projeto (\url{https://github.com/lorenypsum/GraphVisualizer}).

\section{Implementação em Python}


Esta seção descreve a implementação do algoritmo de Chu--Liu--Edmonds em Python, estruturada para refletir com precisão as etapas formais discutidas anteriormente. Cada operação fundamental — normalização dos custos, construção do subdigrafo gerador, contração de ciclos e reexpansão — é traduzida em procedimentos sobre digrafos orientados, utilizando a biblioteca \texttt{networkx}.


A entrada consiste em um digrafo orientado \(D = (V, A)\), com custos dos arcos registrados no atributo \texttt{"w"}, e uma raiz \(r \in V\). As hipóteses adotadas são: (i) o digrafo é conexo a partir de \(r\), isto é, todo vértice \(v \neq r\) é alcançável a partir da raiz; (ii) para todo subconjunto \(X \subseteq V \setminus \{r\}\), existe ao menos um arco entrando em \(X\) (condições de Edmonds, cf. \cite{schrijver2003comb}); e (iii) todos os custos são não negativos.


A saída é um subdigrafo \(T\) de \(D\) com \(|A_T| = |V| - 1\) arcos, tal que cada vértice \(v \neq r\) possui grau de entrada igual a 1, todos os vértices são alcançáveis a partir de \(r\), e o custo total \(\sum_{a \in A_T} c(a)\) é mínimo.

Por limitações da representação com \texttt{networkx.DiGraph}, a implementação elimina arcos paralelos durante a contração de ciclos.

A estrutura do código é modular: funções auxiliares tratam cada etapa do algoritmo — normalização dos custos, detecção e contração de ciclos, construção do subdigrafo gerador e reexpansão da solução. Todas operam sobre objetos \texttt{nx.DiGraph} e são coordenadas por uma função principal que gerencia o fluxo recursivo. As subseções seguintes detalham cada função auxiliar, abordando lógica, parâmetros, saídas e complexidade.

\subsection{Representação de digrafos e detecção de ciclos}

A implementação utiliza a biblioteca NetworkX\footnote{NetworkX é uma biblioteca Python para criação, manipulação e estudo de redes. Disponível em \url{https://networkx.org/}.}, especificamente a classe \texttt{nx.DiGraph} para representar digrafos \(D=(V,A)\). Internamente, usa dicionários aninhados do Python para armazenar vértices, arcos e atributos, garantindo operações eficientes: adicionar/remover arco \(O(1)\) amortizado, iterar vizinhos \(O(\deg(u))\), percorrer todos os arcos \(O(m)\).

\subsubsection*{Métodos da API NetworkX}

Os métodos da API NetworkX utilizados na implementação dividem-se em três categorias funcionais, cada uma correspondendo a uma fase específica do algoritmo:

\paragraph*{Consulta de estrutura}
\begin{itemize}\setlength{\itemsep}{2pt}
	\item \texttt{D.nodes()}: devolve visão iterável sobre \(V\), permitindo percorrer todos os vértices.
	\item \texttt{D.in\_edges(v, data="w")}: devolve arcos entrantes em \(v\) com pesos, produzindo tuplas \((u, v, w)\).
	\item \texttt{D.out\_edges(u, data="w")}: devolve arcos saíntes de \(u\) com pesos, análogo a \texttt{in\_edges}.
	\item \texttt{D[u][v]["w"]}: acessa diretamente o peso do arco \((u,v)\) para leitura ou modificação.
\end{itemize}

\paragraph*{Modificação de estrutura}
\begin{itemize}\setlength{\itemsep}{2pt}
	\item \texttt{D.add\_edge(u, v, w=peso)}: adiciona arco \((u,v)\) com peso especificado, criando vértices automaticamente se não existirem.
	\item \texttt{D.remove\_edges\_from(edges)}: remove múltiplos arcos em lote.
	\item \texttt{D.remove\_nodes\_from(nodes)}: remove vértices e todos os seus arcos incidentes.
\end{itemize}

% \paragraph*{Detecção de ciclos}
% \begin{itemize}\setlength{\itemsep}{2pt}
% 	\item \texttt{nx.find\_cycle(G, orientation="original")}: detecta ciclos via algoritmo de busca em profundidade (detalhado na próxima subseção).
% \end{itemize}

% Essa função devolve um iterador sobre os arcos do ciclo (tuplas \texttt{(u, v, key)}). Dois aspectos importantes, a saída é um iterador (não lista), economizando memória e em grafos acíclicos, lança uma exceção \texttt{NetworkXNoCycle}. Isso segue o princípio EAFP (\emph{Easier to Ask for Forgiveness than Permission}) do Python e casa naturalmente com o fluxo do algoritmo: tratamos o caso acíclico com \texttt{try-except}, distinguindo caso base (sem ciclo, devolve solução) de caso recursivo (com ciclo, contrair e recursão).

% Abaixo, detalhamos as funções auxiliares que implementam os passos do algoritmo e ao final apresentamos a função principal que orquestra o fluxo recursivo.

\subsection{Redução de custos por vértice (normalização):}

Esta função implementa redução de custos por vértice - essa operação é chamada de normalização e calcula \(y(v)=\min\{w(u,v)\}\) e substitui cada peso \(w(u,v)\) por \(w(u,v)-y(v)\), garantindo que ao menos um arco de entrada tenha custo zero. Como cada r-arborescência possui exatamente um arco entrando em cada vértice não-raiz, a soma total dos valores \(y(v)\) subtraídos é constante para qualquer solução, preservando assim a ordem de otimalidade entre diferentes arborescências.

Recebe como entrada um digrafo \texttt{D} (objeto \texttt{nx.DiGraph}) e o  vértice \texttt{node} a ser normalizado. A implementação armazena em uma variável \texttt{incoming\_edges} todos os arcos de entrada de \texttt{node} com seus pesos usando o método \texttt{D.in\_edges(node, data="w")}, que devolve uma lista de tuplas \((u, node, w)\) (linha 2) (fazemos isso para evitar repetição de código e deixar o código mais claro). Em seguida, calcula-se o peso mínimo \texttt{yv} através de uma compreensão de gerador que extrai o terceiro elemento de cada tupla (linha 3) e, para cada vértice \texttt{u}, se houver o atributo "w" subtrai \texttt{yv} do peso armazenado em \texttt{D[u][node]["w"]} (linha 7), caso contrário inicializa o peso como zero antes de subtrair (linha 6).

A função não devolve nenhum valor, pois a operação é realizada modificando diretamente a estrutura: o digrafo \texttt{D} passado como parâmetro é modificado diretamente, e ao menos um arco de entrada de \texttt{node} terá custo reduzido zero após a execução. A complexidade é \(O(\deg^-(v))\), pois cada operação percorre os arcos de entrada uma única vez.

\begin{tcolorbox}[
		enhanced, breakable,
		colframe=blue!60!black, colback=blue!2,
		colbacktitle=blue!15, coltitle=black,
		title={Redução de custos por vértice (normalização)},
		boxed title style={sharp corners, boxrule=0.6pt},
		sharp corners, boxrule=0.6pt
	]
	\emph{Normaliza os pesos dos arcos que entram em \texttt{node}, subtraindo de cada uma o menor peso de entrada. Modifica o digrafo D no próprio objeto.}
	\tcblower
	\begin{lstlisting}[language=Python]
def reduce_weights(D: nx.DiGraph, node: str):    
    incoming_edges = D.in_edges(node, data=True)
    yv = min((data.get("w", 0) for _, _, data in incoming_edges))
    for u, _, _ in incoming_edges:
        if "w" not in D[u][node]:
            D[u][node]["w"] = 0
        D[u][node]["w"] -= yv   
\end{lstlisting}
\end{tcolorbox}

A Figura~\ref{fig:normalize-example} ilustra o funcionamento da normalização:

\begin{figure}[H]
	\centering
	\input{capitulos/implementacao-chuliu/figures/fig_normalize_example.tex}
	\caption{Exemplo de normalização de custos reduzidos. À esquerda, vértice \(v\) com três arcos de entrada (pesos 5, 3 e 7). À direita, após aplicar \texttt{reduce\_weights(D, v)}: o menor peso \(y(v)=3\) é subtraído de todas as entradas, resultando em custos reduzidos 2, 0 e 4. O arco \((u_2,v)\) (em vermelho) tem custo zero e será selecionado para \(A_0\).}
	\label{fig:normalize-example}
\end{figure}

Observe que as diferenças relativas são preservadas: o arco mais caro permanece 4 unidades acima da mais barata, e a intermediária mantém sua posição relativa.

Vale destacar que, quando o vértice recebe apenas um arco de entrada, trivialmente o custo desse arco é reduzido a zero.

Considerando que cada r-arborescência contém exatamente um arco entrando em cada vértice não-raiz, a soma \(\sum_{w\neq r} y(w)\) é constante para qualquer solução, garantindo que a ordem de otimalidade seja preservada.

\subsection{Construção de \texorpdfstring{\(A_0\)}{A_0}:}
Esta função constrói o subdigrafo \(A_0\) selecionando, para cada vértice \(v\neq r_0\), um único arco de custo reduzido zero que entra em \(v\).

Recebe como entrada um digrafo \texttt{D} e a raiz \texttt{r0}. A implementação cria um novo digrafo vazio \texttt{A\_zero} (linha 2) em vez de modificar \texttt{D} diretamente; essa escolha de criar uma estrutura separada é fundamental porque \(A_0\) é um subdigrafo usado para detecção de ciclos, e preservar \texttt{D} inalterado permite que as operações subsequentes (como contração) trabalhem com o digrafo original completo, evitando perda de informação sobre arcos não selecionados que podem ser necessários após reexpansões.

Em seguida, para cada vértice \texttt{v} diferente de \texttt{r0} (linha 3), utilizando o método \texttt{D.nodes()} para iterar sobre todos os vértices, se v for diferente de \texttt{r0} (linha 4), obtém todos os arcos de entrada em \(v\) com seus pesos usando \texttt{D.in\_edges(v, data=True)} (linha 5).

Em seguida, obtém o primeiro predecessor \texttt{u} cujo arco \((u,v)\) tem peso zero, aramazenando-o na variável \texttt{u} (linha 6) utilizando uma compreensão de gerador combinada com \texttt{next}.  A escolha de \texttt{next} com gerador em vez de uma busca exaustiva é eficiente porque interrompe a iteração assim que encontra o primeiro arco de custo zero, evitando processamento desnecessário dos arcos restantes (embora teoricamente todos os arcos de custo zero sejam equivalentes, na prática apenas um é necessário para \(A_0\)). Finalmente, adiciona o arco \((u,v)\) com peso zero a \texttt{A\_zero} (linha 7).

Então, devolve-se o digrafo \texttt{A\_zero} contendo exatamente um arco entrando em cada \(v\neq r_0\), todos com custo reduzido zero. O digrafo original \texttt{D} não é modificado, preservando o estado para operações futuras. A complexidade é \(O(m)\), onde \(m\) é o número de arcos, pois cada arco é considerado no máximo uma vez durante a iteração sobre todos os vértices: para cada um dos \(n-1\) vértices não-raiz, examina-se seus arcos de entrada (totalizando no máximo \(m\) arcos ao longo de todas as iterações), e para cada vértice a busca por arco de peso zero é interrompida na primeira identificação, resultando em tempo linear no tamanho do digrafo.

\begin{tcolorbox}[
		enhanced, breakable,
		colframe=blue!60!black, colback=blue!2,
		colbacktitle=blue!15, coltitle=black,
		title={Construção de A zero },
		boxed title style={sharp corners, boxrule=0.6pt},
		sharp corners, boxrule=0.6pt
	]
	\emph{Constrói o subdigrafo $A_0$ a partir do digrafo D, selecionando para cada vértice (exceto a raiz r0) um arco de custo reduzido zero que entra nele.}
	\tcblower
	\begin{lstlisting}[mathescape=true, language=Python]
def get_Azero(D: nx.DiGraph, r0: str):
    A_zero = nx.DiGraph()
    for v in D.nodes():
        if v != r0:
            in_edges = D.in_edges(v, data=True)
            u = next((u for u, _, data in in_edges if data.get("w") == 0))
            A_zero.add_edge(u, v, w=0)
    return A_zero
\end{lstlisting}
\end{tcolorbox}

A Figura~\ref{fig:get-Azero-example} ilustra a construção de \(A_0\):

\begin{figure}[H]
	\centering
	\input{capitulos/implementacao-chuliu/figures/fig_get_azero_example.tex}
	\caption{Exemplo de construção de \(A_0\) a partir de um digrafo normalizado. À esquerda, o digrafo \(D\) após normalização, onde cada vértice não-raiz possui ao menos um arco de entrada com custo zero (em vermelho). À direita, o afo \(A_0\) resultante contém apenas os arcos de custo zero selecionados, um por vértice. Note que \(A_0\) pode conter ciclos (como \(\{v_1, v_2\}\)) que serão tratados nas etapas subsequentes.}
	\label{fig:get-Azero-example}
\end{figure}

A detecção de ciclos é crucial, pois a presença de um ciclo em \(A_0\) indica que a escolha de arcos de custo reduzido zero não formou uma arborescência válida. Esses ciclos precisam ser tratados nas etapas subsequentes do algoritmo.

As funções de normalização por vértice e construção de \(A_0\) juntas implementam o passo 1 da descrição do algoritmo de Chu–Liu/Edmonds:

\begin{tcolorbox}[
		enhanced, breakable,
		colframe=green!60!black, colback=green!5,
		colbacktitle=green!20, coltitle=black,
		title={Passo 1 do Algoritmo de Chu–Liu/Edmonds},
		boxed title style={sharp corners, boxrule=0.6pt},
		sharp corners, boxrule=0.6pt
	]
	\textbf{Passo 1:} Para cada \(v\neq r\), escolha \(a_v\in\mathop{\mathrm{arg\,min}}_{(u,v)\in A} c(u,v)\). Defina \(y(v):=c(a_v)\) e \(A_0:=\{a_v : v\neq r\}\).
\end{tcolorbox}



\subsection{Detecção de ciclo:}
Esta função detecta a presença de um ciclo dirigido em \(A_0\) e devolve um subdigrafo que o contém; se \(A_0\) for acíclico, devolve \texttt{None}.

Recebe como entrada um digrafo \texttt{A\_zero} (objeto \texttt{nx.DiGraph}). A implementação utiliza um bloco \texttt{try} (linha 2) para capturar exceções caso não haja ciclo; esta escolha de tratamento por exceção é necessária porque a API do NetworkX adota o padrão EAFP (\emph{Easier to Ask for Forgiveness than Permission}), onde \texttt{nx.find\_cycle} não devolve um valor especial (como \texttt{None}) quando o digrafo é acíclico, mas sim lança a exceção \texttt{NetworkXNoCycle} para sinalizar a ausência de ciclos.

Em seguida a função inicializa um conjunto vazio \texttt{nodes\_in\_cycle} (linha 3) e emprega a função \texttt{nx.find\_cycle} do NetworkX (linha 4), que realiza uma busca em profundidade para detectar ciclos. A função \texttt{nx.find\_cycle} ou lança uma exceção devolve um iterador sobre todos os arcos que compõem esse ciclo. O laço na linha 4 itera sobre esses arcos devolvidos, desempacotando cada uma na forma \texttt{(u, v, \_)} (ignorando o terceiro elemento com \texttt{\_}, que contém metadados de orientação), e para cada arco \((u,v)\) adiciona ambos os vértices ao conjunto \texttt{nodes\_in\_cycle} (linha 5); a escolha de usar conjunto em vez de lista garante que cada vértice seja adicionado apenas uma vez mesmo que o ciclo tenha múltiplos arcos incidentes, e a operação de adição tem complexidade \(O(1)\) amortizada.

Após coletar todos os vértices do ciclo, constrói e devolve uma cópia do subdigrafo induzido por eles (linha 7); a cópia é necessária porque o método \texttt{subgraph} devolve apenas uma visão dinâmica sobre o digrafo original.

Se nenhum ciclo existir, a exceção \texttt{nx.NetworkXNoCycle} é capturada no bloco \texttt{except} (linha 8) e a função devolve \texttt{None} (linha 9);

No final, um subdigrafo contendo os vértices e arcos do ciclo detectado é devolvido, ou \texttt{None} se não houver ciclo. O digrafo original \texttt{A\_zero} não é modificado. A complexidade é \(O(m)\), onde \(m\) é o número de arcos, pois a DFS visita cada arco no máximo uma vez.

\begin{tcolorbox}[
		enhanced, breakable,
		colframe=blue!60!black, colback=blue!2,
		colbacktitle=blue!15, coltitle=black,
		title={Detecção de ciclo dirigido em $A_0$},
		boxed title style={sharp corners, boxrule=0.6pt},
		sharp corners, boxrule=0.6pt
	]
	\emph{Detecta um ciclo dirigido em $A_0$ e devolve um subdigrafo contendo seus vértices e arcos, ou \texttt{None} se for acíclico.}
	\tcblower
	\begin{lstlisting}[mathescape=true, language=Python]
def find_cycle(A_zero: nx.DiGraph):
    try:
        nodes_in_cycle = set()
        for u, v, _ in nx.find_cycle(A_zero, orientation="original"):
            nodes_in_cycle.update([u, v])
        return A_zero.subgraph(nodes_in_cycle).copy()
    except nx.NetworkXNoCycle:
        return None  
\end{lstlisting}
\end{tcolorbox}

A Figura~\ref{fig:find-cycle-example} ilustra o processo de detecção de ciclo:

\begin{figure}[H]
	\centering
	\input{capitulos/implementacao-chuliu/figures/fig_find_cycle_example.tex}
	\caption{Exemplo de detecção de ciclo em \(A_0\). À esquerda, o subdigrafo \(A_0\) contém um ciclo formado pelos vértices \(\{v_2, v_3, v_4\}\) (destacados em amarelo). A DFS percorre o digrafo e detecta o ciclo ao encontrar o arco \((v_4, v_2)\), onde \(v_2\) já está na pilha de recursão. À direita, a função devolve uma cópia do subdigrafo induzido pelos vértices do ciclo, contendo apenas os três vértices e os três arcos que formam o ciclo.}
	\label{fig:find-cycle-example}
\end{figure}

Ao detectar um ciclo, a função permite que o algoritmo de Chu–Liu/Edmonds prossiga para a etapa de contração, onde o ciclo será reduzido a um supervértice, facilitando a resolução do problema no digrafo modificado.

\subsection{Contração de ciclo:}
Esta função contrai um ciclo dirigido \(C\) em um supervértice \(x_C\), redirecionando arcos incidentes e ajustando custos segundo a regra de custos reduzidos. Devolve dicionários auxiliares para reexpansão.

Recebe como entrada um digrafo \texttt{D} (objeto \texttt{nx.DiGraph}), o ciclo \texttt{C} a ser contraído e o rótulo \texttt{label} do novo supervértice. A implementação coleta os vértices de \texttt{C} em um conjunto (linha 2) para permitir verificações de pertinência em tempo \(O(1)\), essencial dado que essa operação é realizada repetidamente nos laços seguintes. Inicializa \texttt{in\_to\_cycle} (linha 3), um dicionário que tem como chave vértices externos ao ciclo e como valor tuplas \((v,w)\), onde \(v\) é o vértice do ciclo conectado a \(u\) e \(w\) é o peso do arco \((u,v)\); essa estrutura preserva não apenas o peso mínimo, mas também o ponto exato de entrada no ciclo, informação crucial para a reexpansão posterior.

Para cada vértice \texttt{u} no digrafo \texttt{D} (linha 4), se \texttt{u} não pertence ao ciclo (linha 5), identifica o arco de menor peso que sai de \texttt{u} e entra em \texttt{C} (linhas 6--9) usando uma compreensão de gerador: a expressão \texttt{((v, w) for \_, v, w in D.out\_edges(u, data="w") if v in cycle\_nodes)} itera sobre todos os arcos que saem de \texttt{u}, desempacota cada arco na forma \texttt{(\_, v, w)} (ignorando a origem com \texttt{\_}, capturando o destino \texttt{v} e o peso \texttt{w}), filtra apenas aquelas cujo destino \texttt{v} pertence ao ciclo, e produz tuplas \texttt{(v, w)}; a função \texttt{min} (linha 6) então seleciona a tupla de menor peso usando \texttt{key=lambda x: x[1]} (linha 7) para comparar pelo segundo elemento (o peso), e devolve \texttt{None} se não houver arcos (linha 8). A escolha de selecionar apenas o arco de \emph{menor peso} reflete a propriedade fundamental do algoritmo: qualquer solução ótima que conecta um vértice externo ao ciclo contraído usará necessariamente o arco de custo mínimo, pois todas as outras seriam subótimas. Se tal arco existir, armazena em \texttt{in\_to\_cycle} (linhas 9--10).

Em seguida, a implementação itera sobre \texttt{in\_to\_cycle} usando o método \texttt{items()}, desempacotando cada entrada na forma \texttt{(u, (v, w))}, onde \texttt{u} é o vértice externo e \texttt{(v, w)} é a tupla com o vértice do ciclo e o peso (linhas 11--12). Para cada par, cria um arco de \texttt{u} para \texttt{label} com peso \texttt{w}, efetivamente redirecionando os arcos de entrada para o supervértice. A separação entre coleta (linhas 4--10) e criação (linhas 11--12) é necessária porque modificar o digrafo durante a iteração sobre seus vértices causaria comportamento indefinido; ao coletar primeiro todos os dados em estruturas auxiliares, garantimos que as modificações posteriores sejam seguras.

De forma análoga, constrói o dicionário \texttt{out\_from\_cycle} (linha 13) para mapear arcos que saem do ciclo. Para cada vértice \texttt{v} em \texttt{D} (linha 14), se \texttt{v} não pertence ao ciclo (linha 15), identifica o arco de menor peso que sai de \texttt{C} e entra em \texttt{v} (linhas 16--17) usando uma compreensão de gerador análoga: a expressão \texttt{((u, w) for u, \_, w in D.in\_edges(v, data="w") if u in cycle\_nodes)} itera sobre todos os arcos que entram em \texttt{v}, desempacota cada arco na forma \texttt{(u, \_, w)} (capturando a origem \texttt{u}, ignorando o destino com \texttt{\_}, e capturando o peso \texttt{w}), filtra apenas aqueles cuja origem \texttt{u} pertence ao ciclo, e produz tuplas \texttt{(u, w)}; a função \texttt{min} seleciona o arco de menor peso pela mesma razão de otimalidade. Se existir, armazena em \texttt{out\_from\_cycle} (linhas 18--19). Depois, itera sobre \texttt{out\_from\_cycle} e cria arcos de \texttt{label} para cada vértice \texttt{v} com os respectivos pesos (linhas 20--21). Por fim, remove todos os vértices de \texttt{C} do digrafo (linha 22); essa remoção é realizada por último para garantir que todas as operações de consulta (linhas 4--21) tenham acesso aos dados originais antes da modificação estrutural.

Devolve dois dicionários: \texttt{in\_to\_cycle} mapeia vértices externos aos pontos de entrada no ciclo original, e \texttt{out\_from\_cycle} mapeia vértices externos aos pontos de saída. Esses dicionários são essenciais para a fase de reexpansão, onde será necessário determinar exatamente qual arco interno do ciclo deve ser removido para restaurar a propriedade de arborescência. O digrafo \texttt{D} é modificado sem criar uma cópia: os vértices de \texttt{C} são removidos e substituídos por \texttt{label}. A escolha de modificação no próprio objeto (em vez de criar uma cópia) reduz significativamente o uso de memória e o tempo de execução, especialmente em grafos grandes ou com múltiplos níveis de recursão, embora exija atenção cuidadosa ao gerenciamento de referências. A complexidade é \(O(m)\), onde \(m\) é o número de arcos, pois cada arco incidente ao ciclo é processado uma vez: os laços nas linhas 4--10 e 14--19 examinam cada arco no máximo uma vez, e as operações de adição (linhas 11--12, 20--21) e remoção (linha 22) têm custo proporcional ao número de arcos afetados.

\begin{tcolorbox}[
		enhanced, breakable,
		colframe=blue!60!black, colback=blue!2,
		colbacktitle=blue!15, coltitle=black,
		title={Contração de ciclo},
		boxed title style={sharp corners, boxrule=0.6pt},
		sharp corners, boxrule=0.6pt
	]
	\emph{Contrai o ciclo $C$ em um supervértice \texttt{label}, redirecionando arcos incidentes e ajustando custos. Modifica $D$ no próprio objeto e devolve dicionários para reexpansão.}
	\tcblower
	\begin{lstlisting}[mathescape=true, language=Python]
def contract_cycle(D: nx.DiGraph, C: nx.DiGraph, label: str):
    cycle_nodes: set[str] = set(C.nodes())
    in_to_cycle: dict[str, tuple[str, float]] = {}
    for u in D.nodes:
        if u not in cycle_nodes:
            min_weight_edge_to_cycle = min(
                ((v, w) for _, v, w in D.out_edges(u, data="w") if v in cycle_nodes),
                key=lambda x: x[1],
                default=None,)
            if min_weight_edge_to_cycle:
                in_to_cycle[u] = min_weight_edge_to_cycle
    for u, (v, w) in in_to_cycle.items():
        D.add_edge(u, label, w=w)
    out_from_cycle: dict[str, tuple[str, float]] = {}
    for v in D.nodes:
        if v not in cycle_nodes:
            min_weight_edge_from_cycle = min(
                ((u, w) for u, _, w in D.in_edges(v, data="w") if u in cycle_nodes),key=lambda x: x[1], default=None,)
            if min_weight_edge_from_cycle:
                out_from_cycle[v] = min_weight_edge_from_cycle
    for v, (u, w) in out_from_cycle.items():
        D.add_edge(label, v, w=w)
    D.remove_nodes_from(cycle_nodes)
    return in_to_cycle, out_from_cycle  
\end{lstlisting}
\end{tcolorbox}

A Figura~\ref{fig:contract-cycle-example} ilustra o processo de contração de ciclo:

\begin{figure}[H]
	\centering
	\input{capitulos/implementacao-chuliu/figures/fig_contract_cycle_example.tex}
	\caption{Exemplo de contração de ciclo. À esquerda, digrafo original \(D\) com ciclo \(C=\{v_2, v_3, v_4\}\) (em amarelo). Vértices externos \(r\), \(v_1\) e \(v_5\) têm arcos conectando ao ciclo: \(r\) envia arco para \(v_2\) (peso 2) e \(v_4\) (peso 5); \(v_4\) envia arco para \(v_5\) (peso 1). À direita, após a contração: o ciclo é substituído pelo supervértice \(x_C\) (vermelho). Os arcos de entrada são redirecionados: \((r, x_C)\) recebe peso 2 (menor entre 2 e 5). O arco de saída \((x_C, v_5)\) mantém peso 1. Os dicionários \texttt{in\_to\_cycle} e \texttt{out\_from\_cycle} armazenam os mapeamentos originais para posterior reexpansão.}
	\label{fig:contract-cycle-example}
\end{figure}

A função de deteção de ciclo e a de contração juntas implementam os passos 2 e 3 da descrição do algoritmo de Chu–Liu/Edmonds:

\begin{tcolorbox}[
		enhanced, breakable,
		colframe=green!60!black, colback=green!5,
		colbacktitle=green!20, coltitle=black,
		title={Passos 2 e 3 do Algoritmo de Chu–Liu/Edmonds},
		boxed title style={sharp corners, boxrule=0.6pt},
		sharp corners, boxrule=0.6pt
	]
	\textbf{Passo 2:} Se \((V,A_0)\) é acíclico, devolva \(A_0\). Por \cite[Obs.~4.36]{kleinberg2006}, trata-se de uma r-arborescência de custo mínimo.

	\textbf{Passo 3:} Caso contrário, seja \(C\) um ciclo dirigido de \(A_0\) (com \(r\notin C\)). \textbf{Contração:} contraia \(C\) em um supervértice \(x_C\) e defina custos \(c'\) por
	\begin{align*}
		c'(u,x_C) & := c(u,w) - y(w) = c(u,w) - c(a_w) &  & \text{para } u\notin C,\ w\in C, \\
		c'(x_C,v) & := c(w,v)                          &  & \text{para } w\in C,\ v\notin C,
	\end{align*}
	descartando laços em \(x_C\) e permitindo paralelos. Denote o digrafo contraído por \(D'=(V',A')\).
\end{tcolorbox}

\subsection{Remoção de arcos que entram na raiz:}
Esta função remove todos os arcos que entram no vértice raiz \(r_0\), garantindo que a raiz não tenha predecessores. A remoção é necessária porque, por definição, uma r-arborescência é uma arborescência enraizada em \(r_0\) onde todo vértice \(v \neq r_0\) deve ser alcançável a partir de \(r_0\), mas a própria raiz não pode ter predecessores (grau de entrada zero). Se o digrafo original contiver arcos entrando em \(r_0\), esses arcos violariam a definição de arborescência enraizada e poderiam criar ciclos envolvendo a raiz, o que tornaria impossível obter uma estrutura válida. Além disso, a presença de arcos entrando na raiz interfere na normalização: ao tentar normalizar custos de entrada para \(r_0\), criaríamos custos reduzidos artificiais que não fazem sentido no contexto do problema, já que nenhuma solução válida pode incluir tais arcos. Portanto, esta função atua como um passo de pré-processamento essencial que prepara o digrafo para os passos subsequentes do algoritmo.

A escolha de implementar esta operação como uma função auxiliar separada (em vez de incluí-la apenas inline na função principal) segue princípios de design de software: (1) \emph{modularidade}, encapsulando uma responsabilidade específica e bem definida (remover entradas na raiz) em uma unidade testável independente; (2) \emph{reutilização}, permitindo que outras partes do código ou implementações alternativas possam chamar esta operação quando necessário sem duplicar lógica; (3) \emph{clareza semântica}, dando um nome descritivo (\texttt{remove\_edges\_to\_r0}) que documenta a intenção da operação no ponto de chamada, tornando a função principal mais legível ao abstrair detalhes de implementação; e (4) \emph{facilidade de teste}, possibilitando escrever testes unitários focados exclusivamente nesta operação de pré-processamento, verificando casos extremos (como grafos onde a raiz já não tem predecessores ou onde todos os arcos entram na raiz) sem precisar testar toda a complexidade do algoritmo recursivo.

Em detalhes, ela recebe como entrada um digrafo \texttt{D} (objeto \texttt{nx.DiGraph}) e o rótulo \texttt{r0} da raiz. A implementação armazena em uma lista todos os arcos que entram em \texttt{r0} usando o método \texttt{in\_edges} (linha 2). Se a lista não estiver vazia (linha 3), remove todos esses arcos usando o método \texttt{remove\_edges\_from} (linha 4). Este método da biblioteca NetworkX recebe como parâmetro uma lista de tuplas representando arcos na forma \texttt{(u, v)} e remove cada uma delas do digrafo. A operação é realizada em lote: NetworkX itera sobre a lista fornecida e, para cada tupla \texttt{(u, v)}, remove o arco correspondente da estrutura interna de adjacência. Se algum arco especificado não existir no digrafo, ele é silenciosamente ignorado sem gerar erro. A complexidade de \texttt{remove\_edges\_from} é \(O(k)\), onde \(k\) é o número de arcos na lista de entrada, pois cada remoção individual tem custo \(O(1)\) em média devido ao uso de dicionários aninhados para armazenar arcos.

Por fim, a função devolve o digrafo \texttt{D} atualizado no próprio objeto com todos os arcos de entrada em \texttt{r0} removidos (linha 5). A complexidade total da função é \(O(\deg^-(r_0))\), pois a operação coleta e remove cada arco de entrada uma única vez.

\begin{tcolorbox}[
		enhanced, breakable,
		colframe=blue!60!black, colback=blue!2,
		colbacktitle=blue!15, coltitle=black,
		title={Remoção de arcos que entram na raiz},
		boxed title style={sharp corners, boxrule=0.6pt},
		sharp corners, boxrule=0.6pt
	]
	\emph{Remove todos os arcos que entram na raiz \texttt{r0}, modificando \texttt{D} ao invés de criar uma cópia e devolve o digrafo atualizado.}
	\tcblower
	\begin{lstlisting}[mathescape=true, language=Python]
def remove_edges_to_r0(D: nx.DiGraph, r0: str):
    in_edges = list(D.in_edges(r0))
    if in_edges:
        D.remove_edges_from(in_edges)
    return D
\end{lstlisting}
\end{tcolorbox}


\subsection{Remoção de arco interno:}

Esta função é invocada durante a fase de reexpansão do ciclo contraído, após a chamada recursiva devolver com a arborescência ótima \(T'\) do digrafo contraído. Quando o supervértice \(x_C\) é expandido de volta para o ciclo original \(C\), um arco externo \((u,v)\) é adicionado conectando um vértice externo \(u\) a um vértice \(v\) dentro do ciclo. Como o ciclo \(C\) originalmente continha exatamente um arco entrando em cada um de seus vértices (formando um ciclo fechado), e agora \(v\) recebe um arco adicional vindo do exterior, esse vértice teria grau de entrada 2, violando a propriedade fundamental de arborescência (cada vértice não-raiz deve ter exatamente uma entrada). Para restaurar essa propriedade, a função remove o arco interno que anteriormente entrava em \(v\), mantendo apenas o novo arco externo. Essa remoção "quebra" o ciclo no ponto de entrada, transformando-o em um caminho que se integra corretamente à estrutura de árvore.

A função recebe como entrada o subdigrafo do ciclo \texttt{C} (objeto \texttt{nx.DiGraph}) e o vértice de entrada \texttt{v}. A implementação utiliza uma compreensão de gerador combinada com \texttt{next} para encontrar o predecessor de \texttt{v} dentro do ciclo (linha 2): a expressão \texttt{(u for u, \_ in C.in\_edges(v))} itera sobre os arcos de entrada de \texttt{v}, extraindo apenas o vértice origem \texttt{u} (ignorando metadados com \texttt{\_}), e \texttt{next} devolve o primeiro (e teoricamente único) predecessor. Em seguida, remove o arco \texttt{(predecessor, v)} do ciclo usando o método \texttt{remove\_edge} (linha 3).

A função modifica diretamente o subdigrafo \texttt{C} e não devolve valor. A complexidade é \(O(\deg^-(v))\), dominada pela operação de busca dos arcos de entrada, embora em ciclos simples isso seja tipicamente \(O(1)\) pois cada vértice tem exatamente um predecessor.

\begin{tcolorbox}[
		enhanced, breakable,
		colframe=blue!60!black, colback=blue!2,
		colbacktitle=blue!15, coltitle=black,
		title={Remover arco interno na reexpansão},
		boxed title style={sharp corners, boxrule=0.6pt},
		sharp corners, boxrule=0.6pt
	]
	\emph{Remove o arco interno que entra no vértice de entrada \texttt{v} do ciclo \texttt{C} durante a reexpansão, pois \texttt{v} passa a receber um arco externo, e manter ambos violaria a propriedade de arborescência.}
	\tcblower
	\begin{lstlisting}[mathescape=true, language=Python]
def remove_internal_edge_to_cycle_entry(C: nx.DiGraph, v):
    predecessor = next((u for u, _ in C.in_edges(v)), None)
    C.remove_edge(predecessor, v) 
\end{lstlisting}
\end{tcolorbox}

A Figura~\ref{fig:remove-internal-edge-example} ilustra o objetivo da função:

\begin{figure}[H]
	\centering
	\input{capitulos/implementacao-chuliu/figures/fig_remove_internal_edge_example.tex}
	\caption{Remoção de arco interno durante reexpansão. À esquerda, ciclo $C=\{v_2, v_3, v_4\}$ após adicionar arco externo $(u, v_2)$ vindouro da arborescência $T'$: o vértice $v_2$ tem grau de entrada 2 (arco externo vermelho de $u$ e arco interno do ciclo vindo de $v_4$), violando a propriedade de arborescência. À direita, após remover o arco interno $(v_4, v_2)$: o vértice $v_2$ passa a ter grau de entrada 1, o ciclo é "quebrado" no ponto de entrada, transformando-se em um caminho que se integra corretamente à estrutura de árvore. O arco removido é mostrado tracejado em cinza.}
	\label{fig:remove-internal-edge-example}
\end{figure}

\subsection{Procedimento principal (recursivo):}
Esta função implementa o algoritmo de Chu–Liu/Edmonds de forma recursiva, orquestrando todas as funções auxiliares descritas anteriormente. Recebe como entrada um digrafo ponderado \texttt{D} (objeto \texttt{nx.DiGraph}), o vértice raiz \texttt{r0}, e um parâmetro \texttt{level} (padrão 0) usado para rotular supervértices em níveis recursivos distintos.

A implementação segue a estrutura do algoritmo:

\paragraph*{Preservação do digrafo original (linha 2):} Cria uma cópia \texttt{D\_copy = D.copy()} para preservar os pesos originais. Como as operações de normalização e contração modificam os pesos dos arcos diretamente, a cópia é necessária para restaurar os custos corretos na arborescência final. Complexidade: \(O(m+n)\).

\paragraph*{Normalização e construção de \(A_0\) (linhas 3--6):} Itera sobre todos os vértices não-raiz (linhas 3--5), chamando \texttt{reduce\_weights(D\_copy, v)} para cada um. Após normalizar todos os vértices, constrói \(A_0\) (linha 6) chamando \texttt{get\_Azero(D\_copy, r0)}, que seleciona um arco de custo reduzido zero entrando em cada vértice não-raiz.

\paragraph*{Verificação de aciclicidade — caso base (linhas 7--10):} Verifica se \(A_0\) é uma arborescência válida usando \texttt{nx.is\_arborescence(A\_zero)} (linha 7). Se sim, restaura os pesos originais de \texttt{D} para cada arco de \(A_0\) (linhas 8--9) e devolve \texttt{A\_zero} como solução (linha 10). A função \texttt{nx.is\_arborescence} testa conectividade, aciclicidade e grau de entrada correto simultaneamente.

\paragraph*{Contração e resolução recursiva — caso recursivo (linhas 11--16):} Caso \(A_0\) contenha um ciclo, detecta \(C\) chamando \texttt{find\_cycle(A\_zero)} (linha 12). Cria um rótulo único \texttt{contracted\_label = f"contracted\_\{level\}"} para o supervértice (linha 13). Contrai o ciclo chamando \texttt{contract\_cycle(D\_copy, C, contracted\_label)} (linhas 14--15), que modifica \texttt{D\_copy} diretamente criando o digrafo contraído \(D'\) e devolve os dicionários \texttt{in\_to\_cycle} e \texttt{out\_from\_cycle}. Chama-se recursivamente (linha 16) com \texttt{chuliu(D\_copy, r0, level+1)}, obtendo \(F'\).

\paragraph*{Reexpansão do ciclo contraído (linhas 17--30):} Identifica o arco externo que entra no supervértice em \(F'\) (linha 17) e extrai o vértice externo \texttt{u} (linha 18). Consulta \texttt{v = in\_to\_cycle[u]} para determinar o vértice do ciclo que recebe a conexão (linha 19). Remove o arco interno que entrava em \(v\) chamando \texttt{remove\_internal\_edge\_to\_cycle\_entry(C, v)} (linha 20), quebrando o ciclo no ponto de entrada. Adiciona o arco externo \texttt{(u, v)} a \(F'\) (linha 21) e reintegra os demais arcos do ciclo (linhas 22--23). Processa os arcos de saída (linhas 24--26): para cada \texttt{(contracted\_label, w)} em \(F'\), adiciona \texttt{(v\_out, w)} usando \texttt{out\_from\_cycle[w]}. Remove o supervértice (linha 27), restaura os pesos originais (linhas 28--29) e devolve \texttt{F\_prime} (linha 30).

A função devolve um digrafo contendo exatamente \(|V|-1\) arcos onde cada vértice \(v \neq r_0\) tem grau de entrada 1, todos os vértices são alcançáveis a partir de \(r_0\), e o custo total é mínimo. O digrafo original \texttt{D} não é modificado devido à cópia (linha 2). A complexidade é \(O(mn)\) no pior caso, onde cada nível de recursão (até \(O(n)\) níveis) processa \(O(m)\) arcos durante a normalização, detecção de ciclos e contração/expansão.

O código completo da função principal é apresentado a seguir:

\begin{tcolorbox}[
		enhanced, breakable,
		colframe=blue!60!black, colback=blue!2,
		colbacktitle=blue!15, coltitle=black,
		title={Procedimento principal (recursivo)},
		boxed title style={sharp corners, boxrule=0.6pt},
		sharp corners, boxrule=0.6pt
	]
	\emph{Implementa o algoritmo de Chu–Liu/Edmonds de forma recursiva para encontrar a r-arborescência de custo mínimo em um digrafo ponderado \texttt{D} com raiz \texttt{r0}. Normaliza custos, constrói $A_0$, detecta ciclos e, se houver, contrai em supervértice, resolve recursivamente no digrafo reduzido e reexpande, restaurando a arborescência ótima no digrafo original. Devolve um \texttt{nx.DiGraph} contendo exatamente $|V|-1$ arcos com grau de entrada 1 para cada vértice exceto a raiz.}
	\tcblower
	\begin{lstlisting}[mathescape=true, language=Python]
def chuliu(D: nx.DiGraph,r0: str,level=0,):
    D_copy = D.copy()
    for v in D_copy.nodes:
        if v != r0:
            reduce_weights(D_copy, v)
    A_zero = get_Azero(D_copy, r0)
    if nx.is_arborescence(A_zero):
        for u, v in A_zero.edges:
            A_zero[u][v]["w"] = D[u][v]["w"]
        return A_zero
    else:
        C: nx.DiGraph = find_cycle(A_zero)   
        contracted_label = f"\n n*{level}"
        in_to_cycle, out_from_cycle = contract_cycle(
        D_copy, C, contracted_label)
        F_prime = chuliu(D_copy,r0,level + 1)
        in_edge = next(iter(F_prime.in_edges(contracted_label, data="w")), None)
        u, _, _ = in_edge
        v, _ = in_to_cycle[u]
        remove_internal_edge_to_cycle_entry(C, v)
        F_prime.add_edge(u, v)
        for u_c, v_c in C.edges:
            F_prime.add_edge(u_c, v_c)
        for _, z, _ in F_prime.out_edges(contracted_label, data=True):
            u_cycle, _ = out_from_cycle[z]
            F_prime.add_edge(u_cycle, z)
        F_prime.remove_node(contracted_label)
        for u, v in F_prime.edges:
            F_prime[u][v]["w"] = D[u][v]["w"]
        return F_prime 
\end{lstlisting}
\end{tcolorbox}

A seguir, ilustramos o funcionamento do algoritmo de Chu–Liu/Edmonds em um digrafo de teste. Mostramos o digrafo original, os principais passos do algoritmo e a arborescência final encontrada.

\subsubsection{Exemplo de execução do algoritmo}

A seguir, demonstramos a execução completa do algoritmo de Chu--Liu/Edmonds em um digrafo exemplo, ilustrando cada fase do processo: normalização, construção de $A_0$, detecção de ciclos, contração, resolução recursiva e reexpansão.

\begin{figure}[H]
	\centering
	\input{capitulos/implementacao-chuliu/figures/fig_exemplo_grafo_inicial.tex}
	\caption{digrafo direcionado ponderado inicial com raiz no vértice 0. O digrafo contém 9 vértices e múltiplos arcos com pesos variados. O primeiro passo do algoritmo seria remover arcos que entram na raiz, porém não há nenhum neste caso, logo não existe necessidade de alterar o digrafo.}
	\label{fig:exemplo-digrafo-inicial}
\end{figure}

O primeiro passo do nosso algoritmo seria remover os arcos que entram na raiz (vértice $0$), porém não há nenhum nesse caso, logo não existe a necessidade de alterar o digrafo.

O próximo passo é normalizar os pesos dos arcos de entrada para cada vértice. Nessa etapa, para cada vértice $v$ (exceto a raiz), o algoritmo encontra o arco de menor peso que entra em $v$ e subtrai esse menor peso de todos os arcos que entram em $v$ (isso serve para zerar o peso do arco mínimo de entrada em cada vértice).

\begin{figure}[H]
	\centering
	\input{capitulos/implementacao-chuliu/figures/fig_exemplo_normalizacao_parcial.tex}
	\caption{Normalização parcial dos arcos de entrada para o vértice 1. Os arcos de entrada são $(0 \to 1)$ com peso original 3 e $(2 \to 1)$ com peso original 1. Elegendo o arco $(2 \to 1)$ como o de menor peso (peso mínimo = 1), subtraímos este valor de todos os arcos de entrada: $(0 \to 1)$ passa de peso 3 para 2, e $(2 \to 1)$ passa de peso 1 para 0 (destacadas em vermelho). Esse processo é repetido para todos os demais vértices.}
	\label{fig:exemplo-normalizacao-parcial}
\end{figure}

Com os pesos normalizados, o próximo passo é construir $A_0$: para isso, selecionamos para cada vértice o arco de custo reduzido zero de entrada. Detectamos um ciclo em $A_0$, formado pelos vértices $\{1, 2\}$. Portanto, precisamos contrair esse ciclo em um supervértice $n*0$.

\begin{figure}[H]
	\centering
	\input{capitulos/implementacao-chuliu/figures/fig_exemplo_grafo_contraido.tex}
	\caption{digrafo contraído após detecção do ciclo $C = \{1, 2\}$ em $A_0$. O ciclo foi contraído no supervértice $n*0$ (destacado em vermelho). Os arcos que entravam ou saíam do ciclo foram redirecionados para o supervértice, com custos ajustados segundo as fórmulas $c'(u,x_C) := c(u,w) - y(w)$ para arcos de entrada e $c'(x_C,v) := c(w,v)$ para arcos de saída.}
	\label{fig:exemplo-digrafo-contraido}
\end{figure}

Agora, repetimos o processo recursivamente no digrafo contraído até obter uma arborescência válida.

\begin{figure}[H]
	\centering
	\input{capitulos/implementacao-chuliu/figures/fig_exemplo_arborescencia_contraida.tex}
	\caption{Arborescência ótima $F'$ obtida no digrafo contraído. todos os arcos selecionados têm custo reduzido 0 (destacados em vermelho), e o digrafo forma uma arborescência válida enraizada em 0: cada vértice (exceto a raiz) tem exatamente um arco de entrada, não há ciclos, e todos os vértices são alcançáveis a partir da raiz. Como $F'$ é acíclico, alcançamos o caso base da recursão.}
	\label{fig:exemplo-arborescencia-contraida}
\end{figure}

Após validarmos que $A_0$ não possui mais ciclos e forma uma arborescência, iniciamos o processo de reexpansão do ciclo contraído para obter a arborescência final no digrafo original. Adicionamos o arco de entrada ao ciclo $(0, 1)$, os arcos internos do ciclo modificado $(1, 2)$, e os arcos de saída $(1, 3)$, chegando a uma arborescência válida.

\begin{figure}[H]
	\centering
	\input{capitulos/implementacao-chuliu/figures/fig_exemplo_arborescencia_final.tex}
	\caption{Arborescência ótima final no digrafo original com pesos restaurados. O supervértice $n*0$ foi expandido de volta para os vértices 1 e 2, com o arco externo $(0, 1)$ escolhido pela solução recursiva conectando ao ciclo. O arco interno $(2, 1)$ do ciclo original foi removido para manter a propriedade de arborescência ($\deg^{-}(v)=1$). O resultado é uma 0-arborescência de custo mínimo com exatamente 8 arcos, onde cada vértice não-raiz tem grau de entrada 1 e todos são alcançáveis a partir da raiz 0.}
	\label{fig:exemplo-arborescencia-final}
\end{figure}

\subsection{Correspondência entre teoria e implementação}

A implementação em Python segue fielmente os cinco passos da descrição teórica do algoritmo de Chu–Liu/Edmonds apresentada na Seção anterior. A tabela abaixo estabelece o paralelo direto entre cada passo teórico e sua realização no código:

\begin{table}[H]
	\centering
	\footnotesize
	\renewcommand{\arraystretch}{1.4}
	\begin{tabular}{>{\raggedright\arraybackslash}p{0.46\textwidth}|>{\raggedright\arraybackslash}p{0.46\textwidth}}
		\toprule
		\textbf{\large Descrição Teórica} & \textbf{\large Implementação Python} \\
		\midrule
		\rowcolor{blue!5}
		\textbf{Passo 1:} Normalização e construção de \(A_0\)

		Para cada \(v\neq r\), escolha \(a_v\in\mathop{\mathrm{arg\,min}}_{(u,v)\in A} c(u,v)\).

		Defina \(y(v):=c(a_v)\) e \(A_0:=\{a_v : v\neq r\}\).
		                                  &
		\textbf{Linhas 3--6:}

		\texttt{for v in D\_copy.nodes:}

		\quad \texttt{reduce\_weights(D\_copy, v)}

		\texttt{A\_zero = get\_Azero(D\_copy, r0)}

		\vspace{2mm}
		Calcula \(y(v)\) e cria custos reduzidos, depois constrói \(A_0\) selecionando arcos de custo zero.
		\\
		\midrule
		\rowcolor{green!5}
		\textbf{Passo 2:} Verificação de aciclicidade (caso base)

		Se \((V,A_0)\) é acíclico, devolva \(A_0\). Por Obs. 4.36 de \cite{kleinberg2006}, trata-se de uma r-arborescência de custo mínimo.
		                                  &
		\textbf{Linhas 7--10:}

		\texttt{if nx.is\_arborescence(A\_zero):}

		\quad \texttt{[restaura pesos originais]}

		\quad \texttt{return A\_zero}

		\vspace{2mm}
		Testa conectividade, aciclicidade e grau de entrada correto simultaneamente.
		\\
		\midrule
		\rowcolor{orange!5}
		\textbf{Passo 3:} Contração de ciclo

		Caso contrário, seja \(C\) um ciclo dirigido de \(A_0\) (com \(r\notin C\)). Contraia \(C\) em supervértice \(x_C\) e defina custos \(c'\) por:

		\(c'(u,x_C) := c(u,w) - y(w)\)

		\(c'(x_C,v) := c(w,v)\)

		Denote o digrafo contraído por \(D'=(V',A')\).
		                                  &
		\textbf{Linhas 11--15:}

		\texttt{C = find\_cycle(A\_zero)}

		\texttt{label = f"contracted\_\{level\}"}

		\texttt{in\_to\_cycle, out\_from\_cycle =}

		\quad \texttt{contract\_cycle(D\_copy, C, label)}

		\vspace{2mm}
		Implementa as fórmulas de ajuste de custos e modifica \texttt{D\_copy} para criar \(D'\).
		\\
		\midrule
		\rowcolor{purple!5}
		\textbf{Passo 4:} Resolução recursiva

		Resolva recursivamente em \(D'\), obtendo arborescência ótima \(F'\).
		                                  &
		\textbf{Linha 16:}

		\texttt{F\_prime = chuliu(}

		\quad \texttt{D\_copy, r0, level+1)}

		\vspace{2mm}
		Chamada recursiva resolve o problema no digrafo contraído.
		\\
		\midrule
		\rowcolor{red!5}
		\textbf{Passo 5:} Reexpansão

		Expanda \(x_C\) para o ciclo original \(C\). Se \((u,x_C)\in F'\), adicione \((u,v)\) onde \(v\) é o vértice do ciclo mapeado por \(u\), remova o arco interno entrando em \(v\), e reintegre demais arcos de \(C\). Restaure custos originais.
		                                  &
		\textbf{Linhas 17--30:}

		\texttt{v = in\_to\_cycle[u]}

		\texttt{remove\_internal\_edge\_to\_cycle\_entry(C, v)}

		\texttt{F\_prime.add\_edge(u, v)}

		\texttt{F\_prime.add\_edges\_from(C.edges)}

		\texttt{[processa saídas, remove supervértice]}

		\texttt{[restaura pesos originais]}
		\\
		\bottomrule
	\end{tabular}
	\caption{Correspondência entre os cinco passos teóricos do algoritmo de Chu–Liu/Edmonds e sua implementação em Python. Cada linha da coluna direita mostra a tradução direta dos conceitos matemáticos da coluna esquerda em operações concretas sobre grafos.}
	\label{tab:teoria-implementacao}
\end{table}

Esta correspondência demonstra que a implementação não é uma aproximação ou interpretação livre da teoria, mas uma tentativa de traduzir fielmente a descrição teórica. As funções auxiliares (\texttt{reduce\_weights}, \texttt{get\_Azero}, \texttt{find\_cycle}, \texttt{contract\_cycle}, \texttt{remove\_internal\_edge\_to\_cycle\_entry}) encapsulam exatamente as operações descritas na formulação teórica, preservando as propriedades de correção e complexidade do algoritmo original.

\subsection{Transição para a abordagem primal-dual}

Embora o algoritmo de Chu–Liu/Edmonds seja elegante e eficiente, sua mecânica operacional — normalizar custos, selecionar mínimos, contrair ciclos — pode parecer um conjunto de heurísticas bem-sucedidas sem uma justificativa teórica unificadora aparente. Por que escolher a melhor entrada para cada vértice garante otimalidade global após o tratamento de ciclos? A resposta reside na \emph{dualidade em programação linear}.


No capítulo seguinte, revisitaremos o mesmo problema sob uma ótica primal–dual em duas fases, proposta por András Frank. Essa perspectiva organiza a normalização via potenciais\footnote{No contexto primal–dual, “potenciais” são valores escalares \(y(v)\) atribuídos aos vértices para definir custos reduzidos \(c'(u,v)=c(u,v)-y(v)\). Ajustar \(y\) desloca uniformemente os custos dos arcos que entram em \(v\), sem mudar a otimalidade global: preserva a ordem relativa entre entradas e torna “apertadas” (custo reduzido zero) as candidatas corretas, habilitando contrações e uma prova de corretude via cortes apertados.} \(y(\cdot)\), explica os custos reduzidos e introduz a noção de cortes apertados (família laminar) como guias das contrações. Veremos como a mesma mecânica operacional (normalizar \(\to\) contrair \(\to\) expandir) emerge de condições duais que também sugerem otimizações e generalizações.
