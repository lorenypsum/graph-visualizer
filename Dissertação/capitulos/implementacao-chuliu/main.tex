\chapter{Algoritmo de Chu–Liu--Edmonds}

Neste capítulo, apresentaremos o algoritmo de Chu--Liu--Edmonds, que determina
uma arborescência de custo mínimo em um dígrafo ponderado.
O algoritmo baseia-se em duas operações fundamentais:
(i) a redução gulosa dos custos dos arcos e (ii) a contração de ciclos,
de modo a resolver recursivamente uma instância menor do problema e, em seguida,
estender a solução para o problema original.
O propósito deste capítulo é fornecer uma descrição precisa tanto do algoritmo
quanto da implementação desenvolvida neste trabalho.

\section{O algoritmo}
O algoritmo de Chu--Liu--Edmonds recebe uma tripla \((D,c,r)\), em que \(D=(V,A)\) é um dígrafo, \(c\colon A\to\mathbb{R}\) é uma função custo e \(r\in V\) é a raiz, sob a hipótese de que \(D\) admite ao menos uma \(r\)-arborescência. O algoritmo devolve uma \(r\)-arborescência \(c\)-mínima de \(D\).

Para evitar repetir essa hipótese, introduzimos a seguinte definição.
Uma tripla \((D,c, r)\) é um \textbf{\(r\)-dígrafo ponderado} se $(D, c)$
é um digrafo ponderado, $r$ é um vértice de $D$, $\delta^-(r) = \varnothing$
e $D$ possui uma $r$-arborescência. Note que a hipótese $\delta^-(r)$ é uma trivialidade,
pois uma $r$-arborescência não contém nenhum arco que entra em $r$ e, portanto,
tais arcos podem ser eliminados de $D$ sem nenhum prejuízo.

Vamos tecer algumas considerações para motivar o algoritmo.

\subsection*{Caráter Guloso}
Suponha doravante que $(D, c, r)$ é um $r$-digrafo ponderado.
O algoritmo tem um caráter guloso. Note que, se \(T\) é uma \(r\)-arborescência de $D$,
então, para cada vértice \(v \neq r\), existe exatamente um arco de \(T\) que entra em \(v\). Isso sugere a seguinte escolha gulosa: para cada vértice \(v \neq r\), selecione um arco \(a_v\) de custo mínimo que entra em \(v\) e forme o conjunto \(T := \{a_v : v \in V \setminus \{r\}\}\).

\begin{figure}[h]
	\centering
	\begin{tikzpicture}[>=Stealth]
		% estilos
		\tikzset{
			vtx/.style={circle, draw, thick, inner sep=1.2pt, minimum size=6mm},
			chosen/.style={->, very thick, draw=blue},
			other/.style={->, semithick, draw=black!35},
			costB/.style={font=\scriptsize, fill=white, inner sep=1pt, text=blue},
			costG/.style={font=\scriptsize, fill=white, inner sep=1pt, text=black!55}
		}

		% layout (mais espaçado)
		\node[vtx] (r) at (0,0) {$r$};
		\node[vtx] (a) at (3,1.6) {$a$};
		\node[vtx] (b) at (3,-1.6) {$b$};
		\node[vtx] (c) at (6,2.2) {$c$};
		\node[vtx] (d) at (6,0.0) {$d$};
		\node[vtx] (e) at (6,-2.2) {$e$};

		% --- arcos NÃO escolhidos (cinza), agora com curvaturas mais limpas ---
		\draw[other] (b) to[bend left=12] node[costG, above] {4} (a);   % b->a
		\draw[other] (a) to[bend left=14] node[costG, below] {5} (b);   % a->b

		% r->c: externo por cima, suave (pontos de controle explícitos)
		\draw[other]
		(r) .. controls (0.8,2.4) and (5.2,3.0) ..
		node[costG, yshift=4pt, pos=0.53] {3} (c);

		% a->d (referência)
		\draw[other] (a) -- node[costG, right] {3} (d);

		% c->e: leve curvatura pela direita (sem "barriga")
		\draw[other]
		(c) .. controls (7.6,2.6) and (7.6,-2.6) ..
		node[costG, xshift=8pt, pos=0.52] {5} (e);

		% --- arcos ESCOLHIDOS (AZUL) — formam a r-arborescência T ---
		\draw[chosen] (r) -- node[costB, above] {1} (a);   % r->a
		\draw[chosen] (r) -- node[costB, below] {2} (b);   % r->b
		\draw[chosen] (a) -- node[costB, above] {1} (c);   % a->c
		\draw[chosen] (b) -- node[costB, above] {1} (d);   % b->d
		\draw[chosen] (b) -- node[costB, below] {2} (e);   % b->e

		% legenda compacta
		\node[align=left, anchor=west] at (8.4,1.9) {\footnotesize \textbf{Escolha gulosa:}\\[-2pt]
			\footnotesize para cada \(v\neq r\), escolher\\[-1pt]
			\footnotesize um arco de custo mínimo\\[-1pt]
			\footnotesize que entra em \(v\).};
		\draw[chosen] (9.0,0.8) -- +(0.9,0) node[right, costB] {\footnotesize arcos de \(T\)};
		\draw[other]  (9.0,0.2) -- +(0.9,0) node[right, costG] {\footnotesize demais arcos};
	\end{tikzpicture}

	\caption{A figura ilustra a escolha gulosa quando esta produz uma $r$-arborescência.
		Os arcos em \textcolor{blue}{azul} são os escolhidos; os cinza são os demais arcos
		de digrafo.}
\end{figure}

Suponha que \(T\) é uma \(r\)-arborescência. Não é difícil verificar que \(T\) tem custo mínimo.
De fato, seja \(F\) uma \(r\)-arborescência de \(D\). Para cada vértice \(v \neq r\), escreva \(b_v\) para o \emph{único} arco de \(F\) que entra em \(v\). Pela escolha gulosa,
\[
	c(a_v) \leq c(b_v) \quad \text{para todo } v \neq r.
\]
Logo,
\[
	c(F) \;=\; \sum_{v \in V \setminus \{r\}} c(b_v)
	\;\;\geq\;\; \sum_{v \in V \setminus \{r\}} c(a_v)
	\;=\; c(T).
\]
Portanto, \(T\) é uma \(r\)-arborescência de custo mínimo.

A seguinte figura ilustra que podemos não ter tanta sorte.
\begin{figure}[H]
	\centering
	\begin{tikzpicture}[>=Stealth, node distance=2.0cm]
		% estilos
		\tikzset{
			v/.style={circle, draw, fill=blue!8, minimum size=7mm, inner sep=0pt},
			cheap/.style={->, very thick, draw=blue!70},
			expensive/.style={->, dashed, draw=gray!60}
		}
		% nós
		\node[v] (r) {\small $r$};
		\node[v] (a) [right=2.2cm of r] {\small $a$};
		\node[v] (b) [above right=1.2cm and 1.6cm of a] {\small $b$};
		\node[v] (c) [below right=1.2cm and 1.6cm of a] {\small $c$};
		% ciclo de escolhas mais baratas (custo 1)
		\draw[cheap] (a) to[bend left=12] node[midway, above, sloped] {\scriptsize 3} (b);
		\draw[cheap] (b) to[bend left=12] node[midway, above, sloped] {\scriptsize 2} (c);
		\draw[cheap] (c) to[bend left=14] node[midway, below, sloped] {\scriptsize 3} (a);
		% arcos da raiz mais caros (não escolhidos pelo critério local)
		\draw[expensive] (r) to[bend left=8] node[midway, above, sloped] {\scriptsize 3} (a);
		\draw[expensive] (r) to[bend left=18] node[midway, above, sloped] {\scriptsize 4} (b);
		\draw[expensive] (r) to[bend right=10] node[midway, below, sloped] {\scriptsize 5} (c);
	\end{tikzpicture}
	\caption{Os arcos azuis são os da escolha gulosa.}
\end{figure}
Ora, se no lugar do arco $(c,a)$ tivessemos escolhido o arco $(r, a)$, então
$r$-arborescência resultante seria de custo mínimo.
\begin{figure}[H]
	\centering
	\begin{tikzpicture}[>=Stealth, node distance=2.0cm]
		% estilos
		\tikzset{
			v/.style={circle, draw, fill=blue!8, minimum size=7mm, inner sep=0pt},
			cheap/.style={->, very thick, draw=blue!70},
			expensive/.style={->, dashed, draw=gray!60}
		}
		% nós
		\node[v] (r) {\small $r$};
		\node[v] (a) [right=2.2cm of r] {\small $a$};
		\node[v] (b) [above right=1.2cm and 1.6cm of a] {\small $b$};
		\node[v] (c) [below right=1.2cm and 1.6cm of a] {\small $c$};
		% ciclo de escolhas mais baratas (custo 1)
		\draw[cheap] (a) to[bend left=12] node[midway, above, sloped] {\scriptsize 3} (b);
		\draw[cheap] (b) to[bend left=12] node[midway, above, sloped] {\scriptsize 2} (c);
		\draw[expensive] (c) to[bend left=14] node[midway, below, sloped] {\scriptsize 3} (a);
		% arcos da raiz mais caros (não escolhidos pelo critério local)
		\draw[cheap] (r) to[bend left=8] node[midway, above, sloped] {\scriptsize 3} (a);
		\draw[expensive] (r) to[bend left=18] node[midway, above, sloped] {\scriptsize 4} (b);
		\draw[expensive] (r) to[bend right=10] node[midway, below, sloped] {\scriptsize 5} (c);
	\end{tikzpicture}
	\caption{Os arcos azuis são os da escolha gulosa.}
\end{figure}

O exemplo acima sugere que devemos formar o subdigrafo $H$ de $D$
com \(V(H)=V(D)\) e
\[
	A(H)\;:=\; \bigcup_{v \in V \setminus \{r\}}
	\arg\min\{\, c(a) : a \in \delta^{-}(v) \,\}.
\]
Ou seja, para cada \(v \neq r\) incluímos em \(H\) \emph{todos} os arcos de custo mínimo que entram em \(v\).
Um argumento análogo ao anterior mostra que, se \(H\) contém uma \(r\)-arborescência, então ela é de custo mínimo.

Infelizmente, só isso não é suficiente, como mostra a próxima figura.
\begin{figure}[H]
	\centering
	\begin{tikzpicture}[>=Stealth, node distance=2.0cm]
		% estilos
		\tikzset{
			v/.style={circle, draw, fill=blue!8, minimum size=7mm, inner sep=0pt},
			cheap/.style={->, very thick, draw=blue!70},
			expensive/.style={->, dashed, draw=gray!60}
		}
		% nós
		\node[v] (r) {\small $r$};
		\node[v] (a) [right=2.2cm of r] {\small $a$};
		\node[v] (b) [above right=1.2cm and 1.6cm of a] {\small $b$};
		\node[v] (c) [below right=1.2cm and 1.6cm of a] {\small $c$};
		% ciclo de escolhas mais baratas (custo 1)
		\draw[cheap] (a) to[bend left=12] node[midway, above, sloped] {\scriptsize 3} (b);
		\draw[cheap] (b) to[bend left=12] node[midway, above, sloped] {\scriptsize 2} (c);
		\draw[cheap] (c) to[bend left=14] node[midway, below, sloped] {\scriptsize 1} (a);
		% arcos da raiz mais caros (não escolhidos pelo critério local)
		\draw[expensive] (r) to[bend left=8] node[midway, above, sloped] {\scriptsize 3} (a);
		\draw[expensive] (r) to[bend left=18] node[midway, above, sloped] {\scriptsize 4} (b);
		\draw[expensive] (r) to[bend right=10] node[midway, below, sloped] {\scriptsize 5} (c);
	\end{tikzpicture}
	\caption{Os arcos azuis são os da escolha gulosa.}
	\label{fig:antes:red}
\end{figure}

O ideal, do ponto de vista algorítmico, é dispor de uma forma simples de identificar o subdigrafo \(H\).
Uma transformação nos custos fornece exatamente isso. Para tanto, introduzimos a noção de
\textbf{custo \(q\)-reduzido}.

Seja \(q : V \setminus \{r\} \to \mathbb{R}\) (convencionamos \(q(r)=0\)).
Definimos o \textbf{custo \(q\)-reduzido} \(c_q : A \to \mathbb{R}\) por
\[
	c_q(a) := c(a) - q\bigl(\head(a)\bigr), \qquad a \in A.
\]
Para um conjunto \(X \subseteq V\), escrevemos \(q(X) := \sum_{u \in X} q(u)\).

A próxima proposição mostra que a transformação por custo \(q\)-reduzido preserva a otimalidade.

\begin{proposicao}
	Para toda função \(q: V\setminus \{r\} \to \mathbb{R}\),
	uma \(r\)-arborescência \(T\) é \(c\)-mínima em \(D\) se, e somente se, \(T\) é \(c_q\)-mínima em \(D\).
\end{proposicao}
\begin{proof}[Prova.]
	Seja \(F\) uma \(r\)-arborescência. Para cada \(u \in V \setminus \{r\}\), seja \(a_u\) o único arco de \(F\) que entra em \(u\). Então
	\begin{align*}
		c_q(F)
		 & = \sum_{u \in V \setminus \{r\}} c_q(a_u)                                     \\
		 & = \sum_{u \in V \setminus \{r\}} \bigl(c(a_u) - q(u)\bigr)                    \\
		 & = \sum_{u \in V \setminus \{r\}} c(a_u) - \sum_{u \in V \setminus \{r\}} q(u) \\
		 & = c(F) - q(V \setminus \{r\}).
	\end{align*}
	Assim, para quaisquer $r$-arborescências $T$ e $F$,
	\[
		c(T) \le c(F)
		\;\;\Longleftrightarrow\;\;
		c'(T) = c(T) - q(V \setminus \{r\}) \le c(F) - q(V \setminus \{r\}) = c_q(F),
	\]
	o que prova a proposição.
\end{proof}

Para cada \(v \in V \setminus \{r\}\), defina
\[
	\lambda(v) := \lambda_c(v) := \min\{\, c(a) : a \in \delta^{-}(v) \,\}.
\]
Note que $\lambda$ está bem definida uma vez que $D$ possui uma $r$-arborescência e, portanto,
existe ao menos um arco que entra em cada vértice diferente de $r$.
Então, para todo \(v \in V \setminus \{r\}\),
\[
	\min\{\, c_\lambda(a) : a \in \delta^{-}(v) \,\} = 0,
\]
isto é, precisamente os arcos de custo mínimo que entram em \(v\) passam a ter custo zero, e os demais ficam com custo positivo.
Consequentemente, o subdigrafo \(H\) obtém-se simplesmente como o subdigrafo induzido pelos arcos de custo zero de \(c_\lambda\):
\[
	V(H) = V(D)
	\quad\text{e}\quad
	A(H) = \{\, a \in A : c_\lambda(a) = 0 \,\}.
\]

A figura a seguir ilustra a redução de custos no digrafo da Figura~\ref{fig:antes:red}.

\begin{figure}[H]
	\centering
	\begin{tikzpicture}[>=Stealth, node distance=2.0cm]
		% estilos
		\tikzset{
			v/.style={circle, draw, fill=blue!8, minimum size=7mm, inner sep=0pt},
			cheap/.style={->, very thick, draw=blue!70},
			expensive/.style={->, dashed, draw=gray!60}
		}
		% nós
		\node[v] (r) {\small $r$};
		\node[v] (a) [right=2.2cm of r] {\small $a$};
		\node[v] (b) [above right=1.2cm and 1.6cm of a] {\small $b$};
		\node[v] (c) [below right=1.2cm and 1.6cm of a] {\small $c$};
		% ciclo de escolhas mais baratas (custo 1)
		\draw[cheap] (a) to[bend left=12] node[midway, above, sloped] {\scriptsize 0} (b);
		\draw[cheap] (b) to[bend left=12] node[midway, above, sloped] {\scriptsize 0} (c);
		\draw[cheap] (c) to[bend left=14] node[midway, below, sloped] {\scriptsize 0} (a);
		% arcos da raiz mais caros (não escolhidos pelo critério local)
		\draw[expensive] (r) to[bend left=8] node[midway, above, sloped] {\scriptsize 2} (a);
		\draw[expensive] (r) to[bend left=18] node[midway, above, sloped] {\scriptsize 1} (b);
		\draw[expensive] (r) to[bend right=10] node[midway, below, sloped] {\scriptsize 3} (c);
	\end{tikzpicture}
	\caption{Os arcos azuis são os da escolha gulosa.}
\end{figure}

Podemos agora retomar o caso no qual o subdigrafo gerador $H$ de $D$, cujo
arcos são aqueles cujo custo $\lambda$-reduzido é zero, não possui uma $r$-arborescência.
Vamos mostrar que $H$ possui um ciclo.

Seja $v \neq r$ um vértice de $V$ que \emph{não} é alcançável a partir de $r$ em $H$.
Considere um caminho simples maximal%
\footnote{Maximal aqui tem o seguinte sentido. Para cada vértice $u$
	de $H$, as sequencias $P \cdot u$ e $u \cdot P$ não são caminhos simples.}
de $H$ que termina em $v$.
Seja $u$ o início de $P$. Como $v$ não é atingível a partir de $r$, temos que
$u \neq r$. Logo, existe exatamente um arco, digamos $wv$, de $H$ que entra em $u$.
Pela maximalidade de \(P\), o vértice \(w\) é um dos vértices de \(P\) (caso contrário,
$w \cdot P$ é um caminho simples, o que contraria a escolha de $P$).
Como \(P\) é um caminho simples que começa em \(u\), o vértice \(w\) aparece
em \(P\) \emph{após} \(u\); portanto, \(P\) contém um subcaminho $S$ de \(u\) até \(w\).
Consequentemente, $S \cdot u$ é um ciclo de $H$.

\begin{figure}[h]
	\centering
	\begin{tikzpicture}[>=Stealth]
		% estilos
		\tikzset{
			vtx/.style={circle, draw, thick, inner sep=1pt, minimum size=6mm},
			Pdash/.style={->, thick, densely dashed},   % parte tracejada de P
			cycleedge/.style={->, ultra thick}          % arco que fecha o ciclo
		}

		% vértices em coordenadas (distância maior entre u e w)
		\node[vtx] (u) at (0,0) {$u$};
		\node[vtx] (w) at (4.8,0) {$w$};
		\node[vtx] (d) at (7.2,0) {$d$};
		\node[vtx] (v) at (9.6,0) {$v$};

		% raiz r (apenas contexto)
		\node[vtx] (r) at (-2,1.6) {$r$};
		\node at (-2,2.2) {\small raiz};

		% --- Caminho P ---
		% parte inicial de P (u ~~~> w) como arco ondulado azul (sem o vértice intermediário)
		\draw[blue, very thick, -{Stealth[length=2mm]}, decorate,
		decoration={snake, amplitude=1.2pt, segment length=5pt}]
		(u) .. controls (1.4,1.2) and (3.4,1.2) .. node[midway, yshift=8pt] {$S$} (w);

		% continuação de P (tracejada): w -> d -> v
		\draw[Pdash] (w) -- (d);
		\draw[Pdash] (d) -- (v);

		% rótulo P (afastado do arco w->u)
		\node at (7.2,-0.9) {\small \(P\)};

		% arco que fecha o ciclo: w -> u
		\draw[cycleedge, bend left=35] (w) to node[above, yshift=1pt] {$wu \in T$} (u);
	\end{tikzpicture}

	\caption{O caminho simples maximal \(P\) inicia em \(u\) e termina em \(v\).
		A porção \(S\) de \(P\) entre \(u\) e \(w\) é indicada pelo arco ondulado azul; o
		caminho $S \cdot u$ é um ciclo.}
\end{figure}

A solução consiste em \emph{normalizar os custos por vértice}: para cada \(v\neq r\), subtraímos de todo arco que entra em \(v\) o menor custo entre os arcos que chegam a \(v\). Após esse ajuste (custos reduzidos), cada \(v\neq r\) passa a ter ao menos um arco de custo reduzido zero. Se os arcos de custo zero forem acíclicos, já temos a r-arborescência ótima. Se formarem um ciclo \(C\), \emph{contraímos} \(C\) em um \textbf{supervértice} \(x_C\), ajustamos os custos dos arcos externos e resolvemos recursivamente no grafo menor.

A seguir, detalhamos essa operação de contração de ciclos.

\subsection*{Contração de ciclos}

Vamos agora formalizar a operação de contração de ciclos. Seja \((D, c, r)\) um \(r\)-dígrafo ponderado e seja \(C\) um ciclo dirigido de \(D\) tal que \(r \notin C\). A \textbf{contração de \(C\)} consiste em formar um novo dígrafo \(D' = (V', A')\) substituindo todos os vértices de \(C\) por um único \textbf{supervértice} \(x_C\) tal que \(x_C \notin V\). Formalmente, o conjunto de vértices de \(D'\) é dado por
\[
	V' \;:=\; (V \setminus C) \cup \{x_C\}.
\]

O conjunto de arcos \(A'\) é construído a partir de \(A\) da seguinte forma: para cada arco \(a = (u,v) \in A\), mantemos \(a\) inalterado em \(A'\) se ambos \(u\) e \(v\) estão fora de \(C\); descartamos \(a\) se ambos pertencem a \(C\); criamos um arco \((u, x_C)\) se \(u \notin C\) e \(v \in C\); e criamos um arco \((x_C, v)\) se \(u \in C\) e \(v \notin C\).

Ajustamos os custos dos arcos que entram e saem do supervértice \(x_C\) em \(D'\) para refletir a contração do ciclo \(C\) da seguinte forma: para cada arco \((u, v)\) com \(u \notin C\) e \(v \in C\), o custo do arco contraído \((u, x_C)\) é definido como \(c_\lambda(u,v)\), onde \(\lambda(v) = \min\{c(a) : a \in \delta^-(v)\}\) é o custo mínimo de entrada em \(v\) e de forma semelhante,para cada arco \((u, v)\) com \(u \in C\) e \(v \notin C\), o custo do arco contraído \((x_C, v)\) é definido como \(c_\lambda(u,v)\), onde \(c_\lambda(u,v) = c(u,v) - \lambda(v)\) e \(\lambda(v) = \min\{c(a) : a \in \delta^-(v)\}\) é o custo mínimo de entrada em \(v\).

Agora vamos ilustrar um exemplo de como essa contração é feita e os custos são ajustados.

Considere o dígrafo \(D\) a seguir, com o ciclo \(C = (v_1, v_2, v_3, v_1)\).

\begin{figure}[H]
	\centering
	\begin{tikzpicture}[>=Stealth, node distance=2.0cm]
		% estilos
		\tikzset{
			v/.style={circle, draw, fill=blue!8, minimum size=7mm, inner sep=0pt},
			cycle/.style={->, very thick, draw=blue!70},
			arcs/.style={->, dashed, draw=gray!60},
		}
		% nós
		\node[v] (r) {\small $r$};
		\node[v] (v1) [right=2.2cm of r] {\small $v_1$};
		\node[v] (v2) [above right=1.2cm and 1.6cm of v1] {\small $v_2$};
		\node[v] (v3) [below right=1.2cm and 1.6cm of v1] {\small $v_3$};
		% vértices adicionais que saem do ciclo
		\node[v] (u) [right=2.0cm of v2] {\small $u$};
		\node[v] (w) [right=2.0cm of v3] {\small $w$};
		% ciclo de escolhas mais baratas (custo 1)
		\draw[cycle] (v1) to[bend left=12] node[midway, above, sloped] {\scriptsize 3} (v2);
		\draw[cycle] (v2) to[bend left=12] node[midway, above, sloped] {\scriptsize 2} (v3);
		\draw[cycle] (v3) to[bend left=14] node[midway, below, sloped] {\scriptsize 3} (v1);
		% arcos da raiz mais caros (não escolhidos pelo critério local)
		\draw[arcs] (r) to[bend left=8] node[midway, above, sloped] {\scriptsize 3} (v1);
		\draw[arcs] (r) to[bend left=18] node[midway, above, sloped] {\scriptsize 4} (v2);
		\draw[arcs] (r) to[bend right=10] node[midway, below, sloped] {\scriptsize 5} (v3);
		% arcos saindo do ciclo
		\draw[arcs] (v2) -- node[midway, above] {\scriptsize 1} (u);
		\draw[arcs] (v3) -- node[midway, below] {\scriptsize 2} (w);
		\draw[arcs] (v3) -- node[midway, below] {\scriptsize 4} (u);
	\end{tikzpicture}
	\caption{O dígrafo \(D\) com o ciclo \(C = (v_1, v_2, v_3, v_1)\). Os arcos azuis representam os arcos do ciclo, os tracejados representam os demais arcos do digrafo.}
\end{figure}

Após a normalização dos custos, os arcos internos do ciclo passam a ter custo reduzido zero e os demais arcos são ajustados conforme a definição de custo \(\lambda\)-reduzido.:

\begin{figure}[H]
	\centering
	\begin{tikzpicture}[>=Stealth, node distance=2.0cm]
		% estilos
		\tikzset{
			v/.style={circle, draw, fill=blue!8, minimum size=7mm, inner sep=0pt},
			cycle/.style={->, very thick, draw=blue!70},
			arc/.style={->, dashed, draw=gray!60},
			redarc/.style={->, dashed, draw=red!60}
		}
		% nós
		\node[v] (r) {\small $r$};
		\node[v] (v1) [right=2.2cm of r] {\small $v_1$};
		\node[v] (v2) [above right=1.2cm and 1.6cm of v1] {\small $v_2$};
		\node[v] (v3) [below right=1.2cm and 1.6cm of v1] {\small $v_3$};
		% vértices adicionais que saem do ciclo
		\node[v] (u) [right=2.0cm of v2] {\small $u$};
		\node[v] (w) [right=2.0cm of v3] {\small $w$};

		% ciclo com custo reduzido zero
		\draw[cycle] (v1) to[bend left=12] node[midway, above, sloped] {\scriptsize 0} (v2);
		\draw[cycle] (v2) to[bend left=12] node[midway, above, sloped] {\scriptsize 0} (v3);
		\draw[cycle] (v3) to[bend left=14] node[midway, below, sloped] {\scriptsize 0} (v1);
		% arcos da raiz com custos reduzidos
		\draw[arc] (r) to[bend left=8] node[midway, above, sloped] {\scriptsize 0} (v1);
		\draw[arc] (r) to[bend left=18] node[midway, above, sloped] {\scriptsize 1} (v2);
		\draw[arc] (r) to[bend right=10] node[midway, below, sloped] {\scriptsize 3} (v3);
		% arcos saindo do ciclo com custo reduzido zero
		\draw[arc] (v2) -- node[midway, above] {\scriptsize 0} (u);
		\draw[arc] (v3) -- node[midway, below] {\scriptsize 0} (w);
		\draw[arc] (v3) -- node[midway, below] {\scriptsize 3} (u);
	\end{tikzpicture}
	\caption{Dígrafo com custos \(\lambda\)-reduzidos. Os arcos internos do ciclo \(C\) têm custo zero (em azul). Os arcos da raiz para o ciclo têm custos 1, 0 e 3 (tracejados).}
\end{figure}

Após a contração do ciclo \(C\), obtemos o dígrafo \(D'\) com o supervértice \(x_C\).

\begin{figure}[H]
	\centering
	\begin{tikzpicture}[>=Stealth, node distance=2.0cm]
		% estilos
		\tikzset{
			v/.style={circle, draw, fill=blue!8, minimum size=7mm, inner sep=0pt},
			super/.style={circle, draw, very thick, fill=gray!10, minimum size=9mm, inner sep=0pt},
			cheap/.style={->, very thick, draw=blue!70},
			expensive/.style={->, dashed, draw=gray!60}
		}
		% nós
		\node[v] (r) {\small $r$};
		\node[super] (xC) [right=3.5cm of r] {\small $x_C$};
		\node[v] (u) [above right=1.2cm and 2.0cm of xC] {\small $u$};
		\node[v] (w) [below right=1.2cm and 2.0cm of xC] {\small $w$};
		% arcos do dígrafo contraído que entram em xC (mantêm arcos paralelos, escolhemos o de menor custo)
		\draw[cheap] (r) to[bend left=12] node[midway, above, sloped] {\scriptsize 0} (xC);
		% arcos que saem de xC
		\draw[cheap] (xC) to[bend left=8] node[midway, above] {\scriptsize 0} (u);
		\draw[cheap] (xC) to[bend right=8] node[midway, below] {\scriptsize 0} (w);
	\end{tikzpicture}
	\caption{Dígrafo \(D'\) após a contração do ciclo \(C\). O supervértice \(x_C\) substitui todos os vértices do ciclo. Originalmente, havia três arcos paralelos de \(r\) para o ciclo: \((r, v_1)\), \((r, v_2)\) e \((r, v_3)\) com custos reduzidos 1, 0 e 3; mantemos apenas o de menor custo 0. Os arcos que saíam do ciclo agora saem de \(x_C\): \((x_C, u)\) com custo 0 e \((x_C, w)\) com custo 0. Note que havia dois arcos de vértices do ciclo para \(u\); mantemos apenas o de menor custo.}
\end{figure}

Por definição não admitimos gerar arcos paralelos entre um mesmo par de vértices, mantemos apenas o arco de menor custo, conforme ilustrado do vértice \(r\) para o supervértice \(x_C\) e de \(x_C\) para \(u\) e isso não afeta a otimalidade, já que na reexpansão qualquer escolha entre arcos paralelos conduz à mesma solução ótima.

Com isso, vale a pena destacar que, mesmo que arborescências ótimas diferentes em \(D\) possam levar a arborescências ótimas diferentes em \(D'\), o custo ótimo permanece o mesmo. E as arborescências ótimas em \(D'\) podem ser reexpandidas para obter arborescências ótimas em \(D\), mas não são necessariamente bijetivas, conforme o exemplo abaixo:

Considere o dígrafo a seguir com custos originais:

\begin{figure}[H]
	\centering
	\begin{tikzpicture}[>=Stealth, node distance=2.0cm]
		% estilos
		\tikzset{
			v/.style={circle, draw, fill=blue!8, minimum size=7mm, inner sep=0pt},
			cheap/.style={->, thick, draw=blue!70},
			expensive/.style={->, dashed, draw=gray!60}
		}
		% nós
		\node[v] (r) {\small $r$};
		\node[v] (v1) [right=2.2cm of r] {\small $v_1$};
		\node[v] (v2) [above right=1.2cm and 1.6cm of v1] {\small $v_2$};
		\node[v] (v3) [below right=1.2cm and 1.6cm of v1] {\small $v_3$};
		\node[v] (u) [right=2.0cm of v2] {\small $u$};

		% ciclo
		\draw[cheap] (v1) to[bend left=12] node[midway, above, sloped] {\scriptsize 2} (v2);
		\draw[cheap] (v2) to[bend left=12] node[midway, above, sloped] {\scriptsize 3} (v3);
		\draw[cheap] (v3) to[bend left=14] node[midway, below, sloped] {\scriptsize 1} (v1);
		% dois arcos paralelos da raiz para o ciclo com mesmo custo
		\draw[expensive] (r) to[bend left=8] node[midway, above, sloped] {\scriptsize 4} (v1);
		\draw[expensive] (r) to[bend right=10] node[midway, below, sloped] {\scriptsize 5} (v3);
		% arco saindo do ciclo
		\draw[expensive] (v2) -- node[midway, above] {\scriptsize 4} (u);
	\end{tikzpicture}
	\caption{Dígrafo \(D\) com custos originais. O ciclo \(C = (v_1, v_2, v_3, v_1)\) tem arcos com custos 2, 3 e 1. Existem dois arcos da raiz para o ciclo, ambos com custo 5: \((r, v_1)\) e \((r, v_3)\).}
\end{figure}

Após a normalização dos custos (subtraindo \(\lambda(v_1) = 5\), \(\lambda(v_2) = 2\), \(\lambda(v_3) = 3\) e \(\lambda(u) = 4\)), obtemos:

\begin{figure}[H]
	\centering
	\begin{tikzpicture}[>=Stealth, node distance=2.0cm]
		% estilos
		\tikzset{
			v/.style={circle, draw, fill=blue!8, minimum size=7mm, inner sep=0pt},
			cheap/.style={->, thick, draw=blue!70},
			expensive/.style={->, dashed, draw=gray!60}
		}
		% nós
		\node[v] (r) {\small $r$};
		\node[v] (v1) [right=2.2cm of r] {\small $v_1$};
		\node[v] (v2) [above right=1.2cm and 1.6cm of v1] {\small $v_2$};
		\node[v] (v3) [below right=1.2cm and 1.6cm of v1] {\small $v_3$};
		\node[v] (u) [right=2.0cm of v2] {\small $u$};

		% ciclo com custos reduzidos zero
		\draw[cheap] (v1) to[bend left=12] node[midway, above, sloped] {\scriptsize 0} (v2);
		\draw[cheap] (v2) to[bend left=12] node[midway, above, sloped] {\scriptsize 0} (v3);
		\draw[cheap] (v3) to[bend left=14] node[midway, below, sloped] {\scriptsize 0} (v1);
		% dois arcos paralelos da raiz para o ciclo com mesmo custo reduzido
		\draw[expensive] (r) to[bend left=8] node[midway, above, sloped] {\scriptsize 4} (v1);
		\draw[expensive] (r) to[bend right=10] node[midway, below, sloped] {\scriptsize 5} (v3);
		% arco saindo do ciclo
		\draw[expensive] (v2) -- node[midway, above] {\scriptsize 4} (u);
	\end{tikzpicture}
	\caption{Dígrafo \(D\) com custos \(\lambda\)-reduzidos. Todos os arcos do ciclo custo mínimo têm agora custo zero.}
\end{figure}

Após a normalização, existem duas \(r\)-arborescências ótimas distintas em \(D\), ilustradas a seguir:

\begin{figure}[H]
	\centering
	\begin{tikzpicture}[>=Stealth, node distance=1.8cm, scale=0.85, transform shape]
		% estilos
		\tikzset{
			v/.style={circle, draw, fill=blue!8, minimum size=6mm, inner sep=0pt},
			selected/.style={->, ultra thick, draw=blue!70},
			notselected/.style={->, thick, draw=gray!30}
		}

		% Primeira arborescência
		\begin{scope}[xshift=-2.5cm]
			\node at (2.5, 2.3) {\textbf{Arborescência \(T_1\)}};
			% nós
			\node[v] (r) {\small $r$};
			\node[v] (v1) [right=1.8cm of r] {\small $v_1$};
			\node[v] (v2) [above right=1.0cm and 1.4cm of v1] {\small $v_2$};
			\node[v] (v3) [below right=1.0cm and 1.4cm of v1] {\small $v_3$};
			\node[v] (u) [right=1.6cm of v2] {\small $u$};

			% arcos selecionados
			\draw[selected] (r) to[bend left=8] node[midway, above, sloped] {\scriptsize 0} (v1);
			\draw[selected] (v1) to[bend left=12] node[midway, above, sloped] {\scriptsize 0} (v2);
			\draw[selected] (v2) to[bend left=12] node[midway, above, sloped] {\scriptsize 0} (v3);
			\draw[selected] (v2) -- node[midway, above] {\scriptsize 0} (u);
			% arcos não selecionados
			\draw[notselected] (r) to[bend right=10] (v3);
			\draw[notselected] (v3) to[bend left=14] (v1);
		\end{scope}

		% Segunda arborescência
		\begin{scope}[xshift=6.5cm]
			\node at (3.5, 2.3) {\textbf{Arborescência \(T_2\)}};
			% nós
			\node[v] (r) {\small $r$};
			\node[v] (v1) [right=1.8cm of r] {\small $v_1$};
			\node[v] (v2) [above right=1.0cm and 1.4cm of v1] {\small $v_2$};
			\node[v] (v3) [below right=1.0cm and 1.4cm of v1] {\small $v_3$};
			\node[v] (u) [right=1.6cm of v2] {\small $u$};

			% arcos selecionados
			\draw[selected] (r) to[bend right=10] node[midway, below, sloped] {\scriptsize 0} (v3);
			\draw[selected] (v3) to[bend left=14] node[midway, below, sloped] {\scriptsize 0} (v1);
			\draw[selected] (v1) to[bend left=12] node[midway, above, sloped] {\scriptsize 0} (v2);
			\draw[selected] (v2) -- node[midway, above] {\scriptsize 0} (u);
			% arcos não selecionados
			\draw[notselected] (r) to[bend left=8] (v1);
			\draw[notselected] (v2) to[bend left=12] (v3);
		\end{scope}
	\end{tikzpicture}
	\caption{Duas \(r\)-arborescências ótimas distintas em \(D\) com custos \(c_\lambda\)-reduzidos. \(T_1\) usa o arco \((r, v_1)\) e os arcos do ciclo \((v_1, v_2)\) e \((v_2, v_3)\). \(T_2\) usa o arco \((r, v_3)\) e os arcos do ciclo \((v_3, v_1)\) e \((v_1, v_2)\). Ambas incluem o arco \((v_2, u)\) e têm custo total zero.}
\end{figure}

Após a contração do ciclo \(C\), ambas as arborescências \(T_1\) e \(T_2\) mapeiam para a mesma arborescência \(T'\) no dígrafo contraído \(D'\):

\begin{figure}[H]
	\centering
	\begin{tikzpicture}[>=Stealth, node distance=2.0cm]
		% estilos
		\tikzset{
			v/.style={circle, draw, fill=blue!8, minimum size=7mm, inner sep=0pt},
			super/.style={circle, draw, fill=orange!15, minimum size=9mm, inner sep=0pt},
			selected/.style={->, ultra thick, draw=blue!70}
		}

		\node at (0, 1.5) {\textbf{Arborescência \(T'\) em \(D'\)}};
		% nós
		\node[v] (r) {\small $r$};
		\node[super] (xC) [right=3.5cm of r] {\small $x_C$};
		\node[v] (u) [right=2.5cm of xC] {\small $u$};

		% arcos selecionados
		\draw[selected] (r) to node[midway, above] {\scriptsize 0} (xC);
		\draw[selected] (xC) to node[midway, above] {\scriptsize 0} (u);
	\end{tikzpicture}
	\caption{Arborescência \(T'\) no dígrafo contraído \(D'\). Tanto \(T_1\) quanto \(T_2\) são mapeadas para esta mesma arborescência, demonstrando que a correspondência não é bijetiva. O custo total de \(T'\) é zero, igual ao custo de \(T_1\) e \(T_2\).}
\end{figure}

Logo, a correspondência não é bijetiva, pois duas arborescências distintas em \(D\) correspondem à mesma arborescência em \(D'\). Isso ocorre porque ambos os arcos \((r, v_1)\) e \((r, v_3)\) têm o mesmo custo \(\lambda\)-reduzido (zero) e ambos entram no ciclo \(C\); após a contração, ambos são representados pelo único arco \((r, x_C)\) no dígrafo contraído.

A seguir, apresentamos a proposição que estabelece a correspondência entre as \(r\)-arborescências de \(D\) e \(D'\) após a contração do ciclo \(C\).

\begin{proposicao}
	Seja \(C\) um ciclo dirigido em \(D\) com \(r \notin C\), e seja \(D'\) o dígrafo obtido pela contração de \(C\). Para cada vértice \(v \in C\), seja \(a_v\) o único arco de \(C\) que entra em \(v\), e suponha que \(c_\lambda(a_v) = 0\) para todo \(v \in C\), onde \(\lambda(v) = \min\{c(a) : a \in \delta^-(v)\}\). Defina os custos \(c' : A' \to \mathbb{R}\) por
	\[
		c'(a') \;:=\;
		\begin{cases}
			c_\lambda(a)   & \text{se } a' = a \text{ e } a \text{ não envolve } C,                      \\
			c_\lambda(u,w) & \text{se } a' = (u, x_C) \text{ corresponde a } (u,w) \text{ com } w \in C, \\
			c_\lambda(u,v) & \text{se } a' = (x_C, v) \text{ corresponde a } (u,v) \text{ com } u \in C.
		\end{cases}
	\]
	Então existe uma correspondência bijetiva entre as \(r\)-arborescências de \(D'\) com custos \(c'\) e as \(r\)-arborescências de \(D\) com custos \(c_\lambda\) que contêm exatamente um arco entrando em \(C\). Note que, em geral, pode haver múltiplas arborescências ótimas de \(D\) que são mapeadas para uma mesma arborescência ótima de \(D'\), ou seja, a correspondência entre arborescências ótimas pode não ser bijetiva.
\end{proposicao}

\begin{proof}[Prova.]
	Seja \(T'\) uma \(r\)-arborescência de \(D'\). Como \(x_C\) é um vértice de \(D'\) e \(x_C \neq r\), existe exatamente um arco de \(T'\) que entra em \(x_C\). Seja \((u, x_C)\) esse arco. No dígrafo original \(D\), o arco \((u, x_C)\) corresponde a um arco \((u, w)\) para algum \(w \in C\).

	Definimos \(T \subseteq A\) da seguinte forma: para cada arco \(a' \in T'\) que não envolve \(x_C\), incluímos o arco correspondente \(a \in A\) em \(T\); para o arco \((u, x_C) \in T'\), incluímos \((u,w) \in A\) em \(T\); e incluímos todos os arcos de \(C\), com exceção do arco \(a_w\) que entra em \(w\).

	Afirmamos que \(T\) é uma \(r\)-arborescência de \(D\). De fato, para cada vértice \(v \in V \setminus \{r\}\), se \(v \notin C\), então \(v \in V'\) e há exatamente um arco de \(T'\) entrando em \(v\), logo há exatamente um arco de \(T\) entrando em \(v\). Se \(v \in C\) e \(v \neq w\), então o único arco de \(T\) entrando em \(v\) é o arco \(a_v\) do ciclo \(C\). Finalmente, se \(v = w\), o único arco de \(T\) entrando em \(w\) é precisamente \((u,w)\).

	Além disso, como \(T'\) é acíclico em \(D'\) e os arcos do ciclo \(C\) formam um caminho de \(w\) até seus predecessores em \(C\) (exceto o arco removido \(a_w\)), o conjunto \(T\) permanece acíclico. Portanto, \(T\) é uma \(r\)-arborescência de \(D\).

	Reciprocamente, seja \(T\) uma \(r\)-arborescência de \(D\) que contém exatamente um arco entrando em \(C\), digamos \((u,w)\) com \(u \notin C\) e \(w \in C\). Definimos \(T' \subseteq A'\) mantendo cada arco de \(T\) que não envolve vértices de \(C\), substituindo o arco \((u,w)\) por \((u, x_C)\), e descartando os arcos internos de \(C\) presentes em \(T\). É direto verificar que \(T'\) é uma \(r\)-arborescência de \(D'\) e que essa correspondência é bijetiva.

	Finalmente, como todos os arcos \(a_v\) do ciclo \(C\) têm custo \(c_\lambda\)-reduzido zero, temos
	\[
		c_\lambda(T) \;=\; \sum_{a \in T \setminus C} c_\lambda(a) + c_\lambda(u,w)
		\;=\; c'(T'),
	\]
	o que estabelece a correspondência entre custos.
\end{proof}

Essa proposição justifica a estratégia recursiva do algoritmo: resolver o problema no grafo contraído \(D'\) com custos ajustados \(c'\) e, em seguida, expandir a solução para o grafo original \(D\).

A seguir, apresentamos a implementação completa do algoritmo de Chu–Liu e Edmonds para encontrar uma \(r\)-arborescência de custo mínimo em um \(r\)-dígrafo ponderado \((D, c, r)\).

\section{Descrição do algoritmo}
A seguir apresentamos uma descrição do algoritmo de Chu–Liu/Edmonds. Detalhes de implementação serão discutidos na próxima seção. Denotamos por \(A'\) o conjunto de arcos escolhidos na construção da r-arborescência.

Construa \(A'\) escolhendo, para cada \(v\neq r\), um arco de menor custo que entra em \(v\). Se \((V,A')\) é acíclico, então \(A'\) já é uma r-arborescência ótima, pois realizamos o menor custo de entrada em cada vértice e nenhuma troca pode reduzir o custo mantendo as restrições \cite[Sec.~4.9]{kleinberg2006}.

Se \(A'\) contiver um ciclo dirigido \(C\) (que não inclui \(r\)), normalizamos os custos de entrada, contraímos \(C\) em um supervértice \(x_C\) ajustando arcos que entram em \(C\) por \(c'(u,x_C)=c(u,w)-c(a_w)\), e resolvemos recursivamente no grafo contraído.

As arborescências obtidas no grafo contraído estão em correspondência bijetiva com as arborescências do grafo original que possuem exatamente um arco entrando no ciclo \(C\). Como, após a normalização, todos os arcos internos de \(C\) passam a ter custo reduzido igual a zero, a expansão do supervértice recupera uma arborescência válida no grafo original sem alterar o custo total da solução.


\begin{figure}[H]\centering
	\begin{tikzpicture}[>=Stealth, node distance=1.2cm]
		% (a) Contraído
		\node at (-3.8,2.1) {(a) Grafo contraído};
		\node[circle,draw,minimum size=6mm] (r1) at (-6.2,1.6) {$r$};
		\node[circle,draw,minimum size=8mm,fill=gray!10] (xC1) at (-4.2,0.4) {$x_C$};
		\node[circle,draw,minimum size=6mm] (p1) at (-6.4,-0.8) {$p$};
		\node[circle,draw,minimum size=6mm] (q1) at (-2.2,1.2) {$q$};
		\node[circle,draw,minimum size=6mm] (u1) at (-1.0,-0.2) {$u$};
		\draw[->] (r1) -- (q1);
		\draw[->] (r1) -- (p1);
		\draw[->] (q1) -- (xC1);
		\draw[->,very thick] (u1) -- (xC1);

		% (b) Expandido e mapeado
		\node at (3.8,2.1) {(b) Expansão e bijeção};
		\node[circle,draw,minimum size=6mm] (r2) at (1.6,1.6) {$r$};
		\node[circle,draw,minimum size=6mm] (p2) at (1.4,-0.8) {$p$};
		\node[circle,draw,minimum size=6mm] (q2) at (5.6,1.2) {$q$};
		\node[circle,draw,minimum size=6mm] (u2b) at (6.8,-0.2) {$u$};
		% cycle C
		\draw[dashed,rounded corners] (2.6,-0.9) rectangle (4.6,1.7);
		\node at (5.10,-1.10) {$C$};
		\node[circle,draw,minimum size=6mm] (aC) at (3.0,1.2) {$a$};
		\node[circle,draw,minimum size=6mm] (bC) at (4.2,0.4) {$w$};
		\node[circle,draw,minimum size=6mm, above right] (cC) at (3.2,-0.2) {$c$};
		\draw[->] (aC) -- (bC);
		\draw[->] (bC) -- (cC);
		\draw[->] (cC) -- (aC);
		% external edges
		\draw[->] (r2) -- (q2);
		\draw[->] (r2) -- (p2);
		\draw[->] (q2) -- (aC);
		\draw[->,very thick] (u2b) -- node[above,xshift=15pt] {entra em $w$} (bC);
	\end{tikzpicture}
	\caption{Bijeção entre arborescências no grafo contraído e no original: toda arborescência em $D'$ escolhe exatamente um arco que entra em $x_C$; ao expandir $C$, esse arco corresponde a um $(u,w)$ que entra em algum $w\in C$ e os arcos internos (de custo reduzido zero) são mantidos, preservando o custo total.}
	\label{fig:chu-liu-bijection}
\end{figure}

Na expansão, reintroduzimos \(C\) e removemos exatamente um arco interno para manter grau de entrada 1 e aciclicidade global \cite{schrijver2003comb,kleinberg2006}.

\begin{figure}[H]\centering
	\begin{tikzpicture}[>=Stealth]
		% (a) Contraído
		\node at (-4.8,2.0) {(a) Contraído};
		\node[circle,draw,minimum size=6mm] (r3) at (-6.0,1.2) {$r$};
		\node[circle,draw,minimum size=8mm,fill=gray!10] (xC3) at (-4.0,0.2) {$x_C$};
		\node[circle,draw,minimum size=6mm] (u3) at (-2.0,0.2) {$u$};
		\draw[->] (r3) -- (xC3);
		\draw[->,very thick] (u3) -- (xC3);

		% (b) Expandido
		\node at (0.0,2.0) {(b) Expandido};
		\draw[dashed,rounded corners] (-1.2,-0.8) rectangle (1.2,1.6) node[below right] {$C$};
		\node[circle,draw,minimum size=6mm] (a3) at (-0.8,1.0) {$a$};
		\node[circle,draw,minimum size=6mm] (w3) at (0.8,0.4) {$w$};
		\node[circle,draw,minimum size=6mm] (c3) at (-0.4,0.0) {$c$};
		\draw[->] (a3) -- (w3);
		\draw[->] (w3) -- (c3);
		\draw[->] (c3) -- (a3);
		\node[circle,draw,minimum size=6mm] (u3b) at (2.4,0.4) {$u$};
		\draw[->,very thick] (u3b) -- (w3);

		% (c) Remoção interna
		\node at (4.8,2.0) {(c) Remoção de arco interno};
		\draw[dashed,rounded corners] (3.6,-0.8) rectangle (6.0,1.6) node[below right] {$C$};
		\node[circle,draw,minimum size=6mm] (a4) at (4.0,1.0) {$a$};
		\node[circle,draw,minimum size=6mm] (w4) at (5.6,0.4) {$w$};
		\node[circle,draw,minimum size=6mm] (c4) at (4.8,0.0) {$c$};
		\draw[->] (a4) -- (w4);
		\draw[->] (w4) -- (c4);
		% remove the closing arc with a red cross
		\draw[->] (c4) -- (a4);
		\draw[red,very thick] (4.35,0.55) -- (4.45,0.45);
		\draw[red,very thick] (4.35,0.45) -- (4.45,0.55);
	\end{tikzpicture}
	\caption{Reexpansão de $C$: no grafo contraído seleciona-se um arco que entra em $x_C$; ao expandir, $x_C$ é substituído por $C$ e o arco selecionado entra em algum $w\in C$; remove-se exatamente um arco interno de $C$ para eliminar o ciclo, preservando conectividade e custo total (arcos internos têm custo reduzido zero).}
	\label{fig:chu-liu-reexpansion}
\end{figure}

Abaixo, temos a descrição formal do algoritmo.

\begin{algobox}{Chu–Liu/Edmonds (visão operacional)}{chu-liu-edmonds}
	Entrada: digrafo \(D=(V,A)\), custos \(c:A\to\mathbb{R}_{\ge 0}\), raiz \(r\).\footnote{Se algum \(v\neq r\) não possui arco de entrada, não existe r-arborescência.}
	\begin{enumerate}\setlength{\itemsep}{2pt}
		\item Para cada \(v\neq r\), escolha \(a_v\in\operatorname*{argmin}_{(u,v)\in A} c(u,v)\). Defina \(y(v):=c(a_v)\) e \(F^*:=\{a_v: v\neq r\}.\)
		\item Se \((V,F^*)\) é acíclico, devolva \(F^*\). Por \cite[Obs.~4.36]{kleinberg2006}, trata-se de uma r-arborescência de custo mínimo.
		\item Caso contrário, seja \(C\) um ciclo dirigido de \(F^*\) (com \(r\notin C\)). \textbf{Contração:} contraia \(C\) em um supervértice \(x_C\) e defina custos \(c'\) por
		      \begin{align*}
			      c'(u,x_C) & := c(u,w) - y(w) = c(u,w) - c(a_w) &  & \text{para } u\notin C,\ w\in C, \\
			      c'(x_C,v) & := c(w,v)                          &  & \text{para } w\in C,\ v\notin C,
		      \end{align*}
		      descartando laços em \(x_C\) e permitindo paralelos. Denote o digrafo contraído por $D'=(V',A')$.
		\item \textbf{Recursão:} compute uma r-arborescência ótima \(T'\) de \(D'\) com custos \(c'\).
		\item \textbf{Expansão:} seja \((u,x_C)\in T'\) o único arco que entra em \(x_C\). No grafo original, ele corresponde a \((u,w)\) com \(w\in C\). Forme
		      \[
			      T := \bigl(T'\setminus\{\text{arcos incidentes a } x_C\}\bigr)\ \cup\ \{(u,w)\}\ \cup\ \bigl((F^*\cap A(C))\setminus\{a_w\}\bigr).
		      \]
		      Então \(T\) tem grau de entrada 1 em cada \(v\neq r\), é acíclico e tem o mesmo custo de \(T'\); logo, é uma r-arborescência ótima de \(D\) \cite[Sec.~4.9]{kleinberg2006,schrijver2003comb}.
	\end{enumerate}
\end{algobox}

\subsection{Corretude}

A corretude do algoritmo de Chu–Liu/Edmonds baseia-se em três pilares principais:
\begin{enumerate}\setlength{\itemsep}{2pt}
	\item \emph{Normalização por custos reduzidos:} para cada \(v\neq r\), defina \(y(v):=\min\{c(u,v):(u,v)\in A\}\) e \(c'(u,v):=c(u,v)-y(v)\). Para qualquer r-arborescência \(T\), vale
	      \[
		      \sum_{a\in T} c'(a) \,=\, \sum_{a\in T} c(a) \, - \, \sum_{v\neq r} y(v),
	      \]
	      pois há exatamente um arco de \(T\) entrando em cada \(v\neq r\). O termo \(\sum_{v\neq r} y(v)\) é constante (independe de \(T\)); assim, minimizar \(\sum c\) equivale a minimizar \(\sum c'\) \cite[Obs.~4.37]{kleinberg2006}. Em particular, os arcos \(a_v\) de menor custo que entram em \(v\) têm custo reduzido zero e formam \(F^*\).
	\item \emph{Caso acíclico:} se \((V,F^*)\) é acíclico, então já é uma r-arborescência e, por realizar o mínimo custo de entrada em cada \(v\neq r\), é ótima \cite[Obs.~4.36]{kleinberg2006}.
	\item \emph{Caso com ciclo (contração/expansão):} se \(F^*\) contém um ciclo dirigido \(C\), todos os seus arcos têm custo reduzido zero.

	      Contraia \(C\) em \(x_C\) e ajuste apenas arcos que \emph{entram} em \(C\): \(c'(u,x_C):=c(u,w)-y(w)=c(u,w)-c(a_w)\).

	      Resolva o problema no grafo contraído \(D'\), obtendo uma r-arborescência ótima \(T'\) sob \(c'\). Na expansão, substitua o arco \((u,x_C)\in T'\) pelo correspondente \((u,w)\) (com \(w\in C\)) e remova \(a_w\) de \(C\).

	      Como os arcos de \(C\) têm custo reduzido zero e \(c'(u,x_C)=c(u,w)-y(w)\), a soma dos custos reduzidos é preservada na ida e na volta; logo, \(T'\) ótimo em \(D'\) mapeia para \(T\) ótimo em \(D\) para \(c'\). Pela equivalência entre \(c\) e \(c'\), \(T\) também é ótimo para \(c\). Repetindo o argumento a cada contração, obtemos a corretude por indução \cite[Sec.~4.9]{kleinberg2006,schrijver2003comb}.
\end{enumerate}
Em termos intuitivos, \(y\) funciona como um potencial nos vértices: torna “apertados” (custo reduzido zero) os candidatos corretos; ciclos de arcos apertados podem ser contraídos sem perder otimalidade.

\subsection{Complexidade}

Na implementação direta, selecionar os \(a_v\), detectar/contrair ciclos e atualizar estruturas custa \(O(m)\) por nível; como o número de vértices decresce a cada contração, temos no máximo \(O(n)\) níveis e tempo total \(O(mn)\), com \(n=|V|\), \(m=|A|\).

O uso de memória é \(O(m+n)\), incluindo mapeamentos de contração/expansão e as filas de prioridade dos arcos de entrada. A implementação a seguir adota a versão \(O(mn)\) por simplicidade e está disponível no repositório do projeto (\url{https://github.com/lorenypsum/GraphVisualizer}).

\section{Implementação em Python}

Esta seção apresenta uma implementação em Python do algoritmo. A arquitetura segue os passos teóricos: recebe como entrada um digrafo ponderado, os custos das arestas e o vértice raiz. O procedimento seleciona, para cada vértice, o arco de menor custo de entrada, verifica se o grafo é acíclico e, se necessário, contrai ciclos e ajusta custos. Ao final, retorna como saída a r-arborescência ótima: um conjunto de arestas que conecta todos os vértices à raiz com custo mínimo.

Formalizamos a implementação do algoritmo de Chu--Liu/Edmonds:

\begin{itemize}\setlength{\itemsep}{2pt}
	\item \textbf{Entrada:} digrafo \(D=(V,A)\), custos \(c:A\to\mathbb{R}\) no atributo \texttt{"w"}, raiz \(r\in V\).
	\item \textbf{Hipóteses:} (i) \(D\) é conexo a partir de \(r\) — todo \(v\neq r\) é alcançável; (ii) para todo \(X\subseteq V\setminus\{r\}\), existe arco entrando em \(X\) (condições de Edmonds \cite{schrijver2003comb}); (iii) custos não negativos.
	\item \textbf{Saída:} subgrafo \(T\) com \(|A_T|=|V|-1\) arestas, grau de entrada 1 para todo \(v\neq r\), alcançabilidade a partir de \(r\) e custo \(\sum_{a\in A_T} c(a)\) mínimo.
	\item \textbf{Convenções:} arcos paralelos permitidos após contrações; laços descartados.
\end{itemize}

A implementação consiste em funções auxiliares que traduzem cada passo teórico (normalização, construção de \(F^*\), contração, reexpansão) em operações sobre \texttt{nx.DiGraph}, orquestradas por uma função principal que gerencia o fluxo recursivo. As subseções seguintes detalham cada função auxiliar: lógica, parâmetros, retornos e complexidade.

\subsection{Representação de digrafos e detecção de ciclos}

A implementação utiliza a biblioteca NetworkX\footnote{NetworkX é uma biblioteca Python para criação, manipulação e estudo de redes. Disponível em \url{https://networkx.org/}.}, especificamente a classe \texttt{nx.DiGraph} para representar digrafos \(D=(V,A)\). Internamente, usa dicionários aninhados do Python para armazenar vértices, arestas e atributos, garantindo operações eficientes: adicionar/remover aresta \(O(1)\) amortizado, iterar vizinhos \(O(\deg(u))\), percorrer todas as arestas \(O(m)\).

\subsubsection*{Métodos da API NetworkX}

Os métodos da API NetworkX utilizados na implementação dividem-se em três categorias funcionais, cada uma correspondendo a uma fase específica do algoritmo:

\paragraph*{Consulta de estrutura}
\begin{itemize}\setlength{\itemsep}{2pt}
	\item \texttt{D.nodes()}: retorna visão iterável sobre \(V\), permitindo percorrer todos os vértices.
	\item \texttt{D.in\_edges(v, data="w")}: retorna arestas entrantes em \(v\) com pesos, produzindo tuplas \((u, v, w)\). Usado para encontrar o arco de menor custo que entra em cada vértice.
	\item \texttt{D.out\_edges(u, data="w")}: retorna arestas saintes de \(u\) com pesos, análogo a \texttt{in\_edges}. Necessário na reexpansão para reintegrar arestas do ciclo.
	\item \texttt{D[u][v]["w"]}: acessa diretamente o peso da aresta \((u,v)\) para leitura ou modificação. Usado na normalização para ajustar custos reduzidos.
\end{itemize}

\paragraph*{Modificação de estrutura}
\begin{itemize}\setlength{\itemsep}{2pt}
	\item \texttt{D.add\_edge(u, v, w=peso)}: adiciona aresta \((u,v)\) com peso especificado, criando vértices automaticamente se não existirem. Usado para construir \(F^*\) e reintegrar arestas na reexpansão.
	\item \texttt{D.remove\_edges\_from(edges)}: remove múltiplas arestas em lote. Aplicado para eliminar arestas internas do ciclo contraído.
	\item \texttt{D.remove\_nodes\_from(nodes)}: remove vértices e todas as suas arestas incidentes. Usado para eliminar os vértices do ciclo original após contração.
\end{itemize}

\paragraph*{Detecção de ciclos}
\begin{itemize}\setlength{\itemsep}{2pt}
	\item \texttt{nx.find\_cycle(G, orientation="original")}: detecta ciclos via DFS (detalhado na próxima subseção).
\end{itemize}

Essa função retorna um iterador sobre as arestas do ciclo (tuplas \texttt{(u, v, key)}). Dois aspectos importantes, o retorno é iterador (não lista), economizando memória e em grafos acíclicos, lança a exceção \texttt{NetworkXNoCycle} em vez de retornar valor sentinela. Isso segue o princípio EAFP (\emph{Easier to Ask for Forgiveness than Permission}) do Python e casa naturalmente com o fluxo do algoritmo: tratamos o caso acíclico com \texttt{try-except}, distinguindo caso base (sem ciclo, retornar solução) de caso recursivo (com ciclo, contrair e recursão).

Abaixo, detalhamos as funções auxiliares que implementam os passos do algoritmo e ao final apresentamos a função principal que orquestra o fluxo recursivo.

\subsection{Normalização por vértice}

Esta função implementa a normalização de custos reduzidos: calcula \(y(v)=\min\{w(u,v)\}\) e substitui cada peso \(w(u,v)\) por \(w(u,v)-y(v)\), garantindo que ao menos uma aresta de entrada tenha custo zero. Como cada r-arborescência possui exatamente uma aresta entrando em cada vértice não-raiz, a soma total dos valores \(y(v)\) subtraídos é constante para qualquer solução, preservando assim a ordem de otimalidade entre diferentes arborescências.

Recebe como entrada um digrafo \texttt{D} (objeto \texttt{nx.DiGraph}) e o rótulo \texttt{node} do vértice a ser normalizado. A implementação coleta todas as arestas de entrada de \texttt{node} com seus pesos usando o método \texttt{D.in\_edges(node, data="w")}, que retorna uma lista de tuplas \((u, node, w)\) (linha 2). Em seguida, verifica se a lista está vazia e se estiver retorna imediatamente sem fazer alterações (linhas 3--4). Caso contrário, calcula o peso mínimo \texttt{yv} através de uma compreensão de gerador que extrai o terceiro elemento de cada tupla (linha 5) e, para cada predecessor \texttt{u}, subtrai \texttt{yv} do peso armazenado em \texttt{D[u][node]["w"]} (linha 6).

Não retorna nenhum valor (retorno implícito \texttt{None}), pois a operação é realizada in-place: o grafo \texttt{D} passado como parâmetro é modificado diretamente, e ao menos uma aresta de entrada de \texttt{node} terá custo reduzido zero após a execução. A complexidade é \(O(\deg^-(v))\), pois cada operação percorre as arestas de entrada uma única vez.

\begin{tcolorbox}[
		enhanced, breakable,
		colframe=blue!60!black, colback=blue!2,
		colbacktitle=blue!15, coltitle=black,
		title={Normalização por vértice: custos reduzidos},
		boxed title style={sharp corners, boxrule=0.6pt},
		sharp corners, boxrule=0.6pt
	]
	\emph{Normaliza os pesos das arestas que entram em \texttt{node}, subtraindo de cada uma o menor peso de entrada. Modifica o grafo D in-place.}
	\tcblower
	\begin{lstlisting}[language=Python]
def normalize_incoming_edge_weights(D: nx.DiGraph, node: str):    
    predecessors = list(D.in_edges(node, data="w"))
    if not predecessors:
        return
    yv = min((w for _, _, w in predecessors))
        D[u][node]["w"] -= yv   
\end{lstlisting}
\end{tcolorbox}

A Figura~\ref{fig:normalize-example} ilustra o funcionamento da normalização:

\begin{figure}[H]
	\centering
	\input{capitulos/implementacao-chuliu/figures/fig_normalize_example.tex}
	\caption{Exemplo de normalização de custos reduzidos. À esquerda, vértice \(v\) com três arestas de entrada (pesos 5, 3 e 7). À direita, após aplicar \texttt{normalize\_incoming\_edge\_weights(D, v)}: o menor peso \(y(v)=3\) é subtraído de todas as entradas, resultando em custos reduzidos 2, 0 e 4. A aresta \((u_2,v)\) (em vermelho) tem custo zero e será selecionada para \(F^*\).}
	\label{fig:normalize-example}
\end{figure}

Observe que as diferenças relativas são preservadas: a aresta mais cara permanece 4 unidades acima da mais barata, e a intermediária mantém sua posição relativa. Como cada r-arborescência contém exatamente uma aresta entrando em cada vértice não-raiz, a soma \(\sum_{w\neq r} y(w)\) é constante para qualquer solução, garantindo que a ordem de otimalidade seja preservada.

\subsection{Construção de \texorpdfstring{\(F^*\)}{F*}:}
Esta função constrói o subdigrafo \(F^*\) selecionando, para cada vértice \(v\neq r_0\), uma única aresta de custo reduzido zero que entra em \(v\).

Recebe como entrada um digrafo \texttt{D} (objeto \texttt{nx.DiGraph}) e o rótulo \texttt{r0} da raiz. A implementação cria um novo digrafo vazio \texttt{F\_star} (linha 2) em vez de modificar \texttt{D} diretamente; essa escolha de criar uma estrutura separada é fundamental porque \(F^*\) é um subgrafo conceitual usado para detecção de ciclos, e preservar \texttt{D} inalterado permite que as operações subsequentes (como contração) trabalhem com o grafo original completo, evitando perda de informação sobre arestas não selecionadas que podem ser necessárias após reexpansões.

Em seguida, para cada vértice \texttt{v} diferente de \texttt{r0} (linhas 3--4), utilizando o método \texttt{D.nodes()}, coleta todas as arestas de entrada de \texttt{v} com seus pesos em uma lista e armazena na variável \texttt{in\_edges} (linha 5); a materialização em lista é necessária porque a subsequente iteração sobre as arestas para encontrar aquela de peso zero poderia causar problemas se trabalhássemos diretamente com a visão retornada por \texttt{in\_edges}, especialmente em cenários de modificação concorrente. Se não houver arestas de entrada, prossegue para o próximo vértice (linhas 6--7) usando \texttt{continue}, pois um vértice isolado ou inacessível não contribui para \(F^*\) e sua ausência será detectada posteriormente como violação das hipóteses de conectividade.

Caso contrário, utiliza uma compreensão de gerador combinada com \texttt{next} para encontrar o primeiro predecessor \texttt{u} cuja aresta \texttt{(u, v)} tem peso zero (linha 8); a escolha de \texttt{next} com gerador em vez de uma busca exaustiva é eficiente porque interrompe a iteração assim que encontra a primeira aresta de custo zero, evitando processamento desnecessário das arestas restantes (embora teoricamente todas as arestas de custo zero sejam equivalentes, na prática apenas uma é necessária para \(F^*\)). A função \texttt{next} retorna \texttt{None} se nenhuma aresta de peso zero existir, o que teoricamente não deveria ocorrer após a normalização correta (que garante ao menos uma aresta de custo zero por vértice), mas o tratamento defensivo evita erros em casos degenerados. Se tal aresta existir, adiciona-a a \texttt{F\_star} com peso zero usando o método \texttt{add\_edge} (linhas 9--10); a especificação explícita de \texttt{w=0} garante que \(F^*\) contenha apenas arestas de custo reduzido zero, propriedade fundamental para a corretude do algoritmo.

Retorna o digrafo \texttt{F\_star} contendo exatamente uma aresta entrando em cada \(v\neq r_0\), todas com custo reduzido zero. O grafo original \texttt{D} não é modificado, preservando o estado para operações futuras. A complexidade é \(O(m)\), onde \(m\) é o número de arestas, pois cada aresta é considerada no máximo uma vez durante a iteração sobre todos os vértices: para cada um dos \(n-1\) vértices não-raiz, examina-se suas arestas de entrada (totalizando no máximo \(m\) arestas ao longo de todas as iterações), e para cada vértice a busca por aresta de peso zero é interrompida no primeiro match, resultando em tempo linear no tamanho do grafo.

\begin{tcolorbox}[
		enhanced, breakable,
		colframe=blue!60!black, colback=blue!2,
		colbacktitle=blue!15, coltitle=black,
		title={Construção de F star },
		boxed title style={sharp corners, boxrule=0.6pt},
		sharp corners, boxrule=0.6pt
	]
	\emph{Constrói o subdigrafo $F^*$ a partir do digrafo D, selecionando para cada vértice (exceto a raiz r0) uma aresta de custo reduzido zero que entra nele.}
	\tcblower
	\begin{lstlisting}[mathescape=true, language=Python]
def get_Fstar(D: nx.DiGraph, r0: str):
    F_star = nx.DiGraph()
    for v in D.nodes():
        if v != r0:
            in_edges = list(D.in_edges(v, data="w"))
            if not in_edges:
                continue
            u = next((u for u, _, w in in_edges if w == 0), None)
            if u:
                F_star.add_edge(u, v, w=0)
    return F_star
\end{lstlisting}
\end{tcolorbox}

A Figura~\ref{fig:get-fstar-example} ilustra a construção de \(F^*\):

\begin{figure}[H]
	\centering
	\input{capitulos/implementacao-chuliu/figures/fig_get_fstar_example.tex}
	\caption{Exemplo de construção de \(F^*\) a partir de um digrafo normalizado. À esquerda, o digrafo \(D\) após normalização, onde cada vértice não-raiz possui ao menos uma aresta de entrada com custo zero (em vermelho). À direita, o subgrafo \(F^*\) resultante contém apenas as arestas de custo zero selecionadas, uma por vértice. Note que \(F^*\) pode conter ciclos (como \(\{v_1, v_2\}\)) que serão tratados nas etapas subsequentes.}
	\label{fig:get-fstar-example}
\end{figure}

A detecção de ciclos é crucial, pois a presença de um ciclo em \(F^*\) indica que a escolha de arestas de custo reduzido zero não formou uma arborescência válida. Esses ciclos precisam ser tratados nas etapas subsequentes do algoritmo.

As funções de normalização por vértice e construção de \(F^*\) juntas implementam o passo 1 da descrição do algoritmo de Chu–Liu/Edmonds:

\begin{tcolorbox}[
		enhanced, breakable,
		colframe=green!60!black, colback=green!5,
		colbacktitle=green!20, coltitle=black,
		title={Passo 1 do Algoritmo de Chu–Liu/Edmonds},
		boxed title style={sharp corners, boxrule=0.6pt},
		sharp corners, boxrule=0.6pt
	]
	\textbf{Passo 1:} Para cada \(v\neq r\), escolha \(a_v\in\mathop{\mathrm{arg\,min}}_{(u,v)\in A} c(u,v)\). Defina \(y(v):=c(a_v)\) e \(F^*:=\{a_v : v\neq r\}\).
\end{tcolorbox}



\subsection{Detecção de ciclo:}
Esta função detecta a presença de um ciclo dirigido em \(F^*\) e retorna um subgrafo que o contém; se \(F^*\) for acíclico, retorna \texttt{None}.

Recebe como entrada um digrafo \texttt{F\_star} (objeto \texttt{nx.DiGraph}). A implementação utiliza um bloco \texttt{try} (linha 2) para capturar exceções caso não haja ciclo; esta escolha de tratamento por exceção é necessária porque a API do NetworkX adota o padrão EAFP (\emph{Easier to Ask for Forgiveness than Permission}), onde \texttt{nx.find\_cycle} não retorna um valor especial (como \texttt{None}) quando o grafo é acíclico, mas sim lança a exceção \texttt{NetworkXNoCycle} para sinalizar a ausência de ciclos.

Em seguida a função inicializa um conjunto vazio \texttt{nodes\_in\_cycle} (linha 3) e emprega a função \texttt{nx.find\_cycle} do NetworkX (linha 4), que realiza uma busca em profundidade (DFS) para detectar ciclos. A função \texttt{nx.find\_cycle} percorre o grafo visitando vértices e arestas: ao encontrar uma aresta \((u,v)\) onde \(v\) já está na pilha de recursão da DFS, identifica um ciclo e retorna um iterador sobre todas as arestas que compõem esse ciclo. O laço na linha 4 itera sobre essas arestas retornadas, desempacotando cada uma na forma \texttt{(u, v, \_)} (ignorando o terceiro elemento com \texttt{\_}, que contém metadados de orientação), e para cada aresta \((u,v)\) adiciona ambos os vértices ao conjunto \texttt{nodes\_in\_cycle} (linha 5); a escolha de usar conjunto em vez de lista garante que cada vértice seja adicionado apenas uma vez mesmo que o ciclo tenha múltiplas arestas incidentes, e a operação de adição tem complexidade \(O(1)\) amortizada.

Após coletar todos os vértices do ciclo, constrói e retorna uma cópia do subgrafo induzido por eles (linha 7); a cópia é necessária porque o método \texttt{subgraph} retorna apenas uma visão dinâmica sobre o grafo original.

Se nenhum ciclo existir, a exceção \texttt{nx.NetworkXNoCycle} é capturada no bloco \texttt{except} (linha 8) e a função retorna \texttt{None} (linha 9);

No final, um subgrafo contendo os vértices e arestas do ciclo detectado é retornado, ou \texttt{None} se não houver ciclo. O grafo original \texttt{F\_star} não é modificado. A complexidade é \(O(m)\), onde \(m\) é o número de arestas, pois a DFS visita cada aresta no máximo uma vez.

\begin{tcolorbox}[
		enhanced, breakable,
		colframe=blue!60!black, colback=blue!2,
		colbacktitle=blue!15, coltitle=black,
		title={Detecção de ciclo dirigido em $F^*$},
		boxed title style={sharp corners, boxrule=0.6pt},
		sharp corners, boxrule=0.6pt
	]
	\emph{Detecta um ciclo dirigido em $F^*$ e retorna um subgrafo contendo seus vértices e arestas, ou \texttt{None} se for acíclico.}
	\tcblower
	\begin{lstlisting}[mathescape=true, language=Python]
def find_cycle(F_star: nx.DiGraph):
    try:
        nodes_in_cycle = set()
        for u, v, _ in nx.find_cycle(F_star, orientation="original"):
            nodes_in_cycle.update([u, v])
        return F_star.subgraph(nodes_in_cycle).copy()
    except nx.NetworkXNoCycle:
        return None  
\end{lstlisting}
\end{tcolorbox}

A Figura~\ref{fig:find-cycle-example} ilustra o processo de detecção de ciclo:

\begin{figure}[H]
	\centering
	\input{capitulos/implementacao-chuliu/figures/fig_find_cycle_example.tex}
	\caption{Exemplo de detecção de ciclo em \(F^*\). À esquerda, o subgrafo \(F^*\) contém um ciclo formado pelos vértices \(\{v_2, v_3, v_4\}\) (destacados em amarelo). A DFS percorre o grafo e detecta o ciclo ao encontrar a aresta \((v_4, v_2)\), onde \(v_2\) já está na pilha de recursão. À direita, a função retorna uma cópia do subgrafo induzido pelos vértices do ciclo, contendo apenas os três vértices e as três arestas que formam o ciclo.}
	\label{fig:find-cycle-example}
\end{figure}

Ao detectar um ciclo, a função permite que o algoritmo de Chu–Liu/Edmonds prossiga para a etapa de contração, onde o ciclo será reduzido a um supervértice, facilitando a resolução do problema no grafo modificado.

\subsection{Contração de ciclo:}
Esta função contrai um ciclo dirigido \(C\) em um supervértice \(x_C\), redirecionando arcos incidentes e ajustando custos segundo a regra de custos reduzidos. Retorna dicionários auxiliares para reexpansão.

Recebe como entrada um digrafo \texttt{D} (objeto \texttt{nx.DiGraph}), o ciclo \texttt{C} a ser contraído e o rótulo \texttt{label} do novo supervértice. A implementação coleta os vértices de \texttt{C} em um conjunto (linha 2) para permitir verificações de pertinência em tempo \(O(1)\), essencial dado que essa operação é realizada repetidamente nos laços seguintes. Inicializa \texttt{in\_to\_cycle} (linha 3), um dicionário que tem como chave vértices externos ao ciclo e como valor tuplas \((v,w)\), onde \(v\) é o vértice do ciclo conectado a \(u\) e \(w\) é o peso da aresta \((u,v)\); essa estrutura preserva não apenas o peso mínimo, mas também o ponto exato de entrada no ciclo, informação crucial para a reexpansão posterior.

Para cada vértice \texttt{u} no digrafo \texttt{D} (linha 4), se \texttt{u} não pertence ao ciclo (linha 5), identifica a aresta de menor peso que sai de \texttt{u} e entra em \texttt{C} (linhas 6--9) usando uma compreensão de gerador: a expressão \texttt{((v, w) for \_, v, w in D.out\_edges(u, data="w") if v in cycle\_nodes)} itera sobre todas as arestas que saem de \texttt{u}, desempacota cada aresta na forma \texttt{(\_, v, w)} (ignorando a origem com \texttt{\_}, capturando o destino \texttt{v} e o peso \texttt{w}), filtra apenas aquelas cujo destino \texttt{v} pertence ao ciclo, e produz tuplas \texttt{(v, w)}; a função \texttt{min} (linha 6) então seleciona a tupla de menor peso usando \texttt{key=lambda x: x[1]} (linha 7) para comparar pelo segundo elemento (o peso), e retorna \texttt{None} se não houver arestas (linha 8). A escolha de selecionar apenas a aresta de \emph{menor peso} reflete a propriedade fundamental do algoritmo: qualquer solução ótima que conecta um vértice externo ao ciclo contraído usará necessariamente a aresta de custo mínimo, pois todas as outras seriam subótimas. Se tal aresta existir, armazena em \texttt{in\_to\_cycle} (linhas 9--10).

Em seguida, a implementação itera sobre \texttt{in\_to\_cycle} usando o método \texttt{items()}, desempacotando cada entrada na forma \texttt{(u, (v, w))}, onde \texttt{u} é o vértice externo e \texttt{(v, w)} é a tupla com o vértice do ciclo e o peso (linhas 11--12). Para cada par, cria uma aresta de \texttt{u} para \texttt{label} com peso \texttt{w}, efetivamente redirecionando as arestas de entrada para o supervértice. A separação entre coleta (linhas 4--10) e criação (linhas 11--12) é necessária porque modificar o grafo durante a iteração sobre seus vértices causaria comportamento indefinido; ao coletar primeiro todos os dados em estruturas auxiliares, garantimos que as modificações posteriores sejam seguras.

De forma análoga, constrói o dicionário \texttt{out\_from\_cycle} (linha 13) para mapear arestas que saem do ciclo. Para cada vértice \texttt{v} em \texttt{D} (linha 14), se \texttt{v} não pertence ao ciclo (linha 15), identifica a aresta de menor peso que sai de \texttt{C} e entra em \texttt{v} (linhas 16--17) usando uma compreensão de gerador análoga: a expressão \texttt{((u, w) for u, \_, w in D.in\_edges(v, data="w") if u in cycle\_nodes)} itera sobre todas as arestas que entram em \texttt{v}, desempacota cada aresta na forma \texttt{(u, \_, w)} (capturando a origem \texttt{u}, ignorando o destino com \texttt{\_}, e capturando o peso \texttt{w}), filtra apenas aquelas cuja origem \texttt{u} pertence ao ciclo, e produz tuplas \texttt{(u, w)}; a função \texttt{min} seleciona a de menor peso pela mesma razão de otimalidade. Se existir, armazena em \texttt{out\_from\_cycle} (linhas 18--19). Depois, itera sobre \texttt{out\_from\_cycle} e cria arestas de \texttt{label} para cada vértice \texttt{v} com os respectivos pesos (linhas 20--21). Por fim, remove todos os vértices de \texttt{C} do grafo (linha 22); essa remoção é realizada por último para garantir que todas as operações de consulta (linhas 4--21) tenham acesso aos dados originais antes da modificação estrutural.

Retorna dois dicionários: \texttt{in\_to\_cycle} mapeia vértices externos aos pontos de entrada no ciclo original, e \texttt{out\_from\_cycle} mapeia vértices externos aos pontos de saída. Esses dicionários são essenciais para a fase de reexpansão, onde será necessário determinar exatamente qual aresta interna do ciclo deve ser removida para restaurar a propriedade de arborescência. O digrafo \texttt{D} é modificado in-place: os vértices de \texttt{C} são removidos e substituídos por \texttt{label}. A escolha de modificação in-place (em vez de criar uma cópia) reduz significativamente o uso de memória e o tempo de execução, especialmente em grafos grandes ou com múltiplos níveis de recursão, embora exija atenção cuidadosa ao gerenciamento de referências. A complexidade é \(O(m)\), onde \(m\) é o número de arestas, pois cada aresta incidente ao ciclo é processada uma vez: os laços nas linhas 4--10 e 14--19 examinam cada aresta no máximo uma vez, e as operações de adição (linhas 11--12, 20--21) e remoção (linha 22) têm custo proporcional ao número de arestas afetadas.

\begin{tcolorbox}[
		enhanced, breakable,
		colframe=blue!60!black, colback=blue!2,
		colbacktitle=blue!15, coltitle=black,
		title={Contração de ciclo},
		boxed title style={sharp corners, boxrule=0.6pt},
		sharp corners, boxrule=0.6pt
	]
	\emph{Contrai o ciclo $C$ em um supervértice \texttt{label}, redirecionando arcos incidentes e ajustando custos. Modifica $D$ in-place e retorna dicionários para reexpansão.}
	\tcblower
	\begin{lstlisting}[mathescape=true, language=Python]
def contract_cycle(D: nx.DiGraph, C: nx.DiGraph, label: str):
    cycle_nodes: set[str] = set(C.nodes())
    in_to_cycle: dict[str, tuple[str, float]] = {}
    for u in D.nodes:
        if u not in cycle_nodes:
            min_weight_edge_to_cycle = min(
                ((v, w) for _, v, w in D.out_edges(u, data="w") if v in cycle_nodes),
                key=lambda x: x[1],
                default=None,)
            if min_weight_edge_to_cycle:
                in_to_cycle[u] = min_weight_edge_to_cycle
    for u, (v, w) in in_to_cycle.items():
        D.add_edge(u, label, w=w)
    out_from_cycle: dict[str, tuple[str, float]] = {}
    for v in D.nodes:
        if v not in cycle_nodes:
            min_weight_edge_from_cycle = min(
                ((u, w) for u, _, w in D.in_edges(v, data="w") if u in cycle_nodes),key=lambda x: x[1], default=None,)
            if min_weight_edge_from_cycle:
                out_from_cycle[v] = min_weight_edge_from_cycle
    for v, (u, w) in out_from_cycle.items():
        D.add_edge(label, v, w=w)
    D.remove_nodes_from(cycle_nodes)
    return in_to_cycle, out_from_cycle  
\end{lstlisting}
\end{tcolorbox}

A Figura~\ref{fig:contract-cycle-example} ilustra o processo de contração de ciclo:

\begin{figure}[H]
	\centering
	\input{capitulos/implementacao-chuliu/figures/fig_contract_cycle_example.tex}
	\caption{Exemplo de contração de ciclo. À esquerda, grafo original \(D\) com ciclo \(C=\{v_2, v_3, v_4\}\) (em amarelo). Vértices externos \(r\), \(v_1\) e \(v_5\) têm arestas conectando ao ciclo: \(r\) envia aresta para \(v_2\) (peso 2) e \(v_4\) (peso 5); \(v_4\) envia aresta para \(v_5\) (peso 1). À direita, após a contração: o ciclo é substituído pelo supervértice \(x_C\) (vermelho). As arestas de entrada são redirecionadas: \((r, x_C)\) recebe peso 2 (menor entre 2 e 5). A aresta de saída \((x_C, v_5)\) mantém peso 1. Os dicionários \texttt{in\_to\_cycle} e \texttt{out\_from\_cycle} armazenam os mapeamentos originais para posterior reexpansão.}
	\label{fig:contract-cycle-example}
\end{figure}

A função de deteção de ciclo e a de contração juntas implementam os passos 2 e 3 da descrição do algoritmo de Chu–Liu/Edmonds:

\begin{tcolorbox}[
		enhanced, breakable,
		colframe=green!60!black, colback=green!5,
		colbacktitle=green!20, coltitle=black,
		title={Passos 2 e 3 do Algoritmo de Chu–Liu/Edmonds},
		boxed title style={sharp corners, boxrule=0.6pt},
		sharp corners, boxrule=0.6pt
	]
	\textbf{Passo 2:} Se \((V,F^*)\) é acíclico, devolva \(F^*\). Por \cite[Obs.~4.36]{kleinberg2006}, trata-se de uma r-arborescência de custo mínimo.

	\textbf{Passo 3:} Caso contrário, seja \(C\) um ciclo dirigido de \(F^*\) (com \(r\notin C\)). \textbf{Contração:} contraia \(C\) em um supervértice \(x_C\) e defina custos \(c'\) por
	\begin{align*}
		c'(u,x_C) & := c(u,w) - y(w) = c(u,w) - c(a_w) &  & \text{para } u\notin C,\ w\in C, \\
		c'(x_C,v) & := c(w,v)                          &  & \text{para } w\in C,\ v\notin C,
	\end{align*}
	descartando laços em \(x_C\) e permitindo paralelos. Denote o digrafo contraído por \(D'=(V',A')\).
\end{tcolorbox}

\subsection{Remoção de arestas que entram na raiz:}
Esta função remove todas as arestas que entram no vértice raiz \(r_0\), garantindo que a raiz não tenha predecessores. A remoção é necessária porque, por definição, uma r-arborescência é uma arborescência enraizada em \(r_0\) onde todo vértice \(v \neq r_0\) deve ser alcançável a partir de \(r_0\), mas a própria raiz não pode ter predecessores (grau de entrada zero). Se o grafo original contiver arestas entrando em \(r_0\), essas arestas violariam a definição de arborescência enraizada e poderiam criar ciclos envolvendo a raiz, o que tornaria impossível obter uma estrutura válida. Além disso, a presença de arestas entrando na raiz interfere na normalização: ao tentar normalizar custos de entrada para \(r_0\), criaríamos custos reduzidos artificiais que não fazem sentido no contexto do problema, já que nenhuma solução válida pode incluir tais arestas. Portanto, esta função atua como um passo de pré-processamento essencial que prepara o grafo para os passos subsequentes do algoritmo.

A escolha de implementar esta operação como uma função auxiliar separada (em vez de incluí-la apenas inline na função principal) segue princípios de design de software: (1) \emph{modularidade}, encapsulando uma responsabilidade específica e bem definida (remover entradas na raiz) em uma unidade testável independente; (2) \emph{reutilização}, permitindo que outras partes do código ou implementações alternativas possam chamar esta operação quando necessário sem duplicar lógica; (3) \emph{clareza semântica}, dando um nome descritivo (\texttt{remove\_edges\_to\_r0}) que documenta a intenção da operação no ponto de chamada, tornando a função principal mais legível ao abstrair detalhes de implementação; e (4) \emph{facilidade de teste}, possibilitando escrever testes unitários focados exclusivamente nesta operação de pré-processamento, verificando casos extremos (como grafos onde a raiz já não tem predecessores ou onde todas as arestas entram na raiz) sem precisar testar toda a complexidade do algoritmo recursivo.

Em detalhes, ela recebe como entrada um digrafo \texttt{D} (objeto \texttt{nx.DiGraph}) e o rótulo \texttt{r0} da raiz. A implementação armazena em uma lista todas as arestas que entram em \texttt{r0} usando o método \texttt{in\_edges} (linha 2). Se a lista não estiver vazia (linha 3), remove todas essas arestas usando o método \texttt{remove\_edges\_from} (linha 4). Este método da biblioteca NetworkX recebe como parâmetro uma lista de tuplas representando arestas na forma \texttt{(u, v)} e remove cada uma delas do grafo. A operação é realizada em lote: NetworkX itera sobre a lista fornecida e, para cada tupla \texttt{(u, v)}, remove a aresta correspondente da estrutura interna de adjacência. Se alguma aresta especificada não existir no grafo, ela é silenciosamente ignorada sem gerar erro. A complexidade de \texttt{remove\_edges\_from} é \(O(k)\), onde \(k\) é o número de arestas na lista de entrada, pois cada remoção individual tem custo \(O(1)\) em média devido ao uso de dicionários aninhados para armazenar arestas.

Por fim, a função retorna o grafo \texttt{D} atualizado in-place com todas as arestas de entrada em \texttt{r0} são removidas (linha 5). A complexidade total da função é \(O(\deg^-(r_0))\), pois a operação coleta e remove cada aresta de entrada uma única vez.

\begin{tcolorbox}[
		enhanced, breakable,
		colframe=blue!60!black, colback=blue!2,
		colbacktitle=blue!15, coltitle=black,
		title={Remoção de arestas que entram na raiz},
		boxed title style={sharp corners, boxrule=0.6pt},
		sharp corners, boxrule=0.6pt
	]
	\emph{Remove todas as arestas que entram na raiz \texttt{r0}, modificando \texttt{D} in-place e retornando o grafo atualizado.}
	\tcblower
	\begin{lstlisting}[mathescape=true, language=Python]
def remove_edges_to_r0(D: nx.DiGraph, r0: str):
    in_edges = list(D.in_edges(r0))
    if in_edges:
        D.remove_edges_from(in_edges)
    return D
\end{lstlisting}
\end{tcolorbox}


\subsection{Remoção de arco interno:}

Esta função é invocada durante a fase de reexpansão do ciclo contraído, após a chamada recursiva retornar com a arborescência ótima \(T'\) do grafo contraído. Quando o supervértice \(x_C\) é expandido de volta para o ciclo original \(C\), uma aresta externa \((u,v)\) é adicionada conectando um vértice externo \(u\) a um vértice \(v\) dentro do ciclo. Como o ciclo \(C\) originalmente continha exatamente uma aresta entrando em cada um de seus vértices (formando um ciclo fechado), e agora \(v\) recebe uma aresta adicional vinda do exterior, esse vértice teria grau de entrada 2, violando a propriedade fundamental de arborescência (cada vértice não-raiz deve ter exatamente uma entrada). Para restaurar essa propriedade, a função remove a aresta interna que anteriormente entrava em \(v\), mantendo apenas a nova aresta externa. Essa remoção "quebra" o ciclo no ponto de entrada, transformando-o em um caminho que se integra corretamente à estrutura de árvore.

A função recebe como entrada o subgrafo do ciclo \texttt{C} (objeto \texttt{nx.DiGraph}) e o vértice de entrada \texttt{v}. A implementação utiliza uma compreensão de gerador combinada com \texttt{next} para encontrar o predecessor de \texttt{v} dentro do ciclo (linha 2): a expressão \texttt{(u for u, \_ in C.in\_edges(v))} itera sobre as arestas de entrada de \texttt{v}, extraindo apenas o vértice origem \texttt{u} (ignorando metadados com \texttt{\_}), e \texttt{next} retorna o primeiro (e teoricamente único) predecessor. Em seguida, remove a aresta \texttt{(predecessor, v)} do ciclo usando o método \texttt{remove\_edge} (linha 3).

A função modifica o subgrafo \texttt{C} in-place e não retorna valor. A complexidade é \(O(\deg^-(v))\), dominada pela operação de busca das arestas de entrada, embora em ciclos simples isso seja tipicamente \(O(1)\) pois cada vértice tem exatamente um predecessor.

\begin{tcolorbox}[
		enhanced, breakable,
		colframe=blue!60!black, colback=blue!2,
		colbacktitle=blue!15, coltitle=black,
		title={Remover arco interno na reexpansão},
		boxed title style={sharp corners, boxrule=0.6pt},
		sharp corners, boxrule=0.6pt
	]
	\emph{Remove a aresta interna que entra no vértice de entrada \texttt{v} do ciclo \texttt{C} durante a reexpansão, pois \texttt{v} passa a receber uma aresta externa, e manter ambas violaria a propriedade de arborescência.}
	\tcblower
	\begin{lstlisting}[mathescape=true, language=Python]
def remove_internal_edge_to_cycle_entry(C: nx.DiGraph, v):
    predecessor = next((u for u, _ in C.in_edges(v)), None)
    C.remove_edge(predecessor, v) 
\end{lstlisting}
\end{tcolorbox}

A Figura~\ref{fig:remove-internal-edge-example} ilustra o objetivo da função:

\begin{figure}[H]
	\centering
	\input{capitulos/implementacao-chuliu/figures/fig_remove_internal_edge_example.tex}
	\caption{Remoção de aresta interna durante reexpansão. À esquerda, ciclo $C=\{v_2, v_3, v_4\}$ após adicionar aresta externa $(u, v_2)$ vindoura da arborescência $T'$: o vértice $v_2$ tem grau de entrada 2 (aresta externa vermelha de $u$ e aresta interna do ciclo vinda de $v_4$), violando a propriedade de arborescência. À direita, após remover a aresta interna $(v_4, v_2)$: o vértice $v_2$ passa a ter grau de entrada 1, o ciclo é "quebrado" no ponto de entrada, transformando-se em um caminho que se integra corretamente à estrutura de árvore. A aresta removida é mostrada tracejada em cinza.}
	\label{fig:remove-internal-edge-example}
\end{figure}

\subsection{Procedimento principal (recursivo):}
Esta função implementa o algoritmo de Chu–Liu/Edmonds de forma recursiva, orquestrando todas as funções auxiliares descritas anteriormente. Recebe como entrada um digrafo ponderado \texttt{D} (objeto \texttt{nx.DiGraph}), o vértice raiz \texttt{r0}, e um parâmetro \texttt{level} (padrão 0) usado para rotular supervértices em níveis recursivos distintos.

A implementação segue a estrutura do algoritmo:

\paragraph*{Preservação do grafo original (linha 2):} Cria uma cópia \texttt{D\_copy = D.copy()} para preservar os pesos originais. Como as operações de normalização e contração modificam os pesos das arestas in-place, a cópia é necessária para restaurar os custos corretos na arborescência final. Complexidade: \(O(m+n)\).

\paragraph*{Normalização e construção de \(F^*\) (linhas 3--6):} Itera sobre todos os vértices não-raiz (linhas 3--5), chamando \texttt{normalize\_incoming\_edge\_weights(D\_copy, v)} para cada um. Após normalizar todos os vértices, constrói \(F^*\) (linha 6) chamando \texttt{get\_Fstar(D\_copy, r0)}, que seleciona uma aresta de custo reduzido zero entrando em cada vértice não-raiz.

\paragraph*{Verificação de aciclicidade — caso base (linhas 7--10):} Verifica se \(F^*\) é uma arborescência válida usando \texttt{nx.is\_arborescence(F\_star)} (linha 7). Se sim, restaura os pesos originais de \texttt{D} para cada aresta de \(F^*\) (linhas 8--9) e retorna \texttt{F\_star} como solução (linha 10). A função \texttt{nx.is\_arborescence} testa conectividade, aciclicidade e grau de entrada correto simultaneamente.

\paragraph*{Contração e resolução recursiva — caso recursivo (linhas 11--16):} Caso \(F^*\) contenha um ciclo, detecta \(C\) chamando \texttt{find\_cycle(F\_star)} (linha 12). Cria um rótulo único \texttt{contracted\_label = f"contracted\_\{level\}"} para o supervértice (linha 13). Contrai o ciclo chamando \texttt{contract\_cycle(D\_copy, C, contracted\_label)} (linhas 14--15), que modifica \texttt{D\_copy} in-place criando o digrafo contraído \(D'\) e retorna os dicionários \texttt{in\_to\_cycle} e \texttt{out\_from\_cycle}. Chama-se recursivamente (linha 16) com \texttt{find\_optimum\_arborescence\_chuliu(D\_copy, r0, level+1)}, obtendo \(F'\).

\paragraph*{Reexpansão do ciclo contraído (linhas 17--30):} Identifica a aresta externa que entra no supervértice em \(F'\) (linha 17) e extrai o vértice externo \texttt{u} (linha 18). Consulta \texttt{v = in\_to\_cycle[u]} para determinar o vértice do ciclo que recebe a conexão (linha 19). Remove a aresta interna que entrava em \(v\) chamando \texttt{remove\_internal\_edge\_to\_cycle\_entry(C, v)} (linha 20), quebrando o ciclo no ponto de entrada. Adiciona a aresta externa \texttt{(u, v)} a \(F'\) (linha 21) e reintegra as demais arestas do ciclo (linhas 22--23). Processa as arestas de saída (linhas 24--26): para cada \texttt{(contracted\_label, w)} em \(F'\), adiciona \texttt{(v\_out, w)} usando \texttt{out\_from\_cycle[w]}. Remove o supervértice (linha 27), restaura os pesos originais (linhas 28--29) e retorna \texttt{F\_prime} (linha 30).

A função retorna um digrafo contendo exatamente \(|V|-1\) arestas onde cada vértice \(v \neq r_0\) tem grau de entrada 1, todos os vértices são alcançáveis a partir de \(r_0\), e o custo total é mínimo. O grafo original \texttt{D} não é modificado devido à cópia (linha 2). A complexidade é \(O(mn)\) no pior caso, onde cada nível de recursão (até \(O(n)\) níveis) processa \(O(m)\) arestas durante normalização, detecção de ciclos e contração/expansão.

O código completo da função principal é apresentado a seguir:

\begin{tcolorbox}[
		enhanced, breakable,
		colframe=blue!60!black, colback=blue!2,
		colbacktitle=blue!15, coltitle=black,
		title={Procedimento principal (recursivo)},
		boxed title style={sharp corners, boxrule=0.6pt},
		sharp corners, boxrule=0.6pt
	]
	\emph{Implementa o algoritmo de Chu–Liu/Edmonds de forma recursiva para encontrar a r-arborescência de custo mínimo em um digrafo ponderado \texttt{D} com raiz \texttt{r0}. Normaliza custos, constrói $F^*$, detecta ciclos e, se houver, contrai em supervértice, resolve recursivamente no grafo reduzido e reexpande, restaurando a arborescência ótima no grafo original. Retorna um \texttt{nx.DiGraph} contendo exatamente $|V|-1$ arestas com grau de entrada 1 para cada vértice exceto a raiz.}
	\tcblower
	\begin{lstlisting}[mathescape=true, language=Python]
def find_optimum_arborescence_chuliu(D: nx.DiGraph,r0: str,level=0,):
    D_copy = D.copy()
    for v in D_copy.nodes:
        if v != r0:
            normalize_incoming_edge_weights(D_copy, v)
    F_star = get_Fstar(D_copy, r0)
    if nx.is_arborescence(F_star):
        for u, v in F_star.edges:
            F_star[u][v]["w"] = D[u][v]["w"]
        return F_star
    else:
        C: nx.DiGraph = find_cycle(F_star)   
        contracted_label = f"\n n*{level}"
        in_to_cycle, out_from_cycle = contract_cycle(
        D_copy, C, contracted_label)
        F_prime = find_optimum_arborescence_chuliu(D_copy,r0,level + 1)
        in_edge = next(iter(F_prime.in_edges(contracted_label, data="w")), None)
        u, _, _ = in_edge
        v, _ = in_to_cycle[u]
        remove_internal_edge_to_cycle_entry(C, v)
        F_prime.add_edge(u, v)
        for u_c, v_c in C.edges:
            F_prime.add_edge(u_c, v_c)
        for _, z, _ in F_prime.out_edges(contracted_label, data=True):
            u_cycle, _ = out_from_cycle[z]
            F_prime.add_edge(u_cycle, z)
        F_prime.remove_node(contracted_label)
        for u, v in F_prime.edges:
            F_prime[u][v]["w"] = D[u][v]["w"]
        return F_prime 
\end{lstlisting}
\end{tcolorbox}

A seguir, ilustramos o funcionamento do algoritmo de Chu–Liu/Edmonds em um grafo de teste. Mostramos o grafo original, os principais passos do algoritmo e a arborescência final encontrada.

\subsubsection{Exemplo de execução do algoritmo}

A seguir, demonstramos a execução completa do algoritmo de Chu--Liu/Edmonds em um grafo exemplo, ilustrando cada fase do processo: normalização, construção de $F^*$, detecção de ciclos, contração, resolução recursiva e reexpansão.

\begin{figure}[H]
	\centering
	\input{capitulos/implementacao-chuliu/figures/fig_exemplo_grafo_inicial.tex}
	\caption{Grafo direcionado ponderado inicial com raiz no vértice 0. O grafo contém 9 vértices e múltiplas arestas com pesos variados. O primeiro passo do algoritmo seria remover arestas que entram na raiz, porém não há nenhuma neste caso, logo não existe necessidade de alterar o grafo.}
	\label{fig:exemplo-grafo-inicial}
\end{figure}

O primeiro passo do nosso algoritmo seria remover as arestas que entram na raiz (vértice $0$), porém não há nenhuma nesse caso, logo não existe a necessidade de alterar o grafo.

O próximo passo é normalizar os pesos das arestas de entrada para cada vértice. Nessa etapa, para cada vértice $v$ (exceto a raiz), o algoritmo encontra a aresta de menor peso que entra em $v$ e subtrai esse menor peso de todas as arestas que entram em $v$ (isso serve para zerar o peso da aresta mínima de entrada em cada vértice).

\begin{figure}[H]
	\centering
	\input{capitulos/implementacao-chuliu/figures/fig_exemplo_normalizacao_parcial.tex}
	\caption{Normalização parcial das arestas de entrada para o vértice 1. As arestas de entrada são $(0 \to 1)$ com peso original 3 e $(2 \to 1)$ com peso original 1. Elegendo a aresta $(2 \to 1)$ como a de menor peso (peso mínimo = 1), subtraímos este valor de todas as arestas de entrada: $(0 \to 1)$ passa de peso 3 para 2, e $(2 \to 1)$ passa de peso 1 para 0 (destacadas em vermelho). Esse processo é repetido para todos os demais vértices.}
	\label{fig:exemplo-normalizacao-parcial}
\end{figure}

Com os pesos normalizados, o próximo passo é construir $F^*$: para isso, selecionamos para cada vértice a aresta de custo reduzido zero de entrada. Detectamos um ciclo em $F^*$, formado pelos vértices $\{1, 2\}$. Portanto, precisamos contrair esse ciclo em um supervértice $n*0$.

\begin{figure}[H]
	\centering
	\input{capitulos/implementacao-chuliu/figures/fig_exemplo_grafo_contraido.tex}
	\caption{Grafo contraído após detecção do ciclo $C = \{1, 2\}$ em $F^*$. O ciclo foi contraído no supervértice $n*0$ (destacado em vermelho). As arestas que entravam ou saíam do ciclo foram redirecionadas para o supervértice, com custos ajustados segundo as fórmulas $c'(u,x_C) := c(u,w) - y(w)$ para arestas de entrada e $c'(x_C,v) := c(w,v)$ para arestas de saída.}
	\label{fig:exemplo-grafo-contraido}
\end{figure}

Agora, repetimos o processo recursivamente no grafo contraído até obter uma arborescência válida.

\begin{figure}[H]
	\centering
	\input{capitulos/implementacao-chuliu/figures/fig_exemplo_arborescencia_contraida.tex}
	\caption{Arborescência ótima $F'$ obtida no grafo contraído. Todas as arestas selecionadas têm custo reduzido 0 (destacados em vermelho), e o grafo forma uma arborescência válida enraizada em 0: cada vértice (exceto a raiz) tem exatamente uma aresta de entrada, não há ciclos, e todos os vértices são alcançáveis a partir da raiz. Como $F'$ é acíclico, alcançamos o caso base da recursão.}
	\label{fig:exemplo-arborescencia-contraida}
\end{figure}

Após validarmos que $F^*$ não possui mais ciclos e forma uma arborescência, iniciamos o processo de reexpansão do ciclo contraído para obter a arborescência final no grafo original. Adicionamos a aresta de entrada ao ciclo $(0, 1)$, as arestas internas do ciclo modificado $(1, 2)$, e as arestas de saída $(1, 3)$, chegando a uma arborescência válida.

\begin{figure}[H]
	\centering
	\input{capitulos/implementacao-chuliu/figures/fig_exemplo_arborescencia_final.tex}
	\caption{Arborescência ótima final no grafo original com pesos restaurados. O supervértice $n*0$ foi expandido de volta para os vértices 1 e 2, com a aresta externa $(0, 1)$ escolhida pela solução recursiva conectando ao ciclo. A aresta interna $(2, 1)$ do ciclo original foi removida para manter a propriedade de arborescência ($\deg^{-}(v)=1$). O resultado é uma 0-arborescência de custo mínimo com exatamente 8 arestas, onde cada vértice não-raiz tem grau de entrada 1 e todos são alcançáveis a partir da raiz 0.}
	\label{fig:exemplo-arborescencia-final}
\end{figure}

\subsection{Correspondência entre teoria e implementação}

A implementação em Python segue fielmente os cinco passos da descrição teórica do algoritmo de Chu–Liu/Edmonds apresentada na Seção anterior. A tabela abaixo estabelece o paralelo direto entre cada passo teórico e sua realização no código:

\begin{table}[H]
	\centering
	\footnotesize
	\renewcommand{\arraystretch}{1.4}
	\begin{tabular}{>{\raggedright\arraybackslash}p{0.46\textwidth}|>{\raggedright\arraybackslash}p{0.46\textwidth}}
		\toprule
		\textbf{\large Descrição Teórica} & \textbf{\large Implementação Python} \\
		\midrule
		\rowcolor{blue!5}
		\textbf{Passo 1:} Normalização e construção de \(F^*\)

		Para cada \(v\neq r\), escolha \(a_v\in\mathop{\mathrm{arg\,min}}_{(u,v)\in A} c(u,v)\).

		Defina \(y(v):=c(a_v)\) e \(F^*:=\{a_v : v\neq r\}\).
		                                  &
		\textbf{Linhas 3--6:}

		\texttt{for v in D\_copy.nodes:}

		\quad \texttt{normalize\_incoming\_edge\_weights(D\_copy, v)}

		\texttt{F\_star = get\_Fstar(D\_copy, r0)}

		\vspace{2mm}
		Calcula \(y(v)\) e cria custos reduzidos, depois constrói \(F^*\) selecionando arestas de custo zero.
		\\
		\midrule
		\rowcolor{green!5}
		\textbf{Passo 2:} Verificação de aciclicidade (caso base)

		Se \((V,F^*)\) é acíclico, devolva \(F^*\). Por Obs. 4.36 de \cite{kleinberg2006}, trata-se de uma r-arborescência de custo mínimo.
		                                  &
		\textbf{Linhas 7--10:}

		\texttt{if nx.is\_arborescence(F\_star):}

		\quad \texttt{[restaura pesos originais]}

		\quad \texttt{return F\_star}

		\vspace{2mm}
		Testa conectividade, aciclicidade e grau de entrada correto simultaneamente.
		\\
		\midrule
		\rowcolor{orange!5}
		\textbf{Passo 3:} Contração de ciclo

		Caso contrário, seja \(C\) um ciclo dirigido de \(F^*\) (com \(r\notin C\)). Contraia \(C\) em supervértice \(x_C\) e defina custos \(c'\) por:

		\(c'(u,x_C) := c(u,w) - y(w)\)

		\(c'(x_C,v) := c(w,v)\)

		Denote o digrafo contraído por \(D'=(V',A')\).
		                                  &
		\textbf{Linhas 11--15:}

		\texttt{C = find\_cycle(F\_star)}

		\texttt{label = f"contracted\_\{level\}"}

		\texttt{in\_to\_cycle, out\_from\_cycle =}

		\quad \texttt{contract\_cycle(D\_copy, C, label)}

		\vspace{2mm}
		Implementa as fórmulas de ajuste de custos e modifica \texttt{D\_copy} para criar \(D'\).
		\\
		\midrule
		\rowcolor{purple!5}
		\textbf{Passo 4:} Resolução recursiva

		Resolva recursivamente em \(D'\), obtendo arborescência ótima \(F'\).
		                                  &
		\textbf{Linha 16:}

		\texttt{F\_prime = find\_optimum\_arborescence\_chuliu(}

		\quad \texttt{D\_copy, r0, level+1)}

		\vspace{2mm}
		Chamada recursiva resolve o problema no grafo contraído.
		\\
		\midrule
		\rowcolor{red!5}
		\textbf{Passo 5:} Reexpansão

		Expanda \(x_C\) para o ciclo original \(C\). Se \((u,x_C)\in F'\), adicione \((u,v)\) onde \(v\) é o vértice do ciclo mapeado por \(u\), remova a aresta interna entrando em \(v\), e reintegre demais arestas de \(C\). Restaure custos originais.
		                                  &
		\textbf{Linhas 17--30:}

		\texttt{v = in\_to\_cycle[u]}

		\texttt{remove\_internal\_edge\_to\_cycle\_entry(C, v)}

		\texttt{F\_prime.add\_edge(u, v)}

		\texttt{F\_prime.add\_edges\_from(C.edges)}

		\texttt{[processa saídas, remove supervértice]}

		\texttt{[restaura pesos originais]}
		\\
		\bottomrule
	\end{tabular}
	\caption{Correspondência entre os cinco passos teóricos do algoritmo de Chu–Liu/Edmonds e sua implementação em Python. Cada linha da coluna direita mostra a tradução direta dos conceitos matemáticos da coluna esquerda em operações concretas sobre grafos.}
	\label{tab:teoria-implementacao}
\end{table}

Esta correspondência demonstra que a implementação não é uma aproximação ou interpretação livre da teoria, mas uma tentativa de traduzir fielmente a descrição teórica. As funções auxiliares (\texttt{normalize\_incoming\_edge\_weights}, \texttt{get\_Fstar}, \texttt{find\_cycle}, \texttt{contract\_cycle}, \texttt{remove\_internal\_edge\_to\_cycle\_entry}) encapsulam exatamente as operações descritas na formulação teórica, preservando as propriedades de correção e complexidade do algoritmo original.

\subsection{Transição para a abordagem primal-dual}

Embora o algoritmo de Chu–Liu/Edmonds seja elegante e eficiente, sua mecânica operacional — normalizar custos, selecionar mínimos, contrair ciclos — pode parecer um conjunto de heurísticas bem-sucedidas sem uma justificativa teórica unificadora aparente. Por que escolher a melhor entrada para cada vértice garante otimalidade global após o tratamento de ciclos? A resposta reside na \emph{dualidade em programação linear}.


No capítulo seguinte, revisitaremos o mesmo problema sob uma ótica primal–dual em duas fases, proposta por András Frank. Essa perspectiva organiza a normalização via potenciais\footnote{No contexto primal–dual, “potenciais” são valores escalares \(y(v)\) atribuídos aos vértices para definir custos reduzidos \(c'(u,v)=c(u,v)-y(v)\). Ajustar \(y\) desloca uniformemente os custos das arestas que entram em \(v\), sem mudar a otimalidade global: preserva a ordem relativa entre entradas e torna “apertadas” (custo reduzido zero) as candidatas corretas, habilitando contrações e uma prova de corretude via cortes apertados.} \(y(\cdot)\), explica os custos reduzidos e introduz a noção de cortes apertados (família laminar) como guias das contrações. Veremos como a mesma mecânica operacional (normalizar \(\to\) contrair \(\to\) expandir) emerge de condições duais que também sugerem otimizações e generalizações.
